#line 1 "sessile-ibm-axi-osc-cpp.c"
#line 1 "<built-in>"
#line 1 "<command-line>"
#line 1 "/usr/include/stdc-predef.h"
#line 1 "<command-line>"
#line 1 "sessile-ibm-axi-osc-cpp.c"
#if 700 < 700
  #undef 700
  #define 700 700
#endif
#if _GNU_SOURCE
#include <stdint.h>
#include <string.h>
#include <fenv.h>
#endif



#line 1 "/home/spencer/basilisk/src/common.h"
typedef double number; 






number macro_min (number a, number b) { return a < b ? a : b; } 
number macro_sq (number x) { return x*x; } 
number macro_cube (number x) { return x*x*x; } 
int macro_sign (number x) { return (int)(x > 0 ? 1 : -1); } 
int macro_sign2 (number x) { return (int)(x > 0 ? 1 : x < 0 ? -1 : 0); } 
number macro_clamp (number x, number a, number b) {
  return x < a ? a : x > b ? b : x;
} 



#line 1 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/stdlib.h"
#include <stdlib.h>
#line 2 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/stdio.h"
#include <stdio.h>
#line 3 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/stddef.h"
#include <stddef.h>
#line 4 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/stdint.h"
#include <stdint.h>
#line 5 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/stdbool.h"
#include <stdbool.h>
#line 6 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/stdarg.h"
#include <stdarg.h>
#line 7 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/string.h"
#include <string.h>
#line 8 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/float.h"
#include <float.h>
#line 9 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/limits.h"
#include <limits.h>
#line 10 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/math.h"
#include <math.h>
#line 11 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/time.h"
#include <time.h>
#line 12 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/sys/time.h"
#include <sys/time.h>
#line 13 "/home/spencer/basilisk/src/grid/config.h"
#line 1 "/home/spencer/basilisk/src/ast/std/sys/resource.h"
#include <sys/resource.h>
#line 14 "/home/spencer/basilisk/src/grid/config.h"




#define unmap(x,y)
#define trash(x)


void macro_BEGIN_FOREACH() {;}
#line 52 "/home/spencer/basilisk/src/grid/config.h"
# define OMP(x)
void macro_OMP_SERIAL() {;}
#line 69 "/home/spencer/basilisk/src/grid/config.h"
#define _NVARMAX 65536
#define is_constant(v) ((v).i >= _NVARMAX)
#define constant(v) (is_constant(v) ? _constant[(v).i - _NVARMAX] : 1e30f)

#define systderr stderr
#define systdout stdout
#line 89 "/home/spencer/basilisk/src/grid/config.h"
# define qstderr() stderr
# define qstdout() stdout
# define ferr stderr
# define fout stdout
# define not_mpi_compatible()



static inline void qassert (const char * file, int line, const char * cond) {
  fprintf (ferr, "%s:%d: Assertion `%s' failed.\n", file, line, cond);
  abort();
}







#define sysmalloc malloc
#define syscalloc calloc
#define sysrealloc realloc
#define sysfree free
#define systrdup strdup




# define pmalloc(s,func,file,line) malloc(s)
# define pcalloc(n,s,func,file,line) calloc(n,s)
# define prealloc(p,s,func,file,line) realloc(p,s)
# define pfree(p,func,file,line) free(p)
# define pstrdup(s,func,file,line) strdup(s)






#line 1 "/home/spencer/basilisk/src/grid/array.h"


typedef struct {
  void * p;
  long max, len;
} Array;

Array * array_new()
{
  Array * a = ((Array *) pmalloc ((1)*sizeof(Array),__func__,__FILE__,__LINE__));
  a->p = NULL;
  a->max = a->len = 0;
  return a;
}

void array_free (Array * a)
{
  pfree (a->p,__func__,__FILE__,__LINE__);
  pfree (a,__func__,__FILE__,__LINE__);
}

void * array_append (Array * a, void * elem, size_t size)
{
  if (a->len + size >= a->max) {
    a->max += ( size > 4096 ? size : 4096);
    a->p = prealloc (a->p, a->max,__func__,__FILE__,__LINE__);
  }
  memcpy (((char *)a->p) + a->len, elem, size);
  a->len += size;
  return (void *)(((char *)a->p) + a->len - size);
}

void * array_shrink (Array * a)
{
  void * p = prealloc (a->p, a->len,__func__,__FILE__,__LINE__);
  pfree (a,__func__,__FILE__,__LINE__);
  return p;
}
#line 129 "/home/spencer/basilisk/src/grid/config.h"
#line 372 "/home/spencer/basilisk/src/grid/config.h"
# define tracing(...)
# define end_tracing(...)
#line 524 "/home/spencer/basilisk/src/grid/config.h"
#define tid() 0
#define pid() 0
#define npe() 1
#define mpi_all_reduce(v,type,op)
#define mpi_all_reduce_array(v,type,op,elem)



void macro_OMP_PARALLEL() {;}
#define OMP_PARALLEL(...) OMP(omp parallel __VA_ARGS__)

#define NOT_UNUSED(x) (void)(x)

void macro1_VARIABLES() { ; }
#define _index(a,m) (a.i)
#define val(a,k,l,m) data(k,l,m)[_index(a,m)]

double _val_higher_dimension = 0.;
#line 550 "/home/spencer/basilisk/src/grid/config.h"
#if (_GNU_SOURCE || __APPLE__) && !_OPENMP && !_CADNA
double undefined;
# if __APPLE__
# include <stdint.h>
# include "fp_osx.h"
# endif
#if _GPU
# define enable_fpe(flags)
#else
# define enable_fpe(flags) feenableexcept (flags)
#endif
# define disable_fpe(flags) fedisableexcept (flags)
static void set_fpe (void) {
  int64_t lnan = 0x7ff0000000000001;
  if (!(sizeof (int64_t) == sizeof (double))) qassert ("/home/spencer/basilisk/src/grid/config.h", 564, "sizeof (int64_t) == sizeof (double)");
  memcpy (&undefined, &lnan, sizeof (double));
  enable_fpe (FE_DIVBYZERO|FE_INVALID);
}
#else
# define undefined ((double) DBL_MAX)
# define enable_fpe(flags)
# define disable_fpe(flags)
static void set_fpe (void) {}
#endif



static FILE ** qpopen_pipes = NULL;

FILE * qpopen (const char * command, const char * type)
{
  if (pid() > 0)
    return fopen ("/dev/null", type);
  FILE * fp = popen (command, type);
  if (fp) {
    FILE ** i = qpopen_pipes;
    int n = 0;
    while (i && *i) { n++; i++; }
    qpopen_pipes = (FILE * *) prealloc (qpopen_pipes, (n + 2)*sizeof(FILE *),__func__,__FILE__,__LINE__);
    qpopen_pipes[n] = fp;
    qpopen_pipes[n+1] = NULL;
  }
  return fp;
}

int qpclose (FILE * fp)
{
  if (pid() > 0)
    return fclose (fp);
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i == fp)
      *i = (FILE *) 1;
    i++;
  }
  return pclose (fp);
}

static void qpclose_all()
{
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i != (FILE *) 1)
      pclose (*i);
    i++;
  }
  pfree (qpopen_pipes,__func__,__FILE__,__LINE__);
  qpopen_pipes = NULL;
}






FILE * lfopen (const char * name, const char * mode)
{
  char fname[80];
  sprintf (fname, "%s-%d", name, pid());
  return fopen (fname, mode);
}

#line 1 "/home/spencer/basilisk/src/grid/../ast/symbols.h"

const char * symbol_name (int sym);
int token_symbol (int token);
enum yysymbol_kind_t
{
  sym_YYEMPTY = -2,
  sym_YYEOF = 0,
  sym_YYerror = 1,
  sym_YYUNDEF = 2,
  sym_IDENTIFIER = 3,
  sym_I_CONSTANT = 4,
  sym_F_CONSTANT = 5,
  sym_STRING_LITERAL = 6,
  sym_FUNC_NAME = 7,
  sym_SIZEOF = 8,
  sym_PTR_OP = 9,
  sym_INC_OP = 10,
  sym_DEC_OP = 11,
  sym_LEFT_OP = 12,
  sym_RIGHT_OP = 13,
  sym_LE_OP = 14,
  sym_GE_OP = 15,
  sym_EQ_OP = 16,
  sym_NE_OP = 17,
  sym_AND_OP = 18,
  sym_OR_OP = 19,
  sym_MUL_ASSIGN = 20,
  sym_DIV_ASSIGN = 21,
  sym_MOD_ASSIGN = 22,
  sym_ADD_ASSIGN = 23,
  sym_SUB_ASSIGN = 24,
  sym_LEFT_ASSIGN = 25,
  sym_RIGHT_ASSIGN = 26,
  sym_AND_ASSIGN = 27,
  sym_XOR_ASSIGN = 28,
  sym_OR_ASSIGN = 29,
  sym_TYPEDEF_NAME = 30,
  sym_ENUMERATION_CONSTANT = 31,
  sym_TYPEDEF = 32,
  sym_EXTERN = 33,
  sym_STATIC = 34,
  sym_AUTO = 35,
  sym_REGISTER = 36,
  sym_INLINE = 37,
  sym_CONST = 38,
  sym_RESTRICT = 39,
  sym_VOLATILE = 40,
  sym_BOOL = 41,
  sym_CHAR = 42,
  sym_SHORT = 43,
  sym_INT = 44,
  sym_LONG = 45,
  sym_SIGNED = 46,
  sym_UNSIGNED = 47,
  sym_FLOAT = 48,
  sym_DOUBLE = 49,
  sym_VOID = 50,
  sym_COMPLEX = 51,
  sym_IMAGINARY = 52,
  sym_STRUCT = 53,
  sym_UNION = 54,
  sym_ENUM = 55,
  sym_ELLIPSIS = 56,
  sym_CASE = 57,
  sym_DEFAULT = 58,
  sym_IF = 59,
  sym_ELSE = 60,
  sym_SWITCH = 61,
  sym_WHILE = 62,
  sym_DO = 63,
  sym_FOR = 64,
  sym_GOTO = 65,
  sym_CONTINUE = 66,
  sym_BREAK = 67,
  sym_RETURN = 68,
  sym_ALIGNAS = 69,
  sym_ALIGNOF = 70,
  sym_ATOMIC = 71,
  sym_GENERIC = 72,
  sym_NORETURN = 73,
  sym_STATIC_ASSERT = 74,
  sym_THREAD_LOCAL = 75,
  sym_MAYBECONST = 76,
  sym_NEW_FIELD = 77,
  sym_TRACE = 78,
  sym_FOREACH_DIMENSION = 79,
  sym_REDUCTION = 80,
  sym_MACRO = 81,
  sym_ELLIPSIS_MACRO = 82,
  sym_MACRODEF = 83,
  sym_foreach_statement = 84,
  sym_85_ = 85,
  sym_86_ = 86,
  sym_87_ = 87,
  sym_88_ = 88,
  sym_89_ = 89,
  sym_90_ = 90,
  sym_91_ = 91,
  sym_92_ = 92,
  sym_93_ = 93,
  sym_94_ = 94,
  sym_95_ = 95,
  sym_96_ = 96,
  sym_97_ = 97,
  sym_98_ = 98,
  sym_99_ = 99,
  sym_100_ = 100,
  sym_101_ = 101,
  sym_102_ = 102,
  sym_103_ = 103,
  sym_104_ = 104,
  sym_105_ = 105,
  sym_106_ = 106,
  sym_107_ = 107,
  sym_108_ = 108,
  sym_YYACCEPT = 109,
  sym_translation_unit = 110,
  sym_primary_expression = 111,
  sym_expression_error = 112,
  sym_constant = 113,
  sym_enumeration_constant = 114,
  sym_string = 115,
  sym_generic_selection = 116,
  sym_generic_assoc_list = 117,
  sym_generic_association = 118,
  sym_postfix_expression = 119,
  sym_postfix_initializer = 120,
  sym_array_access = 121,
  sym_function_call = 122,
  sym_member_identifier = 123,
  sym_argument_expression_list = 124,
  sym_argument_expression_list_item = 125,
  sym_unary_expression = 126,
  sym_unary_operator = 127,
  sym_cast_expression = 128,
  sym_multiplicative_expression = 129,
  sym_additive_expression = 130,
  sym_shift_expression = 131,
  sym_relational_expression = 132,
  sym_equality_expression = 133,
  sym_and_expression = 134,
  sym_exclusive_or_expression = 135,
  sym_inclusive_or_expression = 136,
  sym_logical_and_expression = 137,
  sym_logical_or_expression = 138,
  sym_conditional_expression = 139,
  sym_assignment_expression = 140,
  sym_assignment_operator = 141,
  sym_expression = 142,
  sym_constant_expression = 143,
  sym_declaration = 144,
  sym_declaration_specifiers = 145,
  sym_init_declarator_list = 146,
  sym_init_declarator = 147,
  sym_storage_class_specifier = 148,
  sym_type_specifier = 149,
  sym_types = 150,
  sym_struct_or_union_specifier = 151,
  sym_struct_or_union = 152,
  sym_struct_declaration_list = 153,
  sym_struct_declaration = 154,
  sym_specifier_qualifier_list = 155,
  sym_struct_declarator_list = 156,
  sym_struct_declarator = 157,
  sym_enum_specifier = 158,
  sym_enumerator_list = 159,
  sym_enumerator = 160,
  sym_atomic_type_specifier = 161,
  sym_type_qualifier = 162,
  sym_function_specifier = 163,
  sym_alignment_specifier = 164,
  sym_declarator = 165,
  sym_direct_declarator = 166,
  sym_generic_identifier = 167,
  sym_pointer = 168,
  sym_type_qualifier_list = 169,
  sym_parameter_type_list = 170,
  sym_parameter_list = 171,
  sym_parameter_declaration = 172,
  sym_identifier_list = 173,
  sym_type_name = 174,
  sym_abstract_declarator = 175,
  sym_direct_abstract_declarator = 176,
  sym_type_not_specified = 177,
  sym_initializer = 178,
  sym_initializer_list = 179,
  sym_designation = 180,
  sym_designator_list = 181,
  sym_designator = 182,
  sym_static_assert_declaration = 183,
  sym_statement = 184,
  sym_labeled_statement = 185,
  sym_compound_statement = 186,
  sym_187_1 = 187,
  sym_block_item_list = 188,
  sym_block_item = 189,
  sym_expression_statement = 190,
  sym_selection_statement = 191,
  sym_for_scope = 192,
  sym_iteration_statement = 193,
  sym_for_declaration_statement = 194,
  sym_jump_statement = 195,
  sym_external_declaration = 196,
  sym_function_declaration = 197,
  sym_function_definition = 198,
  sym_declaration_list = 199,
  sym_basilisk_statements = 200,
  sym_macro_statement = 201,
  sym_reduction_list = 202,
  sym_reduction = 203,
  sym_reduction_operator = 204,
  sym_reduction_array = 205,
  sym_foreach_dimension_statement = 206,
  sym_forin_declaration_statement = 207,
  sym_forin_statement = 208,
  sym_forin_arguments = 209,
  sym_event_definition = 210,
  sym_event_parameters = 211,
  sym_event_parameter = 212,
  sym_boundary_definition = 213,
  sym_external_foreach_dimension = 214,
  sym_attribute = 215,
  sym_new_field = 216,
  sym_root = 217
};
#line 633 "/home/spencer/basilisk/src/grid/config.h"

enum typedef_kind_t {
  sym_SCALAR = sym_root + 1,
  sym_VECTOR,
  sym_TENSOR,
  sym_COORD,
  sym__COORD,
  sym_VEC4,
  sym_IVEC
};

#define attroffset(x) (offsetof(_Attributes,x))




typedef int Reduce;

void macro_foreach_face (char flags, Reduce reductions,
   const char * order)
{;}
void macro_einstein_sum() {;}
void macro_diagonalize (int a) {;}




#define dimensional(...)

#define show_dimension_internal(...)
#define display_value(...)
#define interpreter_verbosity(...)
#line 20 "/home/spencer/basilisk/src/common.h"

static inline double noise() { return 1. - 2.*rand()/(double)RAND_MAX; }


typedef struct {
  long n;
  long tn;
  int depth;
  int maxdepth;
} Grid;
Grid * grid = NULL;

double X0 = 0., Y0 = 0., Z0 = 0.;

double L0 = 1.;


int N = 64;




typedef struct { int i; } scalar;

typedef struct {
  scalar x;

  scalar y;




} vector;

typedef struct {
  scalar * x;

  scalar * y;




} vectorl;

typedef struct {
  vector x;

  vector y;




} tensor;

struct { int x, y, z; } Period = {false, false, false};

typedef struct {
  double x, y, z;
} coord;

OMP(omp declare reduction (+ : coord :
      omp_out.x += omp_in.x,
      omp_out.y += omp_in.y,
      omp_out.z += omp_in.z))
#line 96 "/home/spencer/basilisk/src/common.h"
void normalize (coord * n)
{
  double norm = 0.;
  
    norm += ( (n->x)*(n->x));    norm += ( (n->y)*(n->y));
  norm = sqrt(norm);
  
    n->x /= norm;    n->y /= norm;
}

void origin (double x, double y, double z) {
  X0 = x; Y0 = y; Z0 = z;
}

void size (double L) {
  L0 = L;
}

double zero (double s0, double s1, double s2) { return 0.; }






  enum { right, left, top, bottom };



int nboundary = 2*2;



double * _constant = NULL;
size_t datasize = 0;
typedef struct _Point Point;

#line 1 "/home/spencer/basilisk/src/grid/boundaries.h"


typedef struct _Boundary Boundary;

struct _Boundary {
  void (* destroy) (Boundary * b);
  void (* level) (const Boundary * b, scalar * list, int l);

  void (* restriction) (const Boundary * b, scalar * list, int l);
};

static Boundary ** boundaries = NULL;

void add_boundary (Boundary * b) {
  int len = 0;
  if (boundaries) {
    Boundary ** i = boundaries;
    while (*i++) len++;
  }
  boundaries = (Boundary * *) prealloc (boundaries, (len + 2)*sizeof(Boundary *),__func__,__FILE__,__LINE__);
  boundaries[len] = b;
  boundaries[len+1] = NULL;
}

void free_boundaries() {
  if (!boundaries)
    return;
  Boundary ** i = boundaries, * b;
  while ((b = *i++))
    if (b->destroy)
      b->destroy (b);
    else
      pfree (b,__func__,__FILE__,__LINE__);
  pfree (boundaries,__func__,__FILE__,__LINE__);
  boundaries = NULL;
}
#line 47 "/home/spencer/basilisk/src/grid/boundaries.h"
typedef struct {
  Boundary parent;
  int d;
} BoxBoundary;
#line 134 "/home/spencer/basilisk/src/common.h"



typedef struct {
  int x;

  int y;




} ivec;
typedef double (* BoundaryFunc) (Point, Point, scalar, bool *);
typedef struct {
  BoundaryFunc * boundary;
  BoundaryFunc * boundary_homogeneous;
  double (* gradient) (double, double, double);
  void (* delete) (scalar);
  char * name;
  ivec d;
  vector v;
  int face;
  bool nodump, freed;
  int block;
  scalar * depends;  
#line 19 "/home/spencer/basilisk/src/grid/stencils.h"
bool input, output, nowarning;
  int width;
  int dirty;  
#line 21 "/home/spencer/basilisk/src/grid/multigrid-common.h"
void (* prolongation) (Point, scalar);
  void (* restriction) (Point, scalar);  
#line 9 "/home/spencer/basilisk/src/grid/tree-common.h"
void (* refine) (Point, scalar);
  
#line 97
void (* coarsen) (Point, scalar);  
#line 81 "/home/spencer/basilisk/src/fractions.h"
vector n;    
#line 71 "./../ibm-gcm.h"
vector mp;
  
#line 209 "./../ibm-tree.h"
void (* ibm_gradient) (Point, scalar, coord *);  
#line 9 "./../my-vof-testv2.h"
scalar * tracers, c;
  bool inverse;
  
#line 22 "./../my-iforce.h"
scalar phi;
  
#line 460 "/home/spencer/basilisk/src/heights.h"
vector height;  
#line 27 "./../my-tension.h"
double sigma;

#line 159 "/home/spencer/basilisk/src/common.h"
} _Attributes;

static _Attributes * _attribute = NULL;







ivec Dimensions = {1,1};






int list_len (scalar * list)
{
  if (!list) return 0;
  int ns = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ ns++;}}
  return ns;
}

scalar * list_append (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) prealloc (list, (len + 2)*sizeof(scalar),__func__,__FILE__,__LINE__);
  list[len] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_prepend (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) prealloc (list, (len + 2)*sizeof(scalar),__func__,__FILE__,__LINE__);
  for (int i = len; i >= 1; i--)
    list[i] = list[i-1];
  list[0] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_add (scalar * list, scalar s)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  return list_append (list, s);
}

int list_lookup (scalar * l, scalar s)
{
  if (l != NULL)
    {scalar*_i=(scalar*)( l);if(_i)for(scalar s1=*_i;(&s1)->i>=0;s1=*++_i){
      if (s1.i == s.i)
 return true;}}
  return false;
}

scalar * list_copy (scalar * l)
{
  scalar * list = NULL;
  if (l != NULL)
    {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      list = list_append (list, s);}}
  return list;
}

scalar * list_concat (scalar * l1, scalar * l2)
{
  scalar * l3 = list_copy (l1);
  {scalar*_i=(scalar*)( l2);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    l3 = list_append (l3, s);}}
  return l3;
}

void list_print (scalar * l, FILE * fp)
{
  int i = 0;
  {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    fprintf (fp, "%s%s", i++ == 0 ? "{" : ",", _attribute[s.i].name);}}
  fputs (i > 0 ? "}\n" : "{}\n", fp);
}

int vectors_len (vector * list)
{
  if (!list) return 0;
  int nv = 0;
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ nv++;}}
  return nv;
}

vector * vectors_append (vector * list, vector v)
{
  int len = vectors_len (list);
  list = (vector *) prealloc (list, (len + 2)*sizeof(vector),__func__,__FILE__,__LINE__);
  list[len] = v;
  list[len + 1] = (vector){{-1}};
  return list;
}

vector * vectors_add (vector * list, vector v)
{
  {vector*_i=(vector*)( list);if(_i)for(vector w=*_i;(&w)->x.i>=0;w=*++_i){ {
    bool id = true;
    
      if (w.x.i != v.x.i)
 id = false;      
#line 268
if (w.y.i != v.y.i)
 id = false;
    if (id)
      return list;
  }}}
  return vectors_append (list, v);
}

vector * vectors_copy (vector * l)
{
  vector * list = NULL;
  if (l != NULL)
    {vector*_i=(vector*)( l);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      list = vectors_append (list, v);}}
  return list;
}

vector * vectors_from_scalars (scalar * s)
{
  vector * list = NULL;
  while (s->i >= 0) {
    vector v;
     {
      if (!(s->i >= 0)) qassert ("/home/spencer/basilisk/src/common.h", 291, "s->i >= 0");
      v.x = *s++;
    } 
#line 290
{
      if (!(s->i >= 0)) qassert ("/home/spencer/basilisk/src/common.h", 291, "s->i >= 0");
      v.y = *s++;
    }
    list = vectors_append (list, v);
  }
  return list;
}

int tensors_len (tensor * list)
{
  if (!list) return 0;
  int nt = 0;
  {tensor*_i=(tensor*)( list);if(_i)for(tensor t=*_i;(&t)->x.x.i>=0;t=*++_i){ nt++;}}
  return nt;
}

tensor * tensors_append (tensor * list, tensor t)
{
  int len = tensors_len (list);
  list = (tensor *) prealloc (list, (len + 2)*sizeof(tensor),__func__,__FILE__,__LINE__);
  list[len] = t;
  list[len + 1] = (tensor){{{-1}}};
  return list;
}

tensor * tensors_from_vectors (vector * v)
{
  tensor * list = NULL;
  while (v->x.i >= 0) {
    tensor t;
     {
      if (!(v->x.i >= 0)) qassert ("/home/spencer/basilisk/src/common.h", 322, "v->x.i >= 0");
      t.x = *v++;
    } 
#line 321
{
      if (!(v->y.i >= 0)) qassert ("/home/spencer/basilisk/src/common.h", 322, "v->x.i >= 0");
      t.y = *v++;
    }
    list = tensors_append (list, t);
  }
  return list;
}

static inline bool is_vertex_scalar (scalar s)
{
  
    if (_attribute[s.i].d.x != -1)
      return false;    
#line 333
if (_attribute[s.i].d.y != -1)
      return false;
  return true;
}

scalar * all = NULL;
scalar * baseblock = NULL;



scalar (* init_scalar) (scalar, const char *);
scalar (* init_vertex_scalar) (scalar, const char *);
vector (* init_vector) (vector, const char *);
vector (* init_face_vector) (vector, const char *);
tensor (* init_tensor) (tensor, const char *);
void (* scalar_clone) (scalar, scalar);
#line 358 "/home/spencer/basilisk/src/common.h"
typedef struct {
  clock_t c;
  struct timeval tv;
  double tm;
} timer;

timer timer_start (void)
{
  timer t;
  t.c = clock();
  gettimeofday (&t.tv, NULL);



  return t;
}

double timer_elapsed (timer t)
{
  struct timeval tvend;
  gettimeofday (&tvend, NULL);
  return ((tvend.tv_sec - t.tv.tv_sec) +
   (tvend.tv_usec - t.tv.tv_usec)/1e6);
}



const vector zerof = {{_NVARMAX+3},{_NVARMAX+4}};
const vector unityf = {{_NVARMAX+5},{_NVARMAX+6}};
const scalar unity = {_NVARMAX+7};
const scalar zeroc = {_NVARMAX+8};



        vector fm = {{_NVARMAX+9},{_NVARMAX+10}};
        scalar cm = {_NVARMAX+11};
#line 407 "/home/spencer/basilisk/src/common.h"
void * matrix_new (int n, int p, size_t size)
{
  void ** m = ((void * *) pmalloc ((n)*sizeof(void *),__func__,__FILE__,__LINE__));
  char * a = ((char *) pmalloc ((n*p*size)*sizeof(char),__func__,__FILE__,__LINE__));
  for (int i = 0; i < n; i++)
    m[i] = a + i*p*size;
  return m;
}

double matrix_inverse (double ** m, int n, double pivmin)
{
  int indxc[n], indxr[n], ipiv[n];
  int i, icol = 0, irow = 0, j, k, l, ll;
  double big, dum, pivinv, minpiv = 1e30f;

  for (j = 0; j < n; j++)
    ipiv[j] = -1;

  for (i = 0; i < n; i++) {
    big = 0.0;
    for (j = 0; j < n; j++)
      if (ipiv[j] != 0)
 for (k = 0; k < n; k++) {
   if (ipiv[k] == -1) {
     if (fabs (m[j][k]) >= big) {
       big = fabs (m[j][k]);
       irow = j;
       icol = k;
     }
   }
 }
    ipiv[icol]++;
    if (irow != icol)
      for (l = 0; l < n; l++)
 do { double _tmp_ = m[irow][l]; m[irow][l] = m[icol][l]; m[icol][l] = _tmp_; } while(false);
    indxr[i] = irow;
    indxc[i] = icol;
    if (fabs (m[icol][icol]) <= pivmin)
      return 0.;
    if (fabs (m[icol][icol]) < minpiv)
      minpiv = fabs (m[icol][icol]);
    pivinv = 1.0/m[icol][icol];
    m[icol][icol] = 1.0;
    for (l = 0; l < n; l++) m[icol][l] *= pivinv;
    for (ll = 0; ll < n; ll++)
      if (ll != icol) {
 dum = m[ll][icol];
 m[ll][icol] = 0.0;
 for (l = 0; l < n; l++)
   m[ll][l] -= m[icol][l]*dum;
      }
  }
  for (l = n - 1; l >= 0; l--) {
    if (indxr[l] != indxc[l])
      for (k = 0; k < n; k++)
 do { double _tmp_ = m[k][indxr[l]]; m[k][indxr[l]] = m[k][indxc[l]]; m[k][indxc[l]] = _tmp_; } while(false);
  }
  return minpiv;
}

void matrix_free (void * m)
{
  pfree (((void **) m)[0],__func__,__FILE__,__LINE__);
  pfree (m,__func__,__FILE__,__LINE__);
}



typedef void (* free_solver_func) (void);

static Array * free_solver_funcs = NULL;

void free_solver_func_add (free_solver_func func)
{
  if (!free_solver_funcs)
    free_solver_funcs = array_new();
  array_append (free_solver_funcs, &func, sizeof(free_solver_func));
}



static char * display_defaults = NULL;

static void free_display_defaults() {
  pfree (display_defaults,__func__,__FILE__,__LINE__);
}

void display (const char * commands, bool overwrite)
{
  if (display_defaults == NULL)
    free_solver_func_add (free_display_defaults);
  if (overwrite) {
    pfree (display_defaults,__func__,__FILE__,__LINE__);
    display_defaults = pmalloc (strlen(commands) + 2,__func__,__FILE__,__LINE__);
    strcpy (display_defaults, "@");
    strcat (display_defaults, commands);
  }
  else {
    if (!display_defaults)
      display_defaults = pstrdup ("@",__func__,__FILE__,__LINE__);
    display_defaults =
      prealloc (display_defaults,
        strlen(display_defaults) + strlen(commands) + 1,__func__,__FILE__,__LINE__);
    strcat (display_defaults, commands);
  }
}



typedef struct {
  double x;

  double y;




} _coord;



typedef struct {
  float r, g, b, a;
} vec4;
#line 540 "/home/spencer/basilisk/src/common.h"
typedef struct {
  coord x, y, z;
} mat3;

OMP(omp declare reduction (+ : mat3 :
      omp_out.x.x += omp_in.x.x,
      omp_out.x.y += omp_in.x.y,
      omp_out.x.z += omp_in.x.z,
      omp_out.y.x += omp_in.y.x,
      omp_out.y.y += omp_in.y.y,
      omp_out.y.z += omp_in.y.z,
      omp_out.z.x += omp_in.z.x,
      omp_out.z.y += omp_in.z.y,
      omp_out.z.z += omp_in.z.z
      ))

typedef struct {
  uint32_t s;
} Adler32Hash;

static
inline void a32_hash_init (Adler32Hash * hash)
{
  hash->s = 0;
}

static
inline void a32_hash_add (Adler32Hash * hash, const void * data, size_t size)
{
  const uint8_t * buffer = (const uint8_t*) data;
  for (size_t n = 0; n < size; n++, buffer++)
    hash->s = *buffer + (hash->s << 6) + (hash->s << 16) - hash->s;
}

static
inline uint32_t a32_hash (const Adler32Hash * hash)
{
  return hash->s;
}
#line 14 "sessile-ibm-axi-osc-cpp.c"
#line 1 "grid/quadtree.h"
#line 1 "/home/spencer/basilisk/src/grid/quadtree.h"


#line 1 "grid/tree.h"
#line 1 "/home/spencer/basilisk/src/grid/tree.h"
typedef double real;

#line 1 "grid/mempool.h"
#line 1 "/home/spencer/basilisk/src/grid/mempool.h"





typedef struct _Pool Pool;

struct _Pool {
  Pool * next;
};

typedef struct {
  char * first, * lastb;
  size_t size;
  size_t poolsize;
  Pool * pool, * last;
} Mempool;

typedef struct {
  char * next;
} FreeBlock;

Mempool * mempool_new (size_t poolsize, size_t size)
{

  if (!(poolsize % 8 == 0)) qassert ("/home/spencer/basilisk/src/grid/mempool.h", 26, "poolsize % 8 == 0");
  if (!(size >= sizeof(FreeBlock))) qassert ("/home/spencer/basilisk/src/grid/mempool.h", 27, "size >= sizeof(FreeBlock)");


  poolsize = ( (1 << 20) < (poolsize + sizeof(Pool)) ? (1 << 20) : (poolsize + sizeof(Pool)));
  Mempool * m = ((Mempool *) pcalloc (1, sizeof(Mempool),__func__,__FILE__,__LINE__));
  m->poolsize = poolsize;
  m->size = size;
  return m;
}

void mempool_destroy (Mempool * m)
{
  Pool * p = m->pool;
  while (p) {
    Pool * next = p->next;
    pfree (p,__func__,__FILE__,__LINE__);
    p = next;
  }
  pfree (m,__func__,__FILE__,__LINE__);
}

void * mempool_alloc (Mempool * m)
{
  if (!m->first) {

    Pool * p = (Pool *) pmalloc (m->poolsize,__func__,__FILE__,__LINE__);
    p->next = NULL;
    if (m->last)
      m->last->next = p;
    else
      m->pool = p;
    m->last = p;
    m->first = m->lastb = ((char *)m->last) + sizeof(Pool);
    FreeBlock * b = (FreeBlock *) m->first;
    b->next = NULL;
  }
  void * ret = m->first;
  FreeBlock * b = (FreeBlock *) ret;
  char * next = b->next;
  if (!next) {
    m->lastb += m->size;
    next = m->lastb;
    if (next + m->size > ((char *) m->last) + m->poolsize)
      next = NULL;
    else {
      FreeBlock * b = (FreeBlock *) next;
      b->next = NULL;
    }
  }
  m->first = next;
#if TRASH
  double * v = (double *) ret;
  for (int i = 0; i < m->size/sizeof(real); i++)
    v[i] = undefined;
#endif
  return ret;
}

void * mempool_alloc0 (Mempool * m)
{
  void * ret = mempool_alloc (m);
  memset (ret, 0, m->size);
  return ret;
}

void mempool_free (Mempool * m, void * p)
{
#if TRASH
  double * v = (double *) p;
  for (int i = 0; i < m->size/sizeof(real); i++)
    v[i] = undefined;
#endif
  FreeBlock * b = (FreeBlock *) p;
  b->next = m->first;
  m->first = (char *) p;
}
#line 4 "/home/spencer/basilisk/src/grid/tree.h"




struct _Point {

  int i;

  int j;




  int level;




  #define _BLOCK_INDEX

};

#line 1 "grid/memindex/range.h"
#line 1 "/home/spencer/basilisk/src/grid/memindex/range.h"
#line 15 "/home/spencer/basilisk/src/grid/memindex/range.h"
typedef struct {
  void ** p;
  int size;
} Memalloc;

typedef struct {
  int start, end;
} Memrange;
#line 34 "/home/spencer/basilisk/src/grid/memindex/range.h"
void memrange_alloc (Memrange * r, Memalloc * mem, int i)
{
  if (r->start == r->end) {
    r->start = i;
    r->end = i + 1;
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = pcalloc (1, m->size,__func__,__FILE__,__LINE__);
      *m->p = (char *)(*m->p) - i*m->size;
    }
  }
  else if (i >= r->end) {
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = prealloc ((char *)(*m->p) + r->start*m->size,
         m->size*(i + 1 - r->start),__func__,__FILE__,__LINE__);
      *m->p = (char *)(*m->p) - r->start*m->size;
      memset ((char *)(*m->p) + r->end*m->size, 0, (i - r->end + 1)*m->size);
    }
    r->end = i + 1;
  }
  else if (i < r->start) {
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = prealloc ((char *)(*m->p) + r->start*m->size, m->size*(r->end - i),__func__,__FILE__,__LINE__);
      memmove ((char *)(*m->p) + (r->start - i)*m->size, *m->p,
        m->size*(r->end - r->start));
      memset ((char *)(*m->p), 0, (r->start - i)*m->size);
      *m->p = (char *)(*m->p) - i*m->size;
    }
    r->start = i;
  }
}
#line 73 "/home/spencer/basilisk/src/grid/memindex/range.h"
bool memrange_free (Memrange * r, Memalloc * mem, int i)
{
  if (i == r->start) {
    if (i == r->end - 1) {
      for (Memalloc * m = mem; m->p; m++) {
 pfree ((char *)(*m->p) + r->start*m->size,__func__,__FILE__,__LINE__);
 *m->p = NULL;
      }
      r->start = r->end = 0;
      return true;
    }
    else {
      for (i = i + 1; i < r->end &&
      !*(void **)((char *)(*mem->p) + i*mem->size); i++);
      for (Memalloc * m = mem; m->p; m++) {
 memmove ((char *)(*m->p) + r->start*m->size,
   (char *)(*m->p) + i*m->size, m->size*(r->end - i));
 *m->p = prealloc ((char *)(*m->p) + r->start*m->size,
    m->size*(r->end - i),__func__,__FILE__,__LINE__);
 *m->p = (char *)(*m->p) - i*m->size;
      }
      r->start = i;
    }
  }
  else if (i == r->end - 1) {
    for (i = i - 1; i >= r->start &&
    !*(void **)((char *)(*mem->p) + i*mem->size); i--);
    r->end = i + 1;
    for (Memalloc * m = mem; m->p; m++) {
      *m->p = prealloc ((char *)(*m->p) + r->start*m->size,
         m->size*(r->end - r->start),__func__,__FILE__,__LINE__);
      *m->p = (char *)(*m->p) - r->start*m->size;
    }
  }
  else {
    if (!(i > r->start && i < r->end)) qassert ("/home/spencer/basilisk/src/grid/memindex/range.h", 108, "i > r->start && i < r->end");
    for (Memalloc * m = mem; m->p; m++)
      memset ((char *)(*m->p) + i*m->size, 0, m->size);
  }
  return false;
}







struct _Memindex {
  Memrange r1;

  Memrange * r2;







  char *** b;



};
#line 171 "/home/spencer/basilisk/src/grid/memindex/range.h"
struct _Memindex * mem_new (int len)
{
  struct _Memindex * m = pcalloc (1, sizeof (struct _Memindex),__func__,__FILE__,__LINE__);
  return m;
}





void mem_destroy (struct _Memindex * m, int len)
{

  for (int i = m->r1.start; i < m->r1.end; i++)
    if (m->b[i]) {






      pfree (m->b[i] + m->r2[i].start,__func__,__FILE__,__LINE__);
    }
  if (m->b) {
    pfree (m->r2 + m->r1.start,__func__,__FILE__,__LINE__);



  }

  if (m->b)
    pfree (m->b + m->r1.start,__func__,__FILE__,__LINE__);
  pfree (m,__func__,__FILE__,__LINE__);
}
#line 218 "/home/spencer/basilisk/src/grid/memindex/range.h"
void mem_assign (struct _Memindex * m, int i, int j, int len, void * b)
{
  Memalloc mem[] = {{(void **)&m->b, sizeof(char **)},
      {(void **)&m->r2, sizeof(Memrange)},
      {NULL}};
  memrange_alloc (&m->r1, mem, i);
  Memalloc mem1[] = {{(void **)&m->b[i], sizeof(char *)},
       {NULL}};
  memrange_alloc (&m->r2[i], mem1, j);
  ((m)->b[i][j]) = b;
}
#line 259 "/home/spencer/basilisk/src/grid/memindex/range.h"
void mem_free (struct _Memindex * m, int i, int j, int len, void * b)
{
  Memalloc mem[] = {{(void **)&m->b[i], sizeof(char *)},
      {NULL}};
  if (memrange_free (&m->r2[i], mem, j)) {
    Memalloc mem[] = {{(void **)&m->b, sizeof(char **)},
        {(void **)&m->r2, sizeof(Memrange)},
        {NULL}};
    memrange_free (&m->r1, mem, i);
  }
}
#line 307 "/home/spencer/basilisk/src/grid/memindex/range.h"
void macro_foreach_mem (struct _Memindex * index, int len, int _i) {
  struct _Memindex * _m = index;
  int _len = len;
  Point point = {0};
  for (point.i = ( (Period.x*2) > (_m->r1.start) ? (Period.x*2) : (_m->r1.start));
       point.i < ( (_len - Period.x*2) < (_m->r1.end) ? (_len - Period.x*2) : (_m->r1.end));
       point.i += _i)
    if (_m->b[point.i])
      for (point.j = ( (Period.y*2) > (_m->r2[point.i].start) ? (Period.y*2) : (_m->r2[point.i].start));
    point.j < ( (_len - Period.y*2) < (_m->r2[point.i].end) ? (_len - Period.y*2) : (_m->r2[point.i].end));
    point.j += _i)
 if (_m->b[point.i][point.j])
   ;
}
#line 27 "/home/spencer/basilisk/src/grid/tree.h"
#line 48 "/home/spencer/basilisk/src/grid/tree.h"
typedef struct {
  unsigned short flags;

  unsigned short neighbors;
  int pid;
} Cell;

enum {
  active = 1 << 0,
  leaf = 1 << 1,
  border = 1 << 2,
  vertex = 1 << 3,
  user = 4,

  face_x = 1 << 0

  , face_y = 1 << 1




};

#define is_active(cell) ((cell).flags & active)
#define is_leaf(cell) ((cell).flags & leaf)
#define is_coarse() ((cell).neighbors > 0)
#define is_border(cell) ((cell).flags & border)
#define is_local(cell) ((cell).pid == pid())
#define is_vertex(cell) ((cell).flags & vertex)



typedef struct {
  int i;

  int j;




} IndexLevel;

typedef struct {
  IndexLevel * p;
  int n, nm;
} CacheLevel;

typedef struct {
  int i;

  int j;




  int level, flags;
} Index;

typedef struct {
  Index * p;
  int n, nm;
} Cache;



typedef struct {
  struct _Memindex * m;
  Mempool * pool;
  long nc;
  int len;
} Layer;

static size_t _size (size_t depth)
{
  return (1 << depth) + 2*2;
}

static size_t poolsize (size_t depth, size_t size)
{




  return ( (_size(depth))*(_size(depth)))*size;



}

static Layer * new_layer (int depth)
{
  Layer * l = ((Layer *) pmalloc ((1)*sizeof(Layer),__func__,__FILE__,__LINE__));
  l->len = _size (depth);
  if (depth == 0)
    l->pool = NULL;
  else {
    size_t size = sizeof(Cell) + datasize;


    l->pool = mempool_new (poolsize (depth, size), (1 << 2)*size);
  }
  l->m = mem_new (l->len);
  l->nc = 0;
  return l;
}

static void destroy_layer (Layer * l)
{
  if (l->pool)
    mempool_destroy (l->pool);
  mem_destroy (l->m, l->len);
  pfree (l,__func__,__FILE__,__LINE__);
}



typedef struct {
  Grid g;
  Layer ** L;

  Cache leaves;
  Cache faces;
  Cache vertices;
  Cache refined;
  CacheLevel * active;
  CacheLevel * prolongation;
  CacheLevel * boundary;

  CacheLevel * restriction;

  bool dirty;
} Tree;



static Point last_point;



static void cache_level_append (CacheLevel * c, Point p)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (IndexLevel *) prealloc (c->p, (c->nm)*sizeof(IndexLevel),__func__,__FILE__,__LINE__);
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;




  c->n++;
}

static void cache_level_shrink (CacheLevel * c)
{
  if (c->nm > (c->n/128 + 1)*128) {
    c->nm = (c->n/128 + 1)*128;
    if (!(c->nm > c->n)) qassert ("/home/spencer/basilisk/src/grid/tree.h", 207, "c->nm > c->n");
    c->p = (IndexLevel *) prealloc (c->p, sizeof (Index)*c->nm,__func__,__FILE__,__LINE__);
  }
}

static void cache_append (Cache * c, Point p, unsigned short flags)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (Index *) prealloc (c->p, (c->nm)*sizeof(Index),__func__,__FILE__,__LINE__);
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;




  c->p[c->n].level = p.level;
  c->p[c->n].flags = flags;
  c->n++;
}

void cache_shrink (Cache * c)
{
  cache_level_shrink ((CacheLevel *)c);
}
#line 250 "/home/spencer/basilisk/src/grid/tree.h"
#define allocated(k,l,n) (((point.i+k) >= (((Tree *)grid)->L[point.level]->m)->r1.start && (point.i+k) < (((Tree *)grid)->L[point.level]->m->r1.end) && (((Tree *)grid)->L[point.level]->m)->b[point.i+k] && (point.j+l) >= (((Tree *)grid)->L[point.level]->m)->r2[point.i+k].start && (point.j+l) < (((Tree *)grid)->L[point.level]->m)->r2[point.i+k].end && (((Tree *)grid)->L[point.level]->m)->b[point.i+k][point.j+l])\
                               )\

#line 252

#define NEIGHBOR(k,l,n) (((((Tree *)grid)->L[point.level]->m)->b[point.i+k][point.j+l])\
                            )\

#line 255

#define PARENT(k,l,n) (((((Tree *)grid)->L[point.level-1]->m)->b[(point.i+2)/2+k][(point.j+2)/2+l])\
                                                    )\

#line 258

#define allocated_child(k,l,n) (level < depth() &&\
         ((2*point.i-2 +k) >= (((Tree *)grid)->L[point.level+1]->m)->r1.start && (2*point.i-2 +k) < (((Tree *)grid)->L[point.level+1]->m->r1.end) && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k] && (2*point.j-2 +l) >= (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +k].start && (2*point.j-2 +l) < (((Tree *)grid)->L[point.level+1]->m)->r2[2*point.i-2 +k].end && (((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k][2*point.j-2 +l])\
\
                             )\

#line 263

#define CHILD(k,l,n) (((((Tree *)grid)->L[point.level+1]->m)->b[2*point.i-2 +k][2*point.j-2 +l])\
                                                )\

#line 266

#line 291 "/home/spencer/basilisk/src/grid/tree.h"
#define CELL(m) (*((Cell *)(m)))


#define depth() (grid->depth)
#define aparent(k,l,n) CELL(PARENT(k,l,n))
#define child(k,l,n) CELL(CHILD(k,l,n))


#define cell CELL(NEIGHBOR(0,0,0))
#define neighbor(k,l,n) CELL(NEIGHBOR(k,l,n))
#define neighborp(l,m,n) (Point) {\
    point.i + l,\
\
    point.j + m,\
\
\
\
\
    point.level\
    _BLOCK_INDEX\
}\

#line 312



#define data(k,l,n) ((double *) (NEIGHBOR(k,l,n) + sizeof(Cell)))
#define fine(a,k,p,n) ((double *) (CHILD(k,p,n) + sizeof(Cell)))[_index(a,n)]
#define coarse(a,k,p,n) ((double *) (PARENT(k,p,n) + sizeof(Cell)))[_index(a,n)]

void macro_POINT_VARIABLES (Point point) { 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 348 "/home/spencer/basilisk/src/grid/tree.h"
}

#line 1 "grid/foreach_cell.h"
#line 1 "/home/spencer/basilisk/src/grid/foreach_cell.h"
#line 66 "/home/spencer/basilisk/src/grid/foreach_cell.h"
void macro_foreach_cell_root (Point root)
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {

 ;

 if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}

void macro_foreach_cell()
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
      
#line 136
{ 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 136 "/home/spencer/basilisk/src/grid/foreach_cell.h"
;} 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

void macro_foreach_cell_all() {
  {
    Point root = {0};
    for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)

      for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 67 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
     
#line 151
{ 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 151 "/home/spencer/basilisk/src/grid/foreach_cell.h"
;} 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 152 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}

void macro_foreach_cell_post_root (bool condition, Point root)
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   if (condition)
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }







      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
#line 246 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      default:
 ;

      }
    }
  }
}

void macro_foreach_cell_post (bool condition)
{
  {



    Point root = {2,2,0};
#line 156
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   if (condition)
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }







      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
#line 246 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      default:
      
#line 265
{ 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 265 "/home/spencer/basilisk/src/grid/foreach_cell.h"
;}      
#line 249
}
    }
  }
}
  
#line 266
}
}

void macro_foreach_cell_post_all (bool condition)
{
  {
    Point root = {0};
    for (root.i = 0; root.i <= 2*2; root.i++)

      for (root.j = 0; root.j <= 2*2; root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 156 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   if (condition)
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }







      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
#line 246 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      default:
     
#line 281
{ 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 281 "/home/spencer/basilisk/src/grid/foreach_cell.h"
;}      
#line 249
}
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 282 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}

void macro_foreach_leaf()
{
#line 126
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
    
#line 288
{ 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 288 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (is_leaf (cell)) {
      if (is_active(cell) && is_local(cell))
 ;
      continue;
    }} 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

#line 293
}
#line 351 "/home/spencer/basilisk/src/grid/tree.h"
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
void macro_foreach_child (Point point) {
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 376
;
      }
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}
#line 411 "/home/spencer/basilisk/src/grid/tree.h"
#define is_refined_check() ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) &&\
    point.i > 0 && point.i < (1 << level) + 2*2 - 1\
\
    && point.j > 0 && point.j < (1 << level) + 2*2 - 1\
\
\
\
\
    )\

#line 420


void macro_foreach_cache (Cache cache, Reduce reductions)
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < cache.n; _k++) {
 point.i = cache.p[_k].i;

 point.j = cache.p[_k].j;




 point.level = cache.p[_k].level;
 _flags = cache.p[_k].flags;
 ;
      }
  }
}

void macro_foreach_cache_level (Cache cache, int _l, Reduce reductions)
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < cache.n; _k++) {
 point.i = cache.p[_k].i;

 point.j = cache.p[_k].j;




 ;
      }
  }
}

static void update_cache_f (void);

void macro_foreach_boundary_level (int _l, Reduce reductions)
{
  if (_l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _boundary = ((Tree *)grid)->boundary[_l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _boundary.n; _k++) {
 point.i = _boundary.p[_k].i;

 point.j = _boundary.p[_k].j;
      
#line 487
{ 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 487
;}      
#line 475
}
  }
}
  









}
}



void macro_foreach_halo_prolongation (int _l)
{
  if (_l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _cache = ((Tree *)grid)->prolongation[_l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _cache.n; _k++) {
 point.i = _cache.p[_k].i;

 point.j = _cache.p[_k].j;
      
#line 499
{ 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 499
;}      
#line 475
}
  }
}
  
#line 500
}
}

void macro_foreach_halo_restriction (int _l)
{
  if (_l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _cache = ((Tree *)grid)->restriction[_l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _cache.n; _k++) {
 point.i = _cache.p[_k].i;

 point.j = _cache.p[_k].j;
      
#line 509
{ 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 509
;}      
#line 475
}
  }
}
  
#line 510
}
}



#line 1 "grid/neighbors.h"
#line 1 "/home/spencer/basilisk/src/grid/neighbors.h"
#line 16 "/home/spencer/basilisk/src/grid/neighbors.h"
void macro_foreach_neighbor (int _s,
    Point point) {
  {
    const int _nn = _s;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 26 "/home/spencer/basilisk/src/grid/neighbors.h"
;
      }
    }
    point.i = _i; point.j = _j;
  }
}
#line 516 "/home/spencer/basilisk/src/grid/tree.h"

static inline bool has_local_children (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg); 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 520
if (is_local(cell))
      return true;      
#line 377
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 522
return false;
}

static inline void cache_append_face (Point point, unsigned short flags)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg); 
  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 527
Tree * q = ((Tree *)grid);
  cache_append (&q->faces, point, flags);

  if (!is_vertex(cell)) {
    cache_append (&q->vertices, point, 0);
    cell.flags |= vertex;
  }
  
    if ((flags & face_y) && !is_vertex(neighbor(1,0,0))) {
      cache_append (&q->vertices, neighborp(1,0,0), 0);
      neighbor(1,0,0).flags |= vertex;
    }    
#line 535
if ((flags & face_x) && !is_vertex(neighbor(0,1,0))) {
      cache_append (&q->vertices, neighborp(0,1,0), 0);
      neighbor(0,1,0).flags |= vertex;
    }
#line 549 "/home/spencer/basilisk/src/grid/tree.h"
}



static void update_cache_f (void)
{
  Tree * q = ((Tree *)grid);
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 557
q->vertices
#line 436
).n; _k++) {
 point.i = (
#line 557
q->vertices
#line 437
).p[_k].i;

 point.j = (
#line 557
q->vertices
#line 439
).p[_k].j;




 point.level = (
#line 557
q->vertices
#line 444
).p[_k].level;
 _flags = (
#line 557
q->vertices
#line 445
).p[_k].flags;
    
#line 558
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 558
if (level <= depth() && allocated(0,0,0))
      cell.flags &= ~vertex;}      
#line 447
}
  }
}


  
#line 562
q->leaves.n = q->faces.n = q->vertices.n = 0;
  for (int l = 0; l <= depth(); l++)
    q->active[l].n = q->prolongation[l].n =
      q->boundary[l].n = q->restriction[l].n = 0;

  const unsigned short fboundary = 1 << user;
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 568 "/home/spencer/basilisk/src/grid/tree.h"
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 568
{



    if (is_local(cell) && is_active(cell)) {


      cache_level_append (&q->active[level], point);
    }
#line 593 "/home/spencer/basilisk/src/grid/tree.h"
    if (!(cell.pid < 0)) {      
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 596
if (allocated(0,0,0) && (cell.pid < 0) && !(cell.flags & fboundary)) {
   cache_level_append (&q->boundary[level], point);
   cell.flags |= fboundary;
 }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 600 "/home/spencer/basilisk/src/grid/tree.h"
}

    else if (level > 0 && is_local(aparent(0,0,0)))
      cache_level_append (&q->restriction[level], point);

    if (is_leaf (cell)) {
      if (is_local(cell)) {
 cache_append (&q->leaves, point, 0);

 unsigned short flags = 0;
 
   if ((neighbor(-1,0,0).pid < 0) || (!is_leaf(neighbor(-1,0,0)) && !neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0) ||
       is_leaf(neighbor(-1,0,0)))
     flags |= face_x;   
#line 611
if ((neighbor(0,-1,0).pid < 0) || (!is_leaf(neighbor(0,-1,0)) && !neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0) ||
       is_leaf(neighbor(0,-1,0)))
     flags |= face_y;
 if (flags)
   cache_append (&q->faces, point, flags);
 
   if ((neighbor(1,0,0).pid < 0) || (!is_leaf(neighbor(1,0,0)) && !neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) ||
       (!is_local(neighbor(1,0,0)) && is_leaf(neighbor(1,0,0))))
     cache_append (&q->faces, neighborp(1,0,0), face_x);   
#line 617
if ((neighbor(0,1,0).pid < 0) || (!is_leaf(neighbor(0,1,0)) && !neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) ||
       (!is_local(neighbor(0,1,0)) && is_leaf(neighbor(0,1,0))))
     cache_append (&q->faces, neighborp(0,1,0), face_y);

 for (int i = 0; i <= 1; i++)

   for (int j = 0; j <= 1; j++)




       if (!is_vertex(neighbor(i,j,k))) {
  cache_append (&q->vertices, neighborp(i,j,k), 0);
  neighbor(i,j,k).flags |= vertex;
       }

        if (cell.neighbors > 0)
   cache_level_append (&q->prolongation[level], point);
      }
      else if (!(cell.pid < 0) || is_local(aparent(0,0,0))) {

 unsigned short flags = 0;
 
   if (allocated(-1,0,0) &&
       is_local(neighbor(-1,0,0)) && (!is_leaf(neighbor(-1,0,0)) && !neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0))
     flags |= face_x;   
#line 640
if (allocated(0,-1,0) &&
       is_local(neighbor(0,-1,0)) && (!is_leaf(neighbor(0,-1,0)) && !neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0))
     flags |= face_y;
 if (flags)
   cache_append_face (point, flags);
 
   if (allocated(1,0,0) && is_local(neighbor(1,0,0)) &&
       (!is_leaf(neighbor(1,0,0)) && !neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0))
     cache_append_face (neighborp(1,0,0), face_x);   
#line 646
if (allocated(0,1,0) && is_local(neighbor(0,1,0)) &&
       (!is_leaf(neighbor(0,1,0)) && !neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0))
     cache_append_face (neighborp(0,1,0), face_y);
      }

      continue;

    }
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}


  
#line 657 "/home/spencer/basilisk/src/grid/tree.h"
cache_shrink (&q->leaves);
  cache_shrink (&q->faces);
  cache_shrink (&q->vertices);
  for (int l = 0; l <= depth(); l++) {
    cache_level_shrink (&q->active[l]);
    cache_level_shrink (&q->prolongation[l]);
    cache_level_shrink (&q->boundary[l]);
    cache_level_shrink (&q->restriction[l]);
}

  q->dirty = false;


  for (int l = depth(); l >= 0; l--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 482 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _boundary = ((Tree *)grid)->boundary[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _boundary.n; _k++) {
 point.i = _boundary.p[_k].i;

 point.j = _boundary.p[_k].j;
      
#line 672
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 672
cell.flags &= ~fboundary;}      
#line 475
}
  }
}
  









}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}



  
#line 676 "/home/spencer/basilisk/src/grid/tree.h"
grid->n = q->leaves.n;

#if !_MPI
  grid->tn = grid->n;
  grid->maxdepth = grid->depth;
#endif
}

void macro_foreach (char flags, Reduce reductions) {
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;
    
#line 687
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 687
;}      
#line 447
}
  }
}

#line 688
}

void macro_foreach_face_generic (char flags, Reduce reductions,
    const char * order)
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
    
#line 695
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 695
;}      
#line 447
}
  }
}

#line 696
}

void macro_is_face_x (unsigned short _f) {
  if (_f & face_x) {
    int ig = -1; NOT_UNUSED(ig);
    ;
  }
}


void macro_is_face_y (unsigned short _f) {
  if (_f & face_y) {
    int jg = -1; NOT_UNUSED(jg);
    ;
  }
}
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
void macro_foreach_level (int l, char flags, Reduce reductions) {
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 736
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 736
;}      
#line 475
}
  }
}
  
#line 737
}
}

void macro1_foreach_coarse_level (int l, char flags, Reduce reductions) { 
#line 731
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
    
#line 742
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 742
if (!is_leaf(cell))
      ;}      
#line 475
}
  }
}
  
#line 737
}
}





}

void macro1_foreach_level_or_leaf (int l, char flags, Reduce reductions) {
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 749
if (_l1 == l || is_leaf (cell))
 ;}      
#line 475
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}

#if TRASH
# undef trash
# define trash(list) reset(list, undefined)
#endif

void reset (void * alist, double val)
{
  scalar * list = (scalar *) alist;
  Tree * q = ((Tree *)grid);

  for (int l = 0; l <= depth(); l++) {
    Layer * L = q->L[l];    
#line 308 "/home/spencer/basilisk/src/grid/memindex/range.h"
struct _Memindex * _m = (
#line 765 "/home/spencer/basilisk/src/grid/tree.h"
L->m
#line 308 "/home/spencer/basilisk/src/grid/memindex/range.h"
);
  int _len = (
#line 765 "/home/spencer/basilisk/src/grid/tree.h"
L->len
#line 309 "/home/spencer/basilisk/src/grid/memindex/range.h"
);
  Point point = {0};
  for (point.i = ( (Period.x*2) > (_m->r1.start) ? (Period.x*2) : (_m->r1.start));
       point.i < ( (_len - Period.x*2) < (_m->r1.end) ? (_len - Period.x*2) : (_m->r1.end));
       point.i += 1)
    if (_m->b[point.i])
      for (point.j = ( (Period.y*2) > (_m->r2[point.i].start) ? (Period.y*2) : (_m->r2[point.i].start));
    point.j < ( (_len - Period.y*2) < (_m->r2[point.i].end) ? (_len - Period.y*2) : (_m->r2[point.i].end));
    point.j += 1)
 if (_m->b[point.i][point.j]) 
#line 765 "/home/spencer/basilisk/src/grid/tree.h"
{
      point.level = l;
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
 if (!is_constant(s))
   for (int b = 0; b < _attribute[s.i].block; b++)
     data(0,0,0)[s.i + b] = val;
      }}}
    }
  }
}

static CacheLevel * cache_level_resize (CacheLevel * name, int a)
{
  for (int i = 0; i <= depth() - a; i++)
    pfree (name[i].p,__func__,__FILE__,__LINE__);
  pfree (name,__func__,__FILE__,__LINE__);
  return ((CacheLevel *) pcalloc (depth() + 1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
}

static void update_depth (int inc)
{
  Tree * q = ((Tree *)grid);
  grid->depth += inc;
  q->L = &(q->L[-1]);
  q->L = (Layer * *) prealloc (q->L, (grid->depth + 2)*sizeof(Layer *),__func__,__FILE__,__LINE__);
  q->L = &(q->L[1]);
  if (inc > 0)
    q->L[grid->depth] = new_layer (grid->depth);
  q->active = cache_level_resize (q->active, inc);
  q->prolongation = cache_level_resize (q->prolongation, inc);
  q->boundary = cache_level_resize (q->boundary, inc);
  q->restriction = cache_level_resize (q->restriction, inc);
}
#line 824 "/home/spencer/basilisk/src/grid/tree.h"
typedef void (* PeriodicFunction) (struct _Memindex *, int, int, int, void *);

static void periodic_function (struct _Memindex * m, int i, int j, int len, void * b,
          PeriodicFunction f)
{
  f(m, i, j, len, b);
  if (Period.x) {
    int nl = len - 2*2;
    for (int l = - 1; l <= 1; l += 2)
      for (int n = i + l*nl; n >= 0 && n < len; n += l*nl)
 f(m, n, j, len, b);
    if (Period.y)
      for (int l = - 1; l <= 1; l += 2)
 for (int n = j + l*nl; n >= 0 && n < len; n += l*nl) {
   f(m, i, n, len, b);
   for (int o = - 1; o <= 1; o += 2)
     for (int p = i + o*nl; p >= 0 && p < len; p += o*nl)
       f(m, p, n, len, b);
 }
  }
  else if (Period.y) {
    int nl = len - 2*2;
    for (int l = - 1; l <= 1; l += 2)
      for (int n = j + l*nl; n >= 0 && n < len; n += l*nl)
 f(m, i, n, len, b);
  }
}

static void assign_periodic (struct _Memindex * m, int i, int j, int len, void * b)
{
  periodic_function (m, i, j, len, b, mem_assign);
}

static void free_periodic (struct _Memindex * m, int i, int j, int len)
{
  periodic_function (m, i, j, len, NULL, mem_free);
}
#line 939 "/home/spencer/basilisk/src/grid/tree.h"
static void alloc_children (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 941
if (point.level == grid->depth)
    update_depth (+1);
  else if (allocated_child(0,0,0))
    return;


  Layer * L = ((Tree *)grid)->L[point.level + 1];
  L->nc++;
  size_t len = sizeof(Cell) + datasize;
  char * b = (char *) mempool_alloc0 (L->pool);
  int i = 2*point.i - 2;
  for (int k = 0; k < 2; k++, i++) {




    int j = 2*point.j - 2;
    for (int l = 0; l < 2; l++, j++) {
      assign_periodic (L->m, i, j, L->len, b);
      b += len;
    }
#line 972 "/home/spencer/basilisk/src/grid/tree.h"
  }

  int pid = cell.pid;  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 975
{
    cell.pid = pid;
#if TRASH
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      val(s,0,0,0) = undefined;}}
#endif
  }      
#line 377
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }

#line 982
}
#line 1001 "/home/spencer/basilisk/src/grid/tree.h"
static void free_children (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

  
#line 1004
Layer * L = ((Tree *)grid)->L[point.level + 1];
  int i = 2*point.i - 2, j = 2*point.j - 2;
  if (!(((L->m)->b[i][j]))) qassert ("/home/spencer/basilisk/src/grid/tree.h", 1006, "mem_data (L->m,i,j)");
  mempool_free (L->pool, ((L->m)->b[i][j]));
  for (int k = 0; k < 2; k++)
    for (int l = 0; l < 2; l++)
      free_periodic (L->m, i + k, j + l, L->len);
  if (--L->nc == 0) {
    destroy_layer (L);
    if (!(point.level + 1 == grid->depth)) qassert ("/home/spencer/basilisk/src/grid/tree.h", 1013, "point.level + 1 == grid->depth");
    update_depth (-1);
  }
}
#line 1042 "/home/spencer/basilisk/src/grid/tree.h"
void increment_neighbors (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1044
((Tree *)grid)->dirty = true;
  if (cell.neighbors++ == 0)
    alloc_children (point);  
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = (
#line 1047 "/home/spencer/basilisk/src/grid/tree.h"
2/2
#line 19 "/home/spencer/basilisk/src/grid/neighbors.h"
);
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1048
if (cell.neighbors++ == 0)
      alloc_children (point);      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
  
#line 1050 "/home/spencer/basilisk/src/grid/tree.h"
cell.neighbors--;
}

void decrement_neighbors (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1055
((Tree *)grid)->dirty = true;  
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = (
#line 1056 "/home/spencer/basilisk/src/grid/tree.h"
2/2
#line 19 "/home/spencer/basilisk/src/grid/neighbors.h"
);
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1057
if (allocated(0,0,0)) {
      cell.neighbors--;
      if (cell.neighbors == 0)
 free_children (point);
    }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
  
#line 1062 "/home/spencer/basilisk/src/grid/tree.h"
if (cell.neighbors) {
    int pid = cell.pid;    
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 1064
{
      cell.flags = 0;
      cell.pid = pid;
    }      
#line 377
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 1068
}
}

void realloc_scalar (int size)
{

  Tree * q = ((Tree *)grid);
  size_t oldlen = sizeof(Cell) + datasize;
  size_t newlen = oldlen + size;
  datasize += size;

  Layer * L = q->L[0];  
#line 308 "/home/spencer/basilisk/src/grid/memindex/range.h"
struct _Memindex * _m = (
#line 1080 "/home/spencer/basilisk/src/grid/tree.h"
L->m
#line 308 "/home/spencer/basilisk/src/grid/memindex/range.h"
);
  int _len = (
#line 1080 "/home/spencer/basilisk/src/grid/tree.h"
L->len
#line 309 "/home/spencer/basilisk/src/grid/memindex/range.h"
);
  Point point = {0};
  for (point.i = ( (Period.x*2) > (_m->r1.start) ? (Period.x*2) : (_m->r1.start));
       point.i < ( (_len - Period.x*2) < (_m->r1.end) ? (_len - Period.x*2) : (_m->r1.end));
       point.i += 1)
    if (_m->b[point.i])
      for (point.j = ( (Period.y*2) > (_m->r2[point.i].start) ? (Period.y*2) : (_m->r2[point.i].start));
    point.j < ( (_len - Period.y*2) < (_m->r2[point.i].end) ? (_len - Period.y*2) : (_m->r2[point.i].end));
    point.j += 1)
 if (_m->b[point.i][point.j]) 
#line 1080 "/home/spencer/basilisk/src/grid/tree.h"
{




    char * p = (char *) prealloc (((L->m)->b[point.i][point.j]),
     newlen*sizeof(char),__func__,__FILE__,__LINE__);
    assign_periodic (L->m, point.i, point.j, L->len, p);





  }

  for (int l = 1; l <= depth(); l++) {
    Layer * L = q->L[l];
    Mempool * oldpool = L->pool;
    L->pool = mempool_new (poolsize (l, newlen), (1 << 2)*newlen);    
#line 308 "/home/spencer/basilisk/src/grid/memindex/range.h"
struct _Memindex * _m = (
#line 1099 "/home/spencer/basilisk/src/grid/tree.h"
L->m
#line 308 "/home/spencer/basilisk/src/grid/memindex/range.h"
);
  int _len = (
#line 1099 "/home/spencer/basilisk/src/grid/tree.h"
L->len
#line 309 "/home/spencer/basilisk/src/grid/memindex/range.h"
);
  Point point = {0};
  for (point.i = ( (Period.x*2) > (_m->r1.start) ? (Period.x*2) : (_m->r1.start));
       point.i < ( (_len - Period.x*2) < (_m->r1.end) ? (_len - Period.x*2) : (_m->r1.end));
       point.i += 2)
    if (_m->b[point.i])
      for (point.j = ( (Period.y*2) > (_m->r2[point.i].start) ? (Period.y*2) : (_m->r2[point.i].start));
    point.j < ( (_len - Period.y*2) < (_m->r2[point.i].end) ? (_len - Period.y*2) : (_m->r2[point.i].end));
    point.j += 2)
 if (_m->b[point.i][point.j]) 
#line 1099 "/home/spencer/basilisk/src/grid/tree.h"
{
      char * new = (char *) mempool_alloc (L->pool);







      for (int k = 0; k < 2; k++)
 for (int o = 0; o < 2; o++) {
   memcpy (new, ((L->m)->b[point.i + k][point.j + o]), oldlen);
   assign_periodic (L->m, point.i + k, point.j + o, L->len, new);
   new += newlen;
 }
#line 1125 "/home/spencer/basilisk/src/grid/tree.h"
    }
    mempool_destroy (oldpool);
  }
}



#define VN v.x
#define VT v.y
#define VR v.z




#if _MPI
# define disable_fpe_for_mpi() disable_fpe (FE_DIVBYZERO|FE_INVALID)
# define enable_fpe_for_mpi() enable_fpe (FE_DIVBYZERO|FE_INVALID)
#else
# define disable_fpe_for_mpi()
# define enable_fpe_for_mpi()
#endif

static inline void no_restriction (Point point, scalar s);

static bool normal_neighbor (Point point, scalar * scalars, vector * vectors)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1151
for (int k = 1; k <= 2; k++)
    {
      for (int i = -k; i <= k; i += 2*k)
 if ((allocated(i,0,0) && !(neighbor(i,0,0).pid < 0))) {
   Point neighbor = neighborp(i,0,0);
   int id = (- cell.pid - 1);
   {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    
       val(s,0,0,0) = _attribute[s.i].boundary[id](neighbor, point, s, NULL);}}
   {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
     {
       scalar vn = VN;
       val(v.x,0,0,0) = _attribute[vn.i].boundary[id](neighbor, point, v.x, NULL);

       scalar vt = VT;
       val(v.y,0,0,0) = _attribute[vt.i].boundary[id](neighbor, point, v.y, NULL);





     }}}
   return true;
 }      
#line 1153
for (int i = -k; i <= k; i += 2*k)
 if ((allocated(0,i,0) && !(neighbor(0,i,0).pid < 0))) {
   Point neighbor = neighborp(0,i,0);
   int id = (- cell.pid - 1);
   {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    
       val(s,0,0,0) = _attribute[s.i].boundary[id](neighbor, point, s, NULL);}}
   {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
     {
       scalar vn = VN;
       val(v.y,0,0,0) = _attribute[vn.i].boundary[id](neighbor, point, v.y, NULL);

       scalar vt = VT;
       val(v.x,0,0,0) = _attribute[vt.i].boundary[id](neighbor, point, v.x, NULL);





     }}}
   return true;
 }}
  return false;
}

static bool diagonal_neighbor_2D (Point point,
      scalar * scalars, vector * vectors)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

  
#line 1182
for (int k = 1; k <= 2; k++)



      for (int i = -k; i <= k; i += 2*k)
 for (int j = -k; j <= k; j += 2*k)
   if (allocated(i,j,0) && (allocated(i,j,0) && !(neighbor(i,j,0).pid < 0)) &&
       allocated(i,0,0) && (neighbor(i,0,0).pid < 0) &&
       allocated(0,j,0) && (neighbor(0,j,0).pid < 0)) {
     Point n = neighborp(i,j,0),
       n1 = neighborp(i,0,0), n2 = neighborp(0,j,0);
     int id1 = (- neighbor(i,0,0).pid - 1), id2 = (- neighbor(0,j,0).pid - 1);
     {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      
  val(s,0,0,0) = (_attribute[s.i].boundary[id1](n,n1,s,NULL) +
         _attribute[s.i].boundary[id2](n,n2,s,NULL) -
         val(s,i,j,0));}}
     {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
       {
  scalar vt = VT, vn = VN;
  val(v.x,0,0,0) = (_attribute[vt.i].boundary[id1](n,n1,v.x,NULL) +
    _attribute[vn.i].boundary[id2](n,n2,v.x,NULL) -
    val(v.x,i,j,0));
  val(v.y,0,0,0) = (_attribute[vn.i].boundary[id1](n,n1,v.y,NULL) +
    _attribute[vt.i].boundary[id2](n,n2,v.y,NULL) -
    val(v.y,i,j,0));






       }}}
     return true;
   }

  return false;
}

static bool diagonal_neighbor_3D (Point point,
      scalar * scalars, vector * vectors)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1267 "/home/spencer/basilisk/src/grid/tree.h"
  return false;
}



static Point tangential_neighbor_x (Point point, bool * zn)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1274
for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if ((allocated(0,j,0) && !(neighbor(0,j,0).pid < 0)) || (allocated(-1,j,0) && !(neighbor(-1,j,0).pid < 0))) {
 *zn = false;
 return neighborp(0,j,0);
      }







    }
  return (Point){.level = -1};
}
#line 1272
static Point tangential_neighbor_y (Point point, bool * zn)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1274
for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if ((allocated(j,0,0) && !(neighbor(j,0,0).pid < 0)) || (allocated(j,-1,0) && !(neighbor(j,-1,0).pid < 0))) {
 *zn = false;
 return neighborp(j,0,0);
      }







    }
  return (Point){.level = -1};
}


static inline bool is_boundary_point (Point point) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1293
return (cell.pid < 0);
}

static void box_boundary_level (const Boundary * b, scalar * list, int l)
{
  disable_fpe_for_mpi();
  scalar * scalars = NULL;
  vector * vectors = NULL, * faces = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i) {
 if (_attribute[s.i].face)
   faces = vectors_add (faces, _attribute[s.i].v);
 else
   vectors = vectors_add (vectors, _attribute[s.i].v);
      }
      else if (_attribute[s.i].v.x.i < 0 && _attribute[s.i].boundary[0])
 scalars = list_add (scalars, s);
    }}}
#line 482
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _boundary = ((Tree *)grid)->boundary[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _boundary.n; _k++) {
 point.i = _boundary.p[_k].i;

 point.j = _boundary.p[_k].j; 
#line 1313
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1313
{
    if (!normal_neighbor (point, scalars, vectors) &&
 !diagonal_neighbor_2D (point, scalars, vectors) &&
 !diagonal_neighbor_3D (point, scalars, vectors)) {

      {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){

   val(s,0,0,0) = undefined;}}
      {vector*_i=(vector*)( vectors);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){

   {
     val(v.x,0,0,0) = undefined;     val(v.y,0,0,0) = undefined;}}}
    }
    if (faces) {
      int id = (- cell.pid - 1);
      
 for (int i = -1; i <= 1; i += 2) {

   if ((allocated(i,0,0) && !(neighbor(i,0,0).pid < 0))) {
     Point neighbor = neighborp(i,0,0);
     {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {
       scalar vn = VN;
       if (_attribute[vn.i].boundary[id])
 
    val(v.x,(i + 1)/2,0,0) = _attribute[vn.i].boundary[id](neighbor, point, v.x, NULL);
     }}}
   }

   else if (i == -1) {

     bool zn;
     Point neighbor = tangential_neighbor_x (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- neighbor(-1,0,0).pid - 1) : (- cell.pid - 1);
       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {

  scalar vt = VT;



 
    val(v.x,0,0,0) = _attribute[vt.i].boundary[id](neighbor, point, v.x, NULL);
       }}}
     }
     else

       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
 
    val(v.x,0,0,0) = 0.;}}
   }

 } 
#line 1329
for (int i = -1; i <= 1; i += 2) {

   if ((allocated(0,i,0) && !(neighbor(0,i,0).pid < 0))) {
     Point neighbor = neighborp(0,i,0);
     {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {
       scalar vn = VN;
       if (_attribute[vn.i].boundary[id])
 
    val(v.y,0,(i + 1)/2,0) = _attribute[vn.i].boundary[id](neighbor, point, v.y, NULL);
     }}}
   }

   else if (i == -1) {

     bool zn;
     Point neighbor = tangential_neighbor_y (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- neighbor(0,-1,0).pid - 1) : (- cell.pid - 1);
       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ {

  scalar vt = VT;



 
    val(v.y,0,0,0) = _attribute[vt.i].boundary[id](neighbor, point, v.y, NULL);
       }}}
     }
     else

       {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
 
    val(v.y,0,0,0) = 0.;}}
   }

 }
    }
  }}      
#line 475
}
  }
}
  









}
}

  
#line 1369
pfree (scalars,__func__,__FILE__,__LINE__);
  pfree (vectors,__func__,__FILE__,__LINE__);
  pfree (faces,__func__,__FILE__,__LINE__);
  enable_fpe_for_mpi();
}



#undef VN
#undef VT
#define VN _attribute[s.i].v.x
#define VT _attribute[s.i].v.y

static double masked_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1384
double sum = 0., n = 0.;  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1386
if (!(cell.pid < 0) && val(s,0,0,0) != 1e30f)
      sum += val(s,0,0,0), n++;      
#line 377
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 1388
return n ? sum/n : 1e30f;
}


static double masked_average_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1394
double sum = 0., n = 0.;  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1396
if (child.x < 0 && (!(cell.pid < 0) || !(neighbor(1,0,0).pid < 0)) &&
 val(s,1,0,0) != 1e30f)
      sum += val(s,1,0,0), n++;      
#line 377
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 1399
return n ? sum/n : 1e30f;
}
#line 1392
static double masked_average_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1394
double sum = 0., n = 0.;  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1396
if (child.y < 0 && (!(cell.pid < 0) || !(neighbor(0,1,0).pid < 0)) &&
 val(s,0,1,0) != 1e30f)
      sum += val(s,0,1,0), n++;      
#line 377
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 1399
return n ? sum/n : 1e30f;
}

static void masked_boundary_restriction (const Boundary * b,
      scalar * list, int l)
{
  scalar * scalars = NULL;
  vector * faces = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i && _attribute[s.i].face)
 faces = vectors_add (faces, _attribute[s.i].v);
      else
 scalars = list_add (scalars, s);
    }}}
#line 504
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _cache = ((Tree *)grid)->restriction[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _cache.n; _k++) {
 point.i = _cache.p[_k].i;

 point.j = _cache.p[_k].j; 
#line 1415
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1415
{
    {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      val(s,0,0,0) = masked_average (parent, s);}}
    {vector*_i=(vector*)( faces);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      { {
 double average = masked_average_x (parent, v.x);
 if ((neighbor(-1,0,0).pid < 0))
   val(v.x,0,0,0) = average;
 if ((neighbor(1,0,0).pid < 0))
   val(v.x,1,0,0) = average;
      } 
#line 1419
{
 double average = masked_average_y (parent, v.y);
 if ((neighbor(0,-1,0).pid < 0))
   val(v.y,0,0,0) = average;
 if ((neighbor(0,1,0).pid < 0))
   val(v.y,0,1,0) = average;
      }}}}
  }}      
#line 475
}
  }
}
  
#line 510
}
}

  
#line 1428
pfree (scalars,__func__,__FILE__,__LINE__);
  pfree (faces,__func__,__FILE__,__LINE__);
}

void macro_mask (double func) {
#line 255 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 156
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   if ((
#line 264
(
#line 1433 "/home/spencer/basilisk/src/grid/tree.h"
!is_leaf(cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 182
))
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }







      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 if ((
#line 264
(
#line 1433 "/home/spencer/basilisk/src/grid/tree.h"
!is_leaf(cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 196
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 if ((
#line 264
(
#line 1433 "/home/spencer/basilisk/src/grid/tree.h"
!is_leaf(cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 201
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };
 if ((
#line 264
(
#line 1433 "/home/spencer/basilisk/src/grid/tree.h"
!is_leaf(cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 206
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
#line 246 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      default: 
#line 1433 "/home/spencer/basilisk/src/grid/tree.h"
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1433
{
    if (is_leaf(cell)) {
      int bid = (func);
      if (bid >= 0)
 cell.pid = - bid - 1;
    }
    else {
      int pid = -1;      
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
  
 
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 1442
if (cell.pid >= 0 || pid < 0)
   pid = cell.pid;      
#line 377
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
      
#line 1444
cell.pid = pid;
      if (pid < 0) {

 cell.flags |= leaf;
 decrement_neighbors (point);
      }
    }
  }}      
#line 249 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
    }
  }
}
  
#line 266
}
}
  
#line 1452 "/home/spencer/basilisk/src/grid/tree.h"
((Tree *)grid)->dirty = true;
}

static void free_cache (CacheLevel * c)
{
  for (int l = 0; l <= depth(); l++)
    pfree (c[l].p,__func__,__FILE__,__LINE__);
  pfree (c,__func__,__FILE__,__LINE__);
}

void free_grid (void)
{
  if (!grid)
    return;
  free_boundaries();
  Tree * q = ((Tree *)grid);
  pfree (q->leaves.p,__func__,__FILE__,__LINE__);
  pfree (q->faces.p,__func__,__FILE__,__LINE__);
  pfree (q->vertices.p,__func__,__FILE__,__LINE__);
  pfree (q->refined.p,__func__,__FILE__,__LINE__);


  Layer * L = q->L[0];  
#line 308 "/home/spencer/basilisk/src/grid/memindex/range.h"
struct _Memindex * _m = (
#line 1475 "/home/spencer/basilisk/src/grid/tree.h"
L->m
#line 308 "/home/spencer/basilisk/src/grid/memindex/range.h"
);
  int _len = (
#line 1475 "/home/spencer/basilisk/src/grid/tree.h"
L->len
#line 309 "/home/spencer/basilisk/src/grid/memindex/range.h"
);
  Point point = {0};
  for (point.i = ( (Period.x*2) > (_m->r1.start) ? (Period.x*2) : (_m->r1.start));
       point.i < ( (_len - Period.x*2) < (_m->r1.end) ? (_len - Period.x*2) : (_m->r1.end));
       point.i += 1)
    if (_m->b[point.i])
      for (point.j = ( (Period.y*2) > (_m->r2[point.i].start) ? (Period.y*2) : (_m->r2[point.i].start));
    point.j < ( (_len - Period.y*2) < (_m->r2[point.i].end) ? (_len - Period.y*2) : (_m->r2[point.i].end));
    point.j += 1)
 if (_m->b[point.i][point.j]) 
#line 1475 "/home/spencer/basilisk/src/grid/tree.h"
{



    pfree (((L->m)->b[point.i][point.j]),__func__,__FILE__,__LINE__);



  }
  for (int l = 0; l <= depth(); l++)
    destroy_layer (q->L[l]);
  q->L = &(q->L[-1]);
  pfree (q->L,__func__,__FILE__,__LINE__);
  free_cache (q->active);
  free_cache (q->prolongation);
  free_cache (q->boundary);
  free_cache (q->restriction);
  pfree (q,__func__,__FILE__,__LINE__);
  grid = NULL;
}

static void refine_level (int depth);

     
void init_grid (int n)
{tracing("init_grid","/home/spencer/basilisk/src/grid/tree.h",1499);

  if (!(sizeof(Cell) % 8 == 0)) qassert ("/home/spencer/basilisk/src/grid/tree.h", 1502, "sizeof(Cell) % 8 == 0");

  free_grid();
  int depth = 0;
  while (n > 1) {
    if (n % 2) {
      fprintf (ferr, "tree: N must be a power-of-two\n");
      exit (1);
    }
    n /= 2;
    depth++;
  }
  Tree * q = ((Tree *) pcalloc (1, sizeof(Tree),__func__,__FILE__,__LINE__));
  grid = (Grid *) q;
  grid->depth = 0;


  q->L = ((Layer * *) pmalloc ((2)*sizeof(Layer *),__func__,__FILE__,__LINE__));

  q->L[0] = NULL; q->L = &(q->L[1]);

  Layer * L = new_layer (0);
  q->L[0] = L;
#line 1538 "/home/spencer/basilisk/src/grid/tree.h"
  for (int i = Period.x*2; i < L->len - Period.x*2; i++)
    for (int j = Period.y*2; j < L->len - Period.y*2; j++)
      assign_periodic (L->m, i, j, L->len,
         (char *) pcalloc (1, sizeof(Cell) + datasize,__func__,__FILE__,__LINE__));
  CELL(((L->m)->b[2][2])).flags |= leaf;
  if (pid() == 0)
    CELL(((L->m)->b[2][2])).flags |= active;
  for (int k = - 2*(1 - Period.x); k <= 2*(1 - Period.x); k++)
    for (int l = -2*(1 - Period.y); l <= 2*(1 - Period.y); l++)
      CELL(((L->m)->b[2 +k][2 +l])).pid =
 (k < 0 ? -1 - left :
  k > 0 ? -1 - right :
  l > 0 ? -1 - top :
  l < 0 ? -1 - bottom :
  0);
  CELL(((L->m)->b[2][2])).pid = 0;
#line 1576 "/home/spencer/basilisk/src/grid/tree.h"
  q->active = ((CacheLevel *) pcalloc (1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
  q->prolongation = ((CacheLevel *) pcalloc (1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
  q->boundary = ((CacheLevel *) pcalloc (1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
  q->restriction = ((CacheLevel *) pcalloc (1, sizeof(CacheLevel),__func__,__FILE__,__LINE__));
  q->dirty = true;
  N = 1 << depth;
#if _MPI
  void mpi_boundary_new();
  mpi_boundary_new();
#endif

  Boundary * b = ((Boundary *) pcalloc (1, sizeof(Boundary),__func__,__FILE__,__LINE__));
  b->level = box_boundary_level;
  b->restriction = masked_boundary_restriction;
  add_boundary (b);
  refine_level (depth);
  reset (all, 0.);
  { if (((Tree *)grid)->dirty) update_cache_f(); };
end_tracing("init_grid","/home/spencer/basilisk/src/grid/tree.h",1594);}


void check_two_one (void)
{
#line 286 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
#line 126
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
    
#line 288
if (is_leaf (cell)) {
      if (is_active(cell) && is_local(cell))
    
#line 1600 "/home/spencer/basilisk/src/grid/tree.h"
{  
#line 537 "/home/spencer/basilisk/src/grid/config.h"
;  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1600
if (level > 0)
      for (int k = -1; k <= 1; k++)
 for (int l = -1; l <= 1; l++) {

   int i = (point.i + 2)/2 + k;
   int j = (point.j + 2)/2 + l;
   double Delta = 1./(1 << point.level);
   double x = ((i - 2 + 0.5)*Delta*2. - 0.5);
   double y = ((j - 2 + 0.5)*Delta*2. - 0.5);
   if (x > -0.5 && x < 0.5 && y > -0.5 && y < 0.5 &&
       !(aparent(k,l,0).flags & active)) {
     FILE * fp = fopen("check_two_one_loc", "w");
     fprintf (fp,
       "# %d %d\n"
       "%g %g\n%g %g\n",
       k, l,
       ((point.i - 2 + 0.5)* - 0.5),
       ((point.j - 2 + 0.5)*Delta - 0.5),
       x, y);
     fclose (fp);





     if (!(false)) qassert ("/home/spencer/basilisk/src/grid/tree.h", 1625, "false");
   }
 }}      
#line 291 "/home/spencer/basilisk/src/grid/foreach_cell.h"
continue;
    } 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

#line 293
}

#line 1628 "/home/spencer/basilisk/src/grid/tree.h"
}


Point locate (double xp, double yp, double zp)
{
  for (int l = depth(); l >= 0; l--) {
    Point point = {0};
    point.level = l;
    int n = 1 << point.level;
    point.i = (xp - X0)/L0*n + 2;

    point.j = (yp - Y0)/L0*n + 2;




    if (point.i >= 0 && point.i < n + 2*2

 && point.j >= 0 && point.j < n + 2*2




 ) {
      if (allocated(0,0,0) && is_local(cell) && is_leaf(cell))
 return point;
    }
    else
      break;
  }
  Point point = {0};
  point.level = -1;
  return point;
}



bool tree_is_full()
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
  return (grid->tn == 1L << grid->maxdepth*2);
}

#line 1 "grid/variables.h"
#line 1 "/home/spencer/basilisk/src/grid/variables.h"
void macro2_VARIABLES (Point point, int _ig, int _jg, int _kg)
{
  double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((_ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((_jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
}
#line 1672 "/home/spencer/basilisk/src/grid/tree.h"

void macro_foreach_boundary (int _b, Reduce reductions) {
  for (int _l = depth(); _l >= 0; _l--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 482 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _boundary = ((Tree *)grid)->boundary[_l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _boundary.n; _k++) {
 point.i = _boundary.p[_k].i;

 point.j = _boundary.p[_k].j; 
#line 1675
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1675
{      
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
      
#line 1677
if ((- cell.pid - 1) == _b)
 for (int _d = 0; _d < 2; _d++) {
   for (int _i = -1; _i <= 1; _i += 2) {
     if (_d == 0) ig = _i; else if (_d == 1) jg = _i; else kg = _i;
     if (allocated(-ig,-jg,-kg) &&
  is_leaf (neighbor(-ig,-jg,-kg)) &&
  !(neighbor(-ig,-jg,-kg).pid < 0) &&
  is_local(neighbor(-ig,-jg,-kg))) {
       point.i -= ig; x -= ig*Delta/2.;

       point.j -= jg; y -= jg*Delta/2.;




       ;
       point.i += ig; x += ig*Delta/2.;

       point.j += jg; y += jg*Delta/2.;




            }
   }
   ig = jg = kg = 0;
 }
    }}      
#line 475
}
  }
}
  









}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 1705 "/home/spencer/basilisk/src/grid/tree.h"
}

void macro_foreach_vertex (char flags, Reduce reductions)
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 1710
((Tree *)grid)->vertices
#line 436
).n; _k++) {
 point.i = (
#line 1710
((Tree *)grid)->vertices
#line 437
).p[_k].i;

 point.j = (
#line 1710
((Tree *)grid)->vertices
#line 439
).p[_k].j;




 point.level = (
#line 1710
((Tree *)grid)->vertices
#line 444
).p[_k].level;
 _flags = (
#line 1710
((Tree *)grid)->vertices
#line 445
).p[_k].flags; 
#line 1710
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1710
{
    int ig = -1; NOT_UNUSED (ig);

    int jg = -1; NOT_UNUSED (jg);




    ;
  }}      
#line 447
}
  }
}

#line 1720
}

#line 1 "grid/tree-common.h"
#line 1 "/home/spencer/basilisk/src/grid/tree-common.h"



#line 1 "grid/multigrid-common.h"
#line 1 "/home/spencer/basilisk/src/grid/multigrid-common.h"



#line 1 "grid/cartesian-common.h"
#line 1 "/home/spencer/basilisk/src/grid/cartesian-common.h"
#line 1 "grid/events.h"
#line 1 "/home/spencer/basilisk/src/grid/events.h"
typedef struct _Event Event;
typedef int (* Expr) (int *, double *, Event *);

struct _Event {
  int last, nexpr;
  int (* action) (const int, const double, Event *);
  Expr expr[3];
  int * arrayi;
  double * arrayt;
  char * file;
  int line;
  char * name;
  double t;
  int i, a;
  void * data;
  Event * next;
};

static Event * Events = NULL;

int iter = 0, inext = 0;
double t = 0, tnext = 0;
void init_events (void);
void event_register (Event event);
static void _init_solver (void);





static int END_EVENT = 1234567890;
static double TEND_EVENT = 1234567890;
static double TEPS = 1e-9;

static void event_error (Event * ev, const char * s)
{
  fprintf (ferr, "%s:%d: error: %s\n", ev->file, ev->line, s);
  exit (1);
}

static void init_event (Event * ev)
{
  if (ev->arrayi || ev->arrayt) {
    ev->i = -1; ev->t = - TEND_EVENT;
    if (ev->arrayi)
      ev->i = ev->arrayi[0];
    else
      ev->t = ev->arrayt[0];
    ev->a = 1;
    ev->expr[1] = NULL;
  }
  else {
    if (ev->nexpr > 0) {
      Expr init = NULL, cond = NULL, inc = NULL;
      for (int j = 0; j < ev->nexpr; j++) {
 int i = -123456; double t = - TEND_EVENT;
 (* ev->expr[j]) (&i, &t, ev);
 if (i == -123456 && t == - TEND_EVENT) {

   if (cond)
     event_error (ev, "events can only use a single condition");
   cond = ev->expr[j];
 }
 else {

   int i1 = i; double t1 = t;
   (* ev->expr[j]) (&i1, &t1, ev);
   if (i1 == i && t1 == t) {


     if (init)
       event_error (ev, "events can only use a single initialisation");
     init = ev->expr[j];
   }
   else {

     if (inc)
       event_error (ev, "events can only use a single increment");
     inc = ev->expr[j];
   }
 }
      }
      ev->expr[0] = init;
      ev->expr[1] = cond;
      ev->expr[2] = inc;
      ev->nexpr = 0;
    }
    ev->i = -1; ev->t = - TEND_EVENT;
    if (ev->expr[0]) {
      (* ev->expr[0]) (&ev->i, &ev->t, ev);
      if (ev->i == END_EVENT || ev->t == TEND_EVENT) {
 ev->i = END_EVENT; ev->t = - TEND_EVENT;
      }
    }
    else if (ev->expr[2]) {
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (ev->i != -1)
 ev->i = 0;
      if (ev->t != - TEND_EVENT)
 ev->t = 0;
    }
  }
}

enum { event_done, event_alive, event_stop };

static int event_finished (Event * ev)
{
  ev->i = -1; ev->t = - TEND_EVENT;
  return event_done;
}

void event_register (Event event) {
  if (!(Events)) qassert ("/home/spencer/basilisk/src/grid/events.h", 114, "Events");
  if (!(!event.last)) qassert ("/home/spencer/basilisk/src/grid/events.h", 115, "!event.last");
  int n = 0, parent = -1;
  for (Event * ev = Events; !ev->last; ev++) {
    if (!strcmp (event.name, ev->name)) {
      if (!(parent < 0)) qassert ("/home/spencer/basilisk/src/grid/events.h", 119, "parent < 0");
      parent = n;
    }
    n++;
  }
  if (parent < 0) {
    Events = (Event *) prealloc (Events, (n + 2)*sizeof(Event),__func__,__FILE__,__LINE__);
    Events[n] = event;
    Events[n].next = NULL;
    Events[n + 1].last = true;
    init_event (&Events[n]);
  }
  else {
    Event * ev = ((Event *) pcalloc (1, sizeof(Event),__func__,__FILE__,__LINE__));
    *ev = Events[parent];
    Events[parent] = event;
    Events[parent].next = ev;
    init_event (&Events[parent]);
  }
}

static int event_cond (Event * ev, int i, double t)
{
  if (!ev->expr[1])
    return true;
  return (* ev->expr[1]) (&i, &t, ev);
}
#line 162 "/home/spencer/basilisk/src/grid/events.h"
static bool overload_event() { return true; }

static int event_do (Event * ev, bool action)
{
  if ((iter > ev->i && t > ev->t) || !event_cond (ev, iter, t))
    return event_finished (ev);
  if (!overload_event() || iter == ev->i || fabs (t - ev->t) <= TEPS*t) {
    if (action) {
      bool finished = false;
      for (Event * e = ev; e; e = e->next) {



 if ((* e->action) (iter, t, e))
   finished = true;
      }
      if (finished) {
 event_finished (ev);
 return event_stop;
      }
    }
    if (ev->arrayi) {
      ev->i = ev->arrayi[ev->a++];
      if (ev->i < 0)
 return event_finished (ev);
    }
    if (ev->arrayt) {
      ev->t = ev->arrayt[ev->a++];
      if (ev->t < 0)
 return event_finished (ev);
    }
    else if (ev->expr[2]) {
      int i0 = ev->i;
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (i0 == -1 && ev->i != i0)
 ev->i += iter + 1;
      if (!event_cond (ev, iter + 1, ev->t))
 return event_finished (ev);
    }
    else if (ev->expr[0] && !ev->expr[1])
      return event_finished (ev);
  }
  return event_alive;
}

static void end_event_do (bool action)
{




  for (Event * ev = Events; !ev->last; ev++)
    if (ev->i == END_EVENT && action)
      for (Event * e = ev; e; e = e->next) {



 e->action (iter, t, e);
      }
}

int events (bool action)
{





  if (iter == 0)
    for (Event * ev = Events; !ev->last; ev++)
      init_event (ev);

  int cond = 0, cond1 = 0;
  inext = END_EVENT; tnext = 1e30f;
  for (Event * ev = Events; !ev->last && !cond; ev++)
    if (ev->i != END_EVENT &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond = 1;
  for (Event * ev = Events; !ev->last; ev++) {
    int status = event_do (ev, action);
    if (status == event_stop) {
      end_event_do (action);
      return 0;
    }
    if (status == event_alive && ev->i != END_EVENT &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond1 = 1;
    if (ev->t > t && ev->t < tnext)
      tnext = ev->t;
    if (ev->i > iter && ev->i < inext)
      inext = ev->i;
  }
  if (overload_event() && (!cond || cond1) && (tnext != 1e30f || inext != END_EVENT)) {
    inext = iter + 1;
    return 1;
  }
  end_event_do (action);
  return 0;
}

void event (const char * name)
{
  for (Event * ev = Events; !ev->last; ev++)
    if (!strcmp (ev->name, name))
      for (Event * e = ev; e; e = e->next) {



 (* e->action) (0, 0, e);
      }
}

double dtnext (double dt)
{
  if (tnext != 1e30f && tnext > t) {
    if (!(dt > 0.)) qassert ("/home/spencer/basilisk/src/grid/events.h", 277, "dt > 0.");
    unsigned int n = (tnext - t)/dt;
    if (!(n < INT_MAX)) qassert ("/home/spencer/basilisk/src/grid/events.h", 279, "n < INT_MAX");
    if (n == 0)
      dt = tnext - t;
    else {
      double dt1 = (tnext - t)/n;
      if (dt1 > dt*(1. + TEPS))
 dt = (tnext - t)/(n + 1);
      else if (dt1 < dt)
 dt = dt1;
      tnext = t + dt;
    }
  }
  else
    tnext = t + dt;
  return dt;
}

void init_solver()
{
  Events = pmalloc (sizeof (Event),__func__,__FILE__,__LINE__);
  Events[0].last = 1;
  _attribute = pcalloc (datasize/sizeof(real), sizeof (_Attributes),__func__,__FILE__,__LINE__);
  int n = datasize/sizeof(real);
  all = (scalar *) pmalloc (sizeof (scalar)*(n + 1),__func__,__FILE__,__LINE__);
  baseblock = (scalar *) pmalloc (sizeof (scalar)*(n + 1),__func__,__FILE__,__LINE__);
  for (int i = 0; i < n; i++)
    baseblock[i].i = all[i].i = i;
  baseblock[n].i = all[n].i = -1;
#line 317 "/home/spencer/basilisk/src/grid/events.h"
}
#line 2 "/home/spencer/basilisk/src/grid/cartesian-common.h"

void (* debug) (Point);

#define _val_constant(a,k,l,m) ((const double) _constant[a.i -_NVARMAX])
#define val_diagonal(a,k,l,m) ((k) == 0 && (l) == 0 && (m) == 0)

#line 1 "grid/fpe.h"
#line 1 "/home/spencer/basilisk/src/grid/fpe.h"


#include <signal.h>
#include <unistd.h>

static int gdb()
{
  if (last_point.level >= 0) {
    debug (last_point);
    fputc ('\n', ferr);
    fflush (ferr);
  }
  char command[80];
  sprintf (command, "exec xterm -e 'gdb -p %d' & xterm -e 'gnuplot plot -'",
    getpid());
  return system (command);
}

static void caught_abort (int sig)
{
  fprintf (ferr, "Caught signal %d (Aborted)\n", sig);
  gdb();
}

static void caught_fpe (int sig)
{
  fprintf (ferr, "Caught signal %d (Floating Point Exception)\n", sig);
  gdb();
  exit (1);
}

static void caught_segfault (int sig)
{
  fprintf (ferr, "Caught signal %d (Segmentation Fault)\n", sig);
  gdb();
  exit (2);
}

void catch_fpe (void)
{
  struct sigaction act;
  act.sa_handler = caught_fpe;
  sigemptyset (&act.sa_mask);
  act.sa_flags = 0;
  last_point.level = -1;
  sigaction (8, &act, NULL);
  act.sa_handler = caught_segfault;
  sigaction (11, &act, NULL);
  act.sa_handler = caught_abort;
  act.sa_flags = SA_RESETHAND;
  sigaction (6, &act, NULL);
}
#line 9 "/home/spencer/basilisk/src/grid/cartesian-common.h"
#line 1 "grid/stencils.h"
#line 1 "/home/spencer/basilisk/src/grid/stencils.h"
#line 17 "/home/spencer/basilisk/src/grid/stencils.h"










typedef struct _External External;

struct _External {
  char * name;
  void * pointer;
  int type;
  int nd;
  char reduct;
  char global;
  void * data;
  scalar s;
  External * externals, * next;
  int used;
};

typedef struct {
  const char * fname;
  int line;
  int first;
  int face;
  bool vertex;
  int parallel;
  scalar * listc;
  vectorl listf;
  scalar * dirty;
  void * data;
} ForeachData;







static inline bool scalar_is_dirty (scalar s)
{
  if (_attribute[s.i].dirty)
    return true;
  scalar * depends = _attribute[s.i].depends;
  {scalar*_i=(scalar*)( depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    if (_attribute[d.i].dirty)
      return true;}}
  return false;
}




static inline bool scalar_depends_from (scalar a, scalar b)
{
  scalar * depends = _attribute[a.i].depends;
  {scalar*_i=(scalar*)( depends);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (s.i == b.i)
      return true;}}
  return false;
}







void boundary_internal (scalar * list, const char * fname, int line);
void (* boundary_face) (vectorl);







void check_stencil (ForeachData * loop)
{
  loop->listf = (vectorl){NULL};




  {scalar*_i=(scalar*)( baseblock);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    bool write = _attribute[s.i].output, read = _attribute[s.i].input;




    {





      if (read && scalar_is_dirty (s)) {





 if (_attribute[s.i].face) {
   if (_attribute[s.i].width > 0)
     loop->listc = list_append (loop->listc, s);
   else if (!write) {
     scalar sn = _attribute[s.i].v.x.i >= 0 ? _attribute[s.i].v.x : s;
     
       if (_attribute[s.i].v.x.i == s.i) {




  if (_attribute[sn.i].boundary[left] || _attribute[sn.i].boundary[right])
    loop->listc = list_append (loop->listc, s);
  else if (_attribute[s.i].dirty != 2)
    loop->listf.x = list_append (loop->listf.x, s);
       }       
#line 130
if (_attribute[s.i].v.y.i == s.i) {




  if (_attribute[sn.i].boundary[bottom] || _attribute[sn.i].boundary[top])
    loop->listc = list_append (loop->listc, s);
  else if (_attribute[s.i].dirty != 2)
    loop->listf.y = list_append (loop->listf.y, s);
       }
   }
 }





 else if (_attribute[s.i].width > 0)
   loop->listc = list_append (loop->listc, s);
      }





      if (write) {
 if (2 > 1 && !loop->vertex && loop->first && !_attribute[s.i].nowarning) {
   bool vertex = true;
   
     if (_attribute[s.i].d.x != -1)
       vertex = false;     
#line 159
if (_attribute[s.i].d.y != -1)
       vertex = false;
   if (vertex)
     fprintf (ferr,
       "%s:%d: warning: vertex scalar '%s' should be assigned with"
       " a foreach_vertex() loop\n",
       loop->fname, loop->line, _attribute[s.i].name);
 }
 if (_attribute[s.i].face) {
   if (loop->face == 0 && loop->first && !_attribute[s.i].nowarning)
     fprintf (ferr,
       "%s:%d: warning: face vector '%s' should be assigned with"
       " a foreach_face() loop\n",
       loop->fname, loop->line, _attribute[s.i].name);
 }
 else if (loop->face) {
   if (_attribute[s.i].v.x.i < 0) {
     int d = 1, i = 0;
      {
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.x.i = s.i;
  _attribute[s.i].boundary[left] = _attribute[s.i].boundary[right] = NULL;





       }
       d *= 2, i++;
     } 
#line 177
{
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.y.i = s.i;
  _attribute[s.i].boundary[bottom] = _attribute[s.i].boundary[top] = NULL;





       }
       d *= 2, i++;
     }
     if (!_attribute[s.i].face && loop->first && !_attribute[s.i].nowarning)
       fprintf (ferr,
         "%s:%d: warning: scalar '%s' should be assigned with "
         "a foreach_face(x|y|z) loop\n",
         loop->fname, loop->line, _attribute[s.i].name);
   }
   else {
     char * name = NULL;
     if (_attribute[s.i].name) {
       name = pstrdup (_attribute[s.i].name,__func__,__FILE__,__LINE__);
       char * s = name + strlen(name) - 1;
       while (s != name && *s != '.') s--;
       if (s != name) *s = '\0';
     }
     struct { int x, y, z; } input, output;
     vector v = _attribute[s.i].v;

     
       input.x = _attribute[v.x.i].input, output.x = _attribute[v.x.i].output;       input.y = _attribute[v.y.i].input, output.y = _attribute[v.y.i].output;

     init_face_vector (v, name);


     
       _attribute[v.x.i].input = input.x, _attribute[v.x.i].output = output.x;       _attribute[v.y.i].input = input.y, _attribute[v.y.i].output = output.y;





     pfree (name,__func__,__FILE__,__LINE__);
   }
 }
 else if (loop->vertex) {
   bool vertex = true;
   
     if (_attribute[s.i].d.x != -1)
       vertex = false;     
#line 225
if (_attribute[s.i].d.y != -1)
       vertex = false;
   if (!vertex) {
     char * name = NULL;
     if (_attribute[s.i].name) name = pstrdup (_attribute[s.i].name,__func__,__FILE__,__LINE__);
     init_vertex_scalar (s, name);
     
       _attribute[s.i].v.x.i = -1;       _attribute[s.i].v.y.i = -1;




     pfree (name,__func__,__FILE__,__LINE__);
   }
 }





 loop->dirty = list_append (loop->dirty, s);
 {scalar*_i=(scalar*)( baseblock);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
   if (scalar_depends_from (d, s))
     loop->dirty = list_append (loop->dirty, d);}}
      }
    }
  }}}
}




void boundary_stencil (ForeachData * loop)
{
  bool flux = false;
  
    if (loop->listf.x)
      flux = true;    
#line 261
if (loop->listf.y)
      flux = true;
  if (flux) {
#line 276 "/home/spencer/basilisk/src/grid/stencils.h"
    boundary_face (loop->listf);
    
      pfree (loop->listf.x,__func__,__FILE__,__LINE__), loop->listf.x = NULL;      pfree (loop->listf.y,__func__,__FILE__,__LINE__), loop->listf.y = NULL;
  }




  if (loop->listc) {






    boundary_internal (loop->listc, loop->fname, loop->line);
    pfree (loop->listc,__func__,__FILE__,__LINE__), loop->listc = NULL;
  }





  if (loop->dirty) {






    {scalar*_i=(scalar*)( loop->dirty);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = true;}}
    pfree (loop->dirty,__func__,__FILE__,__LINE__), loop->dirty = NULL;
  }
}

void macro_foreach_stencil (char flags, Reduce reductions)
{
  {
    static int _first = 1.;
    ForeachData _loop = {
      .fname = __FILE__, .line = __LINE__, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);

    ;

    check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
}

void macro_foreach_vertex_stencil (char flags, Reduce reductions) {  
#line 314
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/grid/stencils.h", .line = 335, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
    ;
  }    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }







}

void macro_foreach_face_stencil (char flags, Reduce reductions, const char * order) {  
#line 314
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/grid/stencils.h", .line = 342, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 343
;    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 344
}

void macro_foreach_level_stencil (int l, char flags, Reduce reductions) {
  if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    ;
  }
}

void macro_foreach_coarse_level_stencil (int l, char flags, Reduce reductions) {  
#line 347
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    





;  
#line 352
}





}

void macro_foreach_level_or_leaf_stencil (int l, char flags, Reduce reductions) {  
#line 347
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 362
;  
#line 352
}










}

void macro_foreach_point_stencil (double xp, double yp, double zp, char flags, Reduce reductions)
{  
#line 314
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/grid/stencils.h", .line = 367, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 368
;    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 369
}

void macro_foreach_region_stencil (coord p, coord box[2], coord n, char flags, Reduce reductions)
{  
#line 314
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/grid/stencils.h", .line = 373, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 374
;    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 375
}

void macro__stencil_is_face_x (ForeachData l) { l.face |= (1 << 0); ; }
void macro__stencil_is_face_y (ForeachData l) { l.face |= (1 << 1); ; }
void macro__stencil_is_face_z (ForeachData l) { l.face |= (1 << 2); ; }

void stencil_val (Point p, scalar s, int i, int j, int k,
    const char * file, int line, bool overflow);
void stencil_val_a (Point p, scalar s, int i, int j, int k, bool input,
      const char * file, int line);

#define _stencil_val(a,_i,_j,_k)\
  stencil_val (point, a, _i, _j, _k, __FILE__, __LINE__, false)\

#line 508

#define _stencil_val_o(a,_i,_j,_k)\
  stencil_val (point, a, _i, _j, _k, __FILE__, __LINE__, true)\

#line 511

#define _stencil_val_a(a,_i,_j,_k)\
  stencil_val_a (point, a, _i, _j, _k, false, __FILE__, __LINE__)\

#line 514

#define _stencil_val_r(a,_i,_j,_k)\
  stencil_val_a (point, a, _i, _j, _k, true, __FILE__, __LINE__)\

#line 517


#define _stencil_fine(a,_i,_j,_k) _stencil_val(a,_i,_j,_k)
#define _stencil_fine(a,_i,_j,_k) _stencil_val(a,_i,_j,_k)
#define _stencil_fine_a(a,_i,_j,_k) _stencil_val_a(a,_i,_j,_k)
#define _stencil_fine_r(a,_i,_j,_k) _stencil_val_r(a,_i,_j,_k)

#define _stencil_coarse(a,_i,_j,_k) _stencil_val(a,_i,_j,_k)
#define _stencil_coarse_a(a,_i,_j,_k) _stencil_val_a(a,_i,_j,_k)
#define _stencil_coarse_r(a,_i,_j,_k) _stencil_val_r(a,_i,_j,_k)

#define r_assign(x)
#define _assign(x)

#define _stencil_neighbor(i,j,k)
#define _stencil_child(i,j,k)
#define _stencil_aparent(i,j,k)
#define _stencil_aparent_a(i,j,k)
#define _stencil_aparent_r(i,j,k)

#define _stencil_allocated(i,j,k) true

#define _stencil_neighborp(i,j,k) neighborp(i,j,k)

int _stencil_nop;
#define _stencil_val_higher_dimension (_stencil_nop = 1)
#define _stencil__val_constant(a,_i,_j,_k) (_stencil_nop = 1)
#define _stencil_val_diagonal(a,_i,_j,_k) (_stencil_nop = 1)

typedef void _stencil_undefined;

#define o_stencil -3
#line 10 "/home/spencer/basilisk/src/grid/cartesian-common.h"

void macro_foreach_point (double _x, double _y, double _z,
        char flags, Reduce reductions)
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    coord _p = { _x, _y, _z };
    Point point = locate (_p.x, _p.y, _p.z);
    if (point.level >= 0)
      ;
  }
}

void macro_foreach_region (coord p, coord box[2], coord n,
         char flags, Reduce reductions)
{
  {
    if (n.x < 1) n.x = 1;
    if (n.y < 1) n.y = 1;
    if (n.z < 1) n.z = 1;

    for (int _i = 0; _i < (int) n.x; _i++) {
      p.x = box[0].x + (box[1].x - box[0].x)/n.x*(_i + 0.5);
      for (int _j = 0; _j < (int) n.y; _j++) {
 p.y = box[0].y + (box[1].y - box[0].y)/n.y*(_j + 0.5);
 for (int _k = 0; _k < (int) n.z; _k++) {
   p.z = box[0].z + (box[1].z - box[0].z)/n.z*(_k + 0.5);
   Point point = locate (p.x, p.y, p.z);
   if (point.level >= 0) {
     int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
     ;
   }
 }
      }
    }
  }
}




static inline
double dirichlet (double expr, Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 54 "/home/spencer/basilisk/src/grid/cartesian-common.h"
return 2.*expr - val(s,0,0,0);
}

static inline
double dirichlet_homogeneous (double expr, Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 60 "/home/spencer/basilisk/src/grid/cartesian-common.h"
return - val(s,0,0,0);
}

static inline
double dirichlet_face (double expr)
{
  return expr;
}

static inline
double dirichlet_face_homogeneous (double expr)
{
  return 0.;
}

static inline
double neumann (double expr, Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 78 "/home/spencer/basilisk/src/grid/cartesian-common.h"
return Delta*expr + val(s,0,0,0);
}

static inline
double neumann_homogeneous (double expr, Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 84 "/home/spencer/basilisk/src/grid/cartesian-common.h"
return val(s,0,0,0);
}
#line 145 "/home/spencer/basilisk/src/grid/cartesian-common.h"
static void init_block_scalar (scalar sb, const char * name, const char * ext,
          int n, int block)
{
  char bname[strlen(name) + strlen(ext) + 10];
  if (n == 0) {
    strcat (strcpy (bname, name), ext);
    _attribute[sb.i].block = block;
    baseblock = list_append (baseblock, sb);
  }
  else {
    sprintf (bname, "%s%d%s", name, n, ext);
    _attribute[sb.i].block = - n;
  }
  _attribute[sb.i].name = pstrdup (bname,__func__,__FILE__,__LINE__);
  all = list_append (all, sb);
}

#define interpreter_set_int(...)
#define interpreter_reset_scalar(...)

scalar alloc_block_scalar (const char * name, const char * ext, int block)
{
  interpreter_set_int (&block);
  int nvar = datasize/sizeof(real);

  scalar s = {0};
  while (s.i < nvar) {
    int n = 0;
    scalar sb = s;
    while (sb.i < nvar && n < block && _attribute[sb.i].freed)
      n++, sb.i++;
    if (n >= block) {
      memset (&_attribute[s.i], 0, block*sizeof (_Attributes));
      for (sb.i = s.i, n = 0; n < block; n++, sb.i++) {
 init_block_scalar (sb, name, ext, n, block);
 interpreter_reset_scalar (sb);
      }
      trash (((scalar []){s, {-1}}));
      return s;
    }
    s.i = sb.i + 1;
  }


  s = (scalar){nvar};
  if (!(nvar + block <= _NVARMAX)) qassert ("/home/spencer/basilisk/src/grid/cartesian-common.h", 190, "nvar + block <= _NVARMAX");

  if (_attribute == NULL)
    _attribute = (_Attributes *) pcalloc (nvar + block + 1, sizeof (_Attributes),__func__,__FILE__,__LINE__);
  else
    _attribute = (_Attributes *)
      prealloc (_attribute, (nvar + block + 1)*sizeof (_Attributes),__func__,__FILE__,__LINE__);
  memset (&_attribute[nvar], 0, block*sizeof (_Attributes));
  for (int n = 0; n < block; n++, nvar++) {
    scalar sb = (scalar){nvar};
    init_block_scalar (sb, name, ext, n, block);
  }

  realloc_scalar (block*sizeof(real));
  trash (((scalar []){s, {-1}}));
  return s;
}

scalar new_block_scalar (const char * name, const char * ext, int block)
{
  scalar s = alloc_block_scalar (name, ext, block), sb;
  int n = 0;
  for (sb.i = s.i, n = 0; n < block; n++, sb.i++)
    init_scalar (sb, NULL);
  return s;
}

scalar new_scalar (const char * name)
{
  return init_scalar (alloc_block_scalar (name, "", 1), NULL);
}

scalar new_vertex_scalar (const char * name)
{
  return init_vertex_scalar (alloc_block_scalar (name, "", 1), NULL);
}

static vector alloc_block_vector (const char * name, int block)
{
  vector v;
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  
    v.x = alloc_block_scalar (name, ext.x, block);    v.y = alloc_block_scalar (name, ext.y, block);
  return v;
}

vector new_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_vector (v, NULL);
  return v;
}

vector new_face_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_face_vector (v, NULL);
  return v;
}

vector new_block_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;
    
      vb.x.i = v.x.i + i;      vb.y.i = v.y.i + i;
    init_vector (vb, NULL);
    
      _attribute[vb.x.i].block = - i;      _attribute[vb.y.i].block = - i;
  }
  
    _attribute[v.x.i].block = block;    _attribute[v.y.i].block = block;
  return v;
}

vector new_block_face_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;
    
      vb.x.i = v.x.i + i;      vb.y.i = v.y.i + i;
    init_face_vector (vb, NULL);
    
      _attribute[vb.x.i].block = - i;      _attribute[vb.y.i].block = - i;
  }
  
    _attribute[v.x.i].block = block;    _attribute[v.y.i].block = block;
  return v;
}

tensor new_tensor (const char * name)
{
  char cname[strlen(name) + 3];
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  tensor t;
   {
    strcat (strcpy (cname, name), ext.x);
    t.x = alloc_block_vector (cname, 1);
  } 
#line 287
{
    strcat (strcpy (cname, name), ext.y);
    t.y = alloc_block_vector (cname, 1);
  }
  init_tensor (t, NULL);
  return t;
}

tensor new_symmetric_tensor (const char * name)
{
  struct { char * x, * y, * z; } ext = {".x.x", ".y.y", ".z.z"};
  tensor t;
  
    t.x.x = alloc_block_scalar (name, ext.x, 1);    t.y.y = alloc_block_scalar (name, ext.y, 1);

    t.x.y = alloc_block_scalar (name, ".x.y", 1);
    t.y.x = t.x.y;
#line 314 "/home/spencer/basilisk/src/grid/cartesian-common.h"
  init_tensor (t, NULL);
  return t;
}

static int nconst = 0;

void init_const_scalar (scalar s, const char * name, double val)
{
  if (s.i - _NVARMAX >= nconst) {
    _constant = (double *) prealloc (_constant, (s.i - _NVARMAX + 1)*sizeof(double),__func__,__FILE__,__LINE__);
    for (int i = nconst; i < s.i - _NVARMAX; i++)
      _constant[i] = 0.;
    nconst = s.i - _NVARMAX + 1;
  }
  _constant[s.i - _NVARMAX] = val;
}

scalar new_const_scalar (const char * name, int i, double val)
{
  scalar s = (scalar){i + _NVARMAX};
  init_const_scalar (s, name, val);
  return s;
}

void init_const_vector (vector v, const char * name, double * val)
{
  
    init_const_scalar (v.x, name, *val++);    init_const_scalar (v.y, name, *val++);
}

vector new_const_vector (const char * name, int i, double * val)
{
  vector v;
  
    v.x.i = _NVARMAX + i++;    v.y.i = _NVARMAX + i++;
  init_const_vector (v, name, val);
  return v;
}

static void cartesian_scalar_clone (scalar clone, scalar src)
{
  char * cname = _attribute[clone.i].name;
  BoundaryFunc * boundary = _attribute[clone.i].boundary;
  BoundaryFunc * boundary_homogeneous = _attribute[clone.i].boundary_homogeneous;
  if (!(_attribute[src.i].block > 0 && _attribute[clone.i].block == _attribute[src.i].block)) qassert ("/home/spencer/basilisk/src/grid/cartesian-common.h", 358, "src.block > 0 && clone.block == src.block");
  pfree (_attribute[clone.i].depends,__func__,__FILE__,__LINE__);
  _attribute[clone.i] = _attribute[src.i];
  _attribute[clone.i].name = cname;
  _attribute[clone.i].boundary = boundary;
  _attribute[clone.i].boundary_homogeneous = boundary_homogeneous;
  for (int i = 0; i < nboundary; i++) {
    _attribute[clone.i].boundary[i] = _attribute[src.i].boundary[i];
    _attribute[clone.i].boundary_homogeneous[i] = _attribute[src.i].boundary_homogeneous[i];
  }
  _attribute[clone.i].depends = list_copy (_attribute[src.i].depends);
}

scalar * list_clone (scalar * l)
{
  scalar * list = NULL;
  int nvar = datasize/sizeof(real), map[nvar];
  for (int i = 0; i < nvar; i++)
    map[i] = -1;
  {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    scalar c = _attribute[s.i].block > 1 ? new_block_scalar("c", "", _attribute[s.i].block) : new_scalar("c");
    scalar_clone (c, s);
    map[s.i] = c.i;
    list = list_append (list, c);
  }}}
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    {
      if (_attribute[s.i].v.x.i >= 0 && map[_attribute[s.i].v.x.i] >= 0)
 _attribute[s.i].v.x.i = map[_attribute[s.i].v.x.i];      
#line 385
if (_attribute[s.i].v.y.i >= 0 && map[_attribute[s.i].v.y.i] >= 0)
 _attribute[s.i].v.y.i = map[_attribute[s.i].v.y.i];}}}
  return list;
}

void delete (scalar * list)
{
  if (all == NULL)
    return;

  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    for (int i = 0; i < _attribute[f.i].block; i++) {
      scalar fb = {f.i + i};
      if (_attribute[f.i].delete)
 _attribute[f.i].delete (fb);
      pfree (_attribute[fb.i].name,__func__,__FILE__,__LINE__); _attribute[fb.i].name = NULL;
      pfree (_attribute[fb.i].boundary,__func__,__FILE__,__LINE__); _attribute[fb.i].boundary = NULL;
      pfree (_attribute[fb.i].boundary_homogeneous,__func__,__FILE__,__LINE__); _attribute[fb.i].boundary_homogeneous = NULL;
      pfree (_attribute[fb.i].depends,__func__,__FILE__,__LINE__); _attribute[fb.i].depends = NULL;
      _attribute[fb.i].freed = true;
    }
  }}}

  if (list == all) {
    all[0].i = -1;
    baseblock[0].i = -1;
    return;
  }

  trash (list);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    if (_attribute[f.i].block > 0) {
      scalar * s;
      for (s = all; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[_attribute[f.i].block].i >= 0; s++)
   s[0] = s[_attribute[f.i].block];
 s->i = -1;
      }
      for (s = baseblock; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[1].i >= 0; s++)
   s[0] = s[1];
 s->i = -1;
      }
    }
  }}}
}

void free_solver()
{
  if (!(_val_higher_dimension == 0.)) qassert ("/home/spencer/basilisk/src/grid/cartesian-common.h", 436, "_val_higher_dimension == 0.");

  if (free_solver_funcs) {
    free_solver_func * a = (free_solver_func *) free_solver_funcs->p;
    for (int i = 0; i < free_solver_funcs->len/sizeof(free_solver_func); i++)
      a[i] ();
    array_free (free_solver_funcs);
  }

  delete (all);
  pfree (all,__func__,__FILE__,__LINE__); all = NULL;
  pfree (baseblock,__func__,__FILE__,__LINE__); baseblock = NULL;
  for (Event * ev = Events; !ev->last; ev++) {
    Event * e = ev->next;
    while (e) {
      Event * next = e->next;
      pfree (e,__func__,__FILE__,__LINE__);
      e = next;
    }
  }

  pfree (Events,__func__,__FILE__,__LINE__); Events = NULL;
  pfree (_attribute,__func__,__FILE__,__LINE__); _attribute = NULL;
  pfree (_constant,__func__,__FILE__,__LINE__); _constant = NULL;




  free_grid();
  qpclose_all();
#if TRACE
  trace_off();
#endif
#if MTRACE
  pmuntrace();
#endif
#if _CADNA
  cadna_end();
#endif
}



void (* boundary_level) (scalar *, int l);
void (* boundary_face) (vectorl);




void boundary_flux (vector * list) __attribute__ ((deprecated));

void boundary_flux (vector * list)
{
  vectorl list1 = {NULL};
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
    {
      list1.x = list_append (list1.x, v.x);      list1.y = list_append (list1.y, v.y);}}}
  boundary_face (list1);
  
    pfree (list1.x,__func__,__FILE__,__LINE__);    pfree (list1.y,__func__,__FILE__,__LINE__);
}

static scalar * list_add_depends (scalar * list, scalar s)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  scalar * list1 = list;
  {scalar*_i=(scalar*)( _attribute[s.i].depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    if (_attribute[d.i].dirty)
      list1 = list_add_depends (list1, d);}}
  return list_append (list1, s);
}

     
void boundary_internal (scalar * list, const char * fname, int line)
{tracing("boundary_internal","/home/spencer/basilisk/src/grid/cartesian-common.h",511);
  if (list == NULL)
    {end_tracing("boundary_internal","/home/spencer/basilisk/src/grid/cartesian-common.h",514);return;}
  scalar * listc = NULL;
  vectorl listf = {NULL};
  bool flux = false;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].block > 0) {
      if (scalar_is_dirty (s)) {
 if (_attribute[s.i].face && _attribute[s.i].dirty != 2)
   {
     if (_attribute[s.i].v.x.i == s.i)
       listf.x = list_add (listf.x, s), flux = true;     
#line 523
if (_attribute[s.i].v.y.i == s.i)
       listf.y = list_add (listf.y, s), flux = true;}
 if (!is_constant(cm) && _attribute[cm.i].dirty)
   listc = list_add_depends (listc, cm);
 if (_attribute[s.i].face != 2)
   listc = list_add_depends (listc, s);
      }




    }}}
  if (flux) {
    boundary_face (listf);
    
      pfree (listf.x,__func__,__FILE__,__LINE__);      pfree (listf.y,__func__,__FILE__,__LINE__);
  }
  if (listc) {






    boundary_level (listc, -1);
    {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = false;}}
    pfree (listc,__func__,__FILE__,__LINE__);
  }
end_tracing("boundary_internal","/home/spencer/basilisk/src/grid/cartesian-common.h",552);}

void cartesian_boundary_level (scalar * list, int l)
{
  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, l); };
}

void cartesian_boundary_face (vectorl list)
{
  
    {scalar*_i=(scalar*)( list.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}    
#line 562
{scalar*_i=(scalar*)( list.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}
}

static double symmetry (Point point, Point neighbor, scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 568 "/home/spencer/basilisk/src/grid/cartesian-common.h"
return val(s,0,0,0);
}

static double antisymmetry (Point point, Point neighbor, scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 573 "/home/spencer/basilisk/src/grid/cartesian-common.h"
return -val(s,0,0,0);
}

BoundaryFunc default_scalar_bc[] = {
  symmetry, symmetry, symmetry, symmetry, symmetry, symmetry
};

scalar cartesian_init_scalar (scalar s, const char * name)
{

  char * pname;
  if (name) {
    pfree (_attribute[s.i].name,__func__,__FILE__,__LINE__);
    pname = pstrdup (name,__func__,__FILE__,__LINE__);
  }
  else
    pname = _attribute[s.i].name;
  int block = _attribute[s.i].block;
  BoundaryFunc * boundary = _attribute[s.i].boundary;
  BoundaryFunc * boundary_homogeneous = _attribute[s.i].boundary_homogeneous;
  _attribute[s.i].name = pname;
  if (block < 0)
    _attribute[s.i].block = block;
  else
    _attribute[s.i].block = block > 0 ? block : 1;

  _attribute[s.i].boundary = boundary ? boundary : (BoundaryFunc *) pmalloc (nboundary*sizeof (BoundaryFunc),__func__,__FILE__,__LINE__);
  _attribute[s.i].boundary_homogeneous = boundary_homogeneous ? boundary_homogeneous :
    (BoundaryFunc *) pmalloc (nboundary*sizeof (BoundaryFunc),__func__,__FILE__,__LINE__);
  for (int b = 0; b < nboundary; b++)
    _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] =
      b < 2*2 ? default_scalar_bc[b] : symmetry;
  _attribute[s.i].gradient = NULL;
   {
    _attribute[s.i].d.x = 0;
    _attribute[s.i].v.x.i = -1;
  } 
#line 606
{
    _attribute[s.i].d.y = 0;
    _attribute[s.i].v.y.i = -1;
  }
  _attribute[s.i].face = false;
  return s;
}

scalar cartesian_init_vertex_scalar (scalar s, const char * name)
{
  cartesian_init_scalar (s, name);
  
    _attribute[s.i].d.x = -1;    _attribute[s.i].d.y = -1;
  for (int d = 0; d < nboundary; d++)
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = NULL;
  return s;
}

BoundaryFunc default_vector_bc[] = {
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry
};

vector cartesian_init_vector (vector v, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
   {
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.x);
      cartesian_init_scalar (v.x, cname);
    }
    else
      cartesian_init_scalar (v.x, NULL);
    _attribute[v.x.i].v = v;
  } 
#line 633
{
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.y);
      cartesian_init_scalar (v.y, cname);
    }
    else
      cartesian_init_scalar (v.y, NULL);
    _attribute[v.y.i].v = v;
  }

  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] =
      d < 2*2 ? default_vector_bc[d] : antisymmetry;
  return v;
}

vector cartesian_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_vector (v, name);
   {
    _attribute[v.x.i].d.x = -1;
    _attribute[v.x.i].face = true;
  } 
#line 653
{
    _attribute[v.y.i].d.y = -1;
    _attribute[v.y.i].face = true;
  }
  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = NULL;
  return v;
}

tensor cartesian_init_tensor (tensor t, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
   {
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.x);
      cartesian_init_vector (t.x, cname);
    }
    else
      cartesian_init_vector (t.x, NULL);
  } 
#line 665
{
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.y);
      cartesian_init_vector (t.y, cname);
    }
    else
      cartesian_init_vector (t.y, NULL);
  }






    for (int b = 0; b < nboundary; b++) {
      _attribute[t.x.x.i].boundary[b] = _attribute[t.y.x.i].boundary[b] =
 _attribute[t.x.x.i].boundary_homogeneous[b] = _attribute[t.y.y.i].boundary_homogeneous[b] =
 b < 2*2 ? default_scalar_bc[b] : symmetry;
      _attribute[t.x.y.i].boundary[b] = _attribute[t.y.y.i].boundary[b] =
 _attribute[t.x.y.i].boundary_homogeneous[b] = _attribute[t.y.x.i].boundary_homogeneous[b] =
 b < 2*2 ? default_vector_bc[b] : antisymmetry;
    }



  return t;
}

void output_cells (FILE * fp, coord c, double size)
{ 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 696 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 696 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{
    bool inside = true;
    coord o = {x,y,z};
    
      if (inside && size > 0. &&
   (o.x > c.x + size || o.x < c.x - size))
 inside = false;      
#line 700
if (inside && size > 0. &&
   (o.y > c.y + size || o.y < c.y - size))
 inside = false;
    if (inside) {
      Delta /= 2.;



      fprintf (fp, "%g %g\n%g %g\n%g %g\n%g %g\n%g %g\n\n",
        x - Delta, y - Delta,
        x - Delta, y + Delta,
        x + Delta, y + Delta,
        x + Delta, y - Delta,
        x - Delta, y - Delta);
#line 728 "/home/spencer/basilisk/src/grid/cartesian-common.h"
    }
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
  
#line 730 "/home/spencer/basilisk/src/grid/cartesian-common.h"
fflush (fp);
}
#line 740 "/home/spencer/basilisk/src/grid/cartesian-common.h"
static char * replace_ (const char * vname)
{
  char * name = pstrdup (vname,__func__,__FILE__,__LINE__), * c = name;
  while (*c != '\0') {
    if (*c == '.')
      *c = '_';
    c++;
  }
  return name;
}

static void debug_plot (FILE * fp, const char * name, const char * cells,
   const char * stencil)
{
  char * vname = replace_ (name);
  fprintf (fp,
    "  load 'debug.plot'\n"
    "  v=%s\n"




    "  plot '%s' w l lc 0, "
    "'%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 1 title columnhead(3+3*v)",





    vname, cells, stencil);
  pfree (vname,__func__,__FILE__,__LINE__);
}

void cartesian_debug (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 775 "/home/spencer/basilisk/src/grid/cartesian-common.h"
char name[80] = "cells";
  if (pid() > 0)
    sprintf (name, "cells-%d", pid());
  FILE * fp = fopen (name, "w");
  output_cells (fp, (coord){x,y,z}, 4.*Delta);
  fclose (fp);

  char stencil[80] = "stencil";
  if (pid() > 0)
    sprintf (stencil, "stencil-%d", pid());
  fp = fopen (stencil, "w");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){



    fprintf (fp, "x y %s ", _attribute[v.i].name);}}



  fputc ('\n', fp);
#line 807 "/home/spencer/basilisk/src/grid/cartesian-common.h"
    for (int k = -2; k <= 2; k++)
      for (int l = -2; l <= 2; l++) {
 {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){ {
   fprintf (fp, "%g %g ",
     x + k*Delta + _attribute[v.i].d.x*Delta/2.,
     y + l*Delta + _attribute[v.i].d.y*Delta/2.);
   if (allocated(k,l,0))
     fprintf (fp, "%g ", val(v,k,l,0));
   else
     fputs ("n/a ", fp);
 }}}
 fputc ('\n', fp);
      }
#line 837 "/home/spencer/basilisk/src/grid/cartesian-common.h"
  fclose (fp);

  fp = fopen ("debug.plot", "w");
  fprintf (fp,
    "set term x11\n"
    "set size ratio -1\n"
    "set key outside\n");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    char * name = replace_ (_attribute[s.i].name);
    fprintf (fp, "%s = %d\n", name, s.i);
    pfree (name,__func__,__FILE__,__LINE__);
  }}}
  fclose (fp);

  fprintf (ferr, "Last point stencils can be displayed using (in gnuplot)\n");
  debug_plot (ferr, _attribute[0].name, name, stencil);
  fflush (ferr);

  fp = fopen ("plot", "w");
  debug_plot (fp, _attribute[0].name, name, stencil);
  fclose (fp);
}

void cartesian_methods()
{
  init_scalar = cartesian_init_scalar;
  init_vertex_scalar = cartesian_init_vertex_scalar;
  init_vector = cartesian_init_vector;
  init_face_vector = cartesian_init_face_vector;
  init_tensor = cartesian_init_tensor;
  boundary_level = cartesian_boundary_level;
  boundary_face = cartesian_boundary_face;
  scalar_clone = cartesian_scalar_clone;
  debug = cartesian_debug;
}

tensor init_symmetric_tensor (tensor t, const char * name)
{
  return init_tensor (t, name);
}

static double interpolate_linear (Point point, scalar v,
      double xp, double yp, double zp)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;







  
#line 888 "/home/spencer/basilisk/src/grid/cartesian-common.h"
x = (xp - x)/Delta - _attribute[v.i].d.x/2.;
  y = (yp - y)/Delta - _attribute[v.i].d.y/2.;
  int i = ( (int)(x > 0 ? 1 : -1)), j = ( (int)(y > 0 ? 1 : -1));
  x = fabs(x); y = fabs(y);

  return ((val(v,0,0,0)*(1. - x) + val(v,i,0,0)*x)*(1. - y) +
   (val(v,0,j,0)*(1. - x) + val(v,i,j,0)*x)*y);
#line 907 "/home/spencer/basilisk/src/grid/cartesian-common.h"
}
#line 878
static void _stencil_interpolate_linear (Point point, scalar v,
_stencil_undefined * xp,_stencil_undefined * yp,_stencil_undefined * zp)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;                    







        
        
  
       
#line 893 "/home/spencer/basilisk/src/grid/cartesian-common.h"
_stencil_val(v,0,0,0);_stencil_val(v, o_stencil,0,0);
_stencil_val(v,0,o_stencil,0); _stencil_val(v,o_stencil,o_stencil,0);  
#line 893
return         
    ;
#line 907 "/home/spencer/basilisk/src/grid/cartesian-common.h"
}

     
double interpolate (scalar v, double xp, double yp, double zp,
      bool linear)
{tracing("interpolate","/home/spencer/basilisk/src/grid/cartesian-common.h",910);
  double val = 1e30f;  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/grid/cartesian-common.h", .line = 914, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 915 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{ _stencil_interpolate_linear (point, v, NULL, NULL, NULL); _stencil_val(v,0,0,0);    }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 13 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    coord _p = { xp, yp, zp };
    Point point = locate (_p.x, _p.y, _p.z);
    if (point.level >= 0)
    
#line 915
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 915 "/home/spencer/basilisk/src/grid/cartesian-common.h"
val = linear ? interpolate_linear (point, v, xp, yp, zp) : val(v,0,0,0);}  
#line 20
}
}
#line 915
{mpi_all_reduce_array(&val,MPI_DOUBLE,MPI_MIN,1);}
  {end_tracing("interpolate","/home/spencer/basilisk/src/grid/cartesian-common.h",916);return val;}
end_tracing("interpolate","/home/spencer/basilisk/src/grid/cartesian-common.h",917);}

     
void interpolate_array (scalar * list, coord * a, int n, double * v,
   bool linear)
{tracing("interpolate_array","/home/spencer/basilisk/src/grid/cartesian-common.h",920);
  int len = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    len++;}}
  for (int i = 0; i < n; i++) {
    double * w = v;
#line 937 "/home/spencer/basilisk/src/grid/cartesian-common.h"
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      *(w++) = 1e30f;}}    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/grid/cartesian-common.h", .line = 939, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 939 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{   
      
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 { _stencil_val(s,0,0,0); _stencil_interpolate_linear (point, s, NULL, NULL, NULL);    }}}
    }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 13 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    coord _p = { (
#line 939
a[i].x
#line 16
), (
#line 939
a[i].y
#line 16
), (
#line 939
a[i].z
#line 16
) };
    Point point = locate (_p.x, _p.y, _p.z);
    if (point.level >= 0) 
#line 939
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 939 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{
      int j = 0;
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 v[j++] = !linear ? val(s,0,0,0) : interpolate_linear (point, s, a[i].x, a[i].y, a[i].z);}}
    }}  
#line 20
}
}
#line 943
{mpi_all_reduce_array(v,MPI_DOUBLE,MPI_MIN,len);}

    v = w;
  }
end_tracing("interpolate_array","/home/spencer/basilisk/src/grid/cartesian-common.h",947);}



typedef int bid;

bid new_bid()
{
  int b = nboundary++;
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].boundary = (BoundaryFunc *) prealloc (_attribute[s.i].boundary, nboundary*sizeof (BoundaryFunc),__func__,__FILE__,__LINE__);
    _attribute[s.i].boundary_homogeneous = (BoundaryFunc *)
      prealloc (_attribute[s.i].boundary_homogeneous, nboundary*sizeof (BoundaryFunc),__func__,__FILE__,__LINE__);
  }}}
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    if (_attribute[s.i].v.x.i < 0)
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] = symmetry;
    else if (_attribute[s.i].v.x.i == s.i) {
      vector v = _attribute[s.i].v;
      
 _attribute[v.y.i].boundary[b] = _attribute[v.y.i].boundary_homogeneous[b] = symmetry; _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] = symmetry;
      _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] =
 _attribute[v.x.i].face ? NULL : antisymmetry;
    }
  }}}
  return b;
}



static double periodic_bc (Point point, Point neighbor, scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 979 "/home/spencer/basilisk/src/grid/cartesian-common.h"
return val(s,0,0,0);
}

static void periodic_boundary (int d)
{

  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (is_vertex_scalar (s))
      _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = NULL;
    else
      _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = periodic_bc;}}

  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (_attribute[s.i].face) {
      vector v = _attribute[s.i].v;
      _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = NULL;
    }}}

  default_scalar_bc[d] = periodic_bc;
  default_vector_bc[d] = periodic_bc;
}

void periodic (int dir)
{



    if (!(dir <= bottom)) qassert ("/home/spencer/basilisk/src/grid/cartesian-common.h", 1006, "dir <= bottom");




  int c = dir/2;
  periodic_boundary (2*c);
  periodic_boundary (2*c + 1);
  (&Period.x)[c] = true;
}


double getvalue (Point point, scalar s, int i, int j, int k)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 1020 "/home/spencer/basilisk/src/grid/cartesian-common.h"
return val(s,i,j,k);
}

void default_stencil (Point p, scalar * list)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    if (_attribute[s.i].v.x.i != -1) {
      vector v = _attribute[s.i].v;
      {scalar*_i=(scalar*)(((vector[]) {v,{{-1},{-1}}}));if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){
 _attribute[c.i].input = _attribute[c.i].output = _attribute[c.i].nowarning = true, _attribute[c.i].width = 2;}}
    }
    else
      _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = true, _attribute[s.i].width = 2;
  }}}
}




static void write_stencil_index (int * index)
{
  fprintf (qstderr(), "[%d", index[0]);
  for (int d = 1; d < 2; d++)
    fprintf (qstderr(), ",%d", index[d]);
  fputs ("]", qstderr());
}

void stencil_val (Point p, scalar s, int i, int j, int k,
    const char * file, int line, bool overflow)
{
  if (is_constant(s) || s.i < 0)
    return;
  if (_attribute[s.i].block < 0)
    s.i += _attribute[s.i].block;
  if (!_attribute[s.i].name) {
    fprintf (ferr, "%s:%d: error: trying to access a deleted field\n",
      file, line);
    exit (1);
  }
  int index[] = {i, j, k};
  for (int d = 0; d < 2; d++) {
    if (index[d] == o_stencil)
      index[d] = 2;
    else
      index[d] += (&p.i)[d];
  }
  bool central = true;
  for (int d = 0; d < 2; d++) {
    if (!overflow && (index[d] > 2 || index[d] < - 2)) {
      fprintf (qstderr(), "%s:%d: error: stencil overflow: %s",
        file, line, _attribute[s.i].name);
      write_stencil_index (index);
      fprintf (qstderr(), "\n");
      fflush (qstderr());
      abort();
    }
    if (index[d] != 0)
      central = false;
  }
  if (central) {
    if (!_attribute[s.i].output)
      _attribute[s.i].input = true;
  }
  else {
    _attribute[s.i].input = true;
    int d = 0;
     {
      if ((!_attribute[s.i].face || _attribute[s.i].v.x.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    } 
#line 1086
{
      if ((!_attribute[s.i].face || _attribute[s.i].v.y.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    }
  }
}

void stencil_val_a (Point p, scalar s, int i, int j, int k, bool input,
      const char * file, int line)
{
  if (is_constant(s) || s.i < 0) {
    fprintf (ferr, "%s:%d: error: trying to modify a%s field\n",
      file, line, s.i < 0 ? "n undefined" : " constant");
    exit (1);
  }
  if (_attribute[s.i].block < 0)
    s.i += _attribute[s.i].block;
  if (!_attribute[s.i].name) {
    fprintf (ferr, "%s:%d: error: trying to access a deleted field\n",
      file, line);
    exit (1);
  }
  int index[] = {i, j, k};
  for (int d = 0; d < 2; d++)
    index[d] += (&p.i)[d];
  for (int d = 0; d < 2; d++)
    if (index[d] != 0) {
      fprintf (qstderr(), "%s:%d: error: illegal write: %s",
        file, line, _attribute[s.i].name);
      write_stencil_index (index);
      fprintf (qstderr(), "\n");
      fflush (qstderr());
      abort();
    }
  if (input && !_attribute[s.i].output)
    _attribute[s.i].input = true;
  _attribute[s.i].output = true;
} 
#line 5 "/home/spencer/basilisk/src/grid/multigrid-common.h"

void macro2_foreach_level_or_leaf (int l, char flags, Reduce reductions)
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;    
#line 9 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 9 "/home/spencer/basilisk/src/grid/multigrid-common.h"
;}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 10 "/home/spencer/basilisk/src/grid/multigrid-common.h"
} 

void macro2_foreach_coarse_level (int l, char flags, Reduce reductions)
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;    
#line 15 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 15 "/home/spencer/basilisk/src/grid/multigrid-common.h"
;}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 16 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}










void (* restriction) (scalar *);

static inline void restriction_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 31 "/home/spencer/basilisk/src/grid/multigrid-common.h"
double sum = 0.;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 33 "/home/spencer/basilisk/src/grid/multigrid-common.h"
sum += val(s,0,0,0);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 34 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = sum/(1 << 2);
}
#line 29
static void _stencil_restriction_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 33 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(s,0,0,0); }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 34 "/home/spencer/basilisk/src/grid/multigrid-common.h"
_stencil_val_a(s,0,0,0);    
}

static inline void restriction_volume_average (Point point, scalar s)
{if(!is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 39 "/home/spencer/basilisk/src/grid/multigrid-common.h"
double sum = 0.;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 41 "/home/spencer/basilisk/src/grid/multigrid-common.h"
sum += val(cm,0,0,0)*val(s,0,0,0);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 42 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = sum/(1 << 2)/(val(cm,0,0,0) + 1e-30);
}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
#line 38
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 39 "/home/spencer/basilisk/src/grid/multigrid-common.h"
double sum = 0.;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 41 "/home/spencer/basilisk/src/grid/multigrid-common.h"
sum += _const_cm*val(s,0,0,0);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 42 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = sum/(1 << 2)/(_const_cm + 1e-30);
}}}

static inline void face_average (Point point, vector v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 47 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{




      val(v.x,0,0,0) = (fine(v.x,0,0,0) + fine(v.x,0,1,0))/2.;
      val(v.x,1,0,0) = (fine(v.x,2,0,0) + fine(v.x,2,1,0))/2.;






  } 
#line 47
{




      val(v.y,0,0,0) = (fine(v.y,0,0,0) + fine(v.y,1,0,0))/2.;
      val(v.y,0,1,0) = (fine(v.y,0,2,0) + fine(v.y,1,2,0))/2.;






  }
}

static inline void restriction_face (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 65 "/home/spencer/basilisk/src/grid/multigrid-common.h"
face_average (point, _attribute[s.i].v);
}

static inline void restriction_vertex (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 70 "/home/spencer/basilisk/src/grid/multigrid-common.h"
for (int i = 0; i <= 1; i++) {
    val(s,i,0,0) = fine(s,2*i,0,0);

    val(s,i,1,0) = fine(s,2*i,2,0);





  }
}

static inline void no_restriction (Point point, scalar s) {}

static inline void no_data (Point point, scalar s) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 86 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = 1e30f;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 87 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}

void wavelet (scalar s, scalar w)
{
  restriction (((scalar[]){s,{-1}}));
  for (int l = grid->maxdepth - 1; l >= 0; l--) {
  
  
    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 93 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
  
      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;        
#line 95 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(s,0,0,0);_stencil_val_a(w,0,0,0); }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 96 "/home/spencer/basilisk/src/grid/multigrid-common.h"
default_stencil (      point,((scalar[]){ s,{-1}}));
  
      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 97 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
         _stencil_val(s,0,0,0); 
_stencil_val(w,0,0,0);        _stencil_val_a(s,0,0,0); 

        _stencil_val_r(w,0,0,0);  
      }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }    
#line 103 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 740 "/home/spencer/basilisk/src/grid/tree.h"
{ 
#line 731
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
    
#line 742
if (!is_leaf(cell)) 
#line 93 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 93 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
  
      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;        
#line 95 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(w,0,0,0) = val(s,0,0,0);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }      
#line 96 "/home/spencer/basilisk/src/grid/multigrid-common.h"
_attribute[s.i].prolongation (point, s);
  
      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 97 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
        double sp = val(s,0,0,0);
        val(s,0,0,0) = val(w,0,0,0);

        val(w,0,0,0) -= sp;
      }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }    
#line 103 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}





}    
#line 104 "/home/spencer/basilisk/src/grid/multigrid-common.h"
boundary_level (((scalar[]){w,{-1}}), l + 1);
  }
  

  
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 108 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(s,0,0,0);_stencil_val_a(w,0,0,0); }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (0 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[0];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = 0;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;    
#line 108 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 108 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(w,0,0,0) = val(s,0,0,0);}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}  
#line 109 "/home/spencer/basilisk/src/grid/multigrid-common.h"
boundary_level (((scalar[]){w,{-1}}), 0);
}

void inverse_wavelet (scalar s, scalar w)
{
  
  
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 115 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(w,0,0,0);_stencil_val_a(s,0,0,0); }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (0 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[0];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = 0;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;    
#line 115 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 115 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = val(w,0,0,0);}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}  
#line 116 "/home/spencer/basilisk/src/grid/multigrid-common.h"
boundary_level (((scalar[]){s,{-1}}), 0);
  for (int l = 0; l <= grid->maxdepth - 1; l++) {
  
  
    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 118 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
default_stencil (      point,((scalar[]){ s,{-1}}));
  
      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;        
#line 121 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(w,0,0,0);_stencil_val_r(s,0,0,0); }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }    
#line 122 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 740 "/home/spencer/basilisk/src/grid/tree.h"
{ 
#line 731
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
    
#line 742
if (!is_leaf(cell)) 
#line 118 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 118 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
      _attribute[s.i].prolongation (point, s);
  
      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;        
#line 121 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) += val(w,0,0,0);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }    
#line 122 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}





}    
#line 123 "/home/spencer/basilisk/src/grid/multigrid-common.h"
boundary_level (((scalar[]){s,{-1}}), l + 1);
  }
}

static inline double bilinear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 132 "/home/spencer/basilisk/src/grid/multigrid-common.h"
return (9.*coarse(s,0,0,0) +
     3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
     coarse(s,child.x,child.y,0))/16.;
#line 143 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}
#line 127
static void _stencil_bilinear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 132 "/home/spencer/basilisk/src/grid/multigrid-common.h"
_stencil_coarse(s,0,0,0);
_stencil_coarse(s,o_stencil,0,0); _stencil_coarse(s,0,o_stencil,0);
     _stencil_coarse(s,o_stencil,o_stencil,0);    
#line 132
return 
        
;
#line 143 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_bilinear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 148 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = bilinear (point, s);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 149 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}

static inline double quadratic (double a, double b, double c)
{
  return (30.*a + 5.*b - 3.*c)/32.;
}

static inline double biquadratic (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 161 "/home/spencer/basilisk/src/grid/multigrid-common.h"
return
    quadratic (quadratic (coarse(s,0,0,0),
     coarse(s,child.x,0,0),
     coarse(s,-child.x,0,0)),
        quadratic (coarse(s,0,child.y,0),
     coarse(s,child.x,child.y,0),
     coarse(s,-child.x,child.y,0)),
        quadratic (coarse(s,0,-child.y,0),
     coarse(s,child.x,-child.y,0),
     coarse(s,-child.x,-child.y,0)));




}

static inline double biquadratic_vertex (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 182 "/home/spencer/basilisk/src/grid/multigrid-common.h"
return (36.*val(s,0,0,0) + 18.*(val(s,-1,0,0) + val(s,0,-1,0)) - 6.*(val(s,1,0,0) + val(s,0,1,0)) +
   9.*val(s,-1,-1,0) - 3.*(val(s,1,-1,0) + val(s,-1,1,0)) + val(s,1,1,0))/64.;




}

static inline void refine_biquadratic (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 193 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = biquadratic (point, s);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 194 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_linear (Point point, scalar s)
{if(!is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 198 "/home/spencer/basilisk/src/grid/multigrid-common.h"
coord g;
  if (_attribute[s.i].gradient)
    {
      g.x = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0));      g.y = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0));}
  else
    {
      g.x = (val(s,1,0,0) - val(s,-1,0,0))/2.;      g.y = (val(s,0,1,0) - val(s,0,-1,0))/2.;}

  double sc = val(s,0,0,0), cmc = 4.*val(cm,0,0,0), sum = val(cm,0,0,0)*(1 << 2);
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 207 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
    val(s,0,0,0) = sc;
    
      val(s,0,0,0) += child.x*g.x*val(cm,-child.x,0,0)/cmc;      val(s,0,0,0) += child.y*g.y*val(cm,0,-child.y,0)/cmc;
    sum -= val(cm,0,0,0);
  }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 213 "/home/spencer/basilisk/src/grid/multigrid-common.h"
if (!(fabs(sum) < 1e-10)) qassert ("/home/spencer/basilisk/src/grid/multigrid-common.h", 213, "fabs(sum) < 1e-10");
}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
#line 197
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 198 "/home/spencer/basilisk/src/grid/multigrid-common.h"
coord g;
  if (_attribute[s.i].gradient)
    {
      g.x = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0));      g.y = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0));}
  else
    {
      g.x = (val(s,1,0,0) - val(s,-1,0,0))/2.;      g.y = (val(s,0,1,0) - val(s,0,-1,0))/2.;}

  double sc = val(s,0,0,0), cmc = 4.*_const_cm, sum = _const_cm*(1 << 2);
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 207 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
    val(s,0,0,0) = sc;
    
      val(s,0,0,0) += child.x*g.x*_const_cm/cmc;      val(s,0,0,0) += child.y*g.y*_const_cm/cmc;
    sum -= _const_cm;
  }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 213 "/home/spencer/basilisk/src/grid/multigrid-common.h"
if (!(fabs(sum) < 1e-10)) qassert ("/home/spencer/basilisk/src/grid/multigrid-common.h", 213, "fabs(sum) < 1e-10");
}}}

static inline void refine_reset (Point point, scalar v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 219 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(v,0,0,0) = 0.;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 220 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_injection (Point point, scalar v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 224 "/home/spencer/basilisk/src/grid/multigrid-common.h"
double val = val(v,0,0,0);
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 226 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(v,0,0,0) = val;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 227 "/home/spencer/basilisk/src/grid/multigrid-common.h"
}

static scalar multigrid_init_scalar (scalar s, const char * name)
{
  s = cartesian_init_scalar (s, name);
  _attribute[s.i].prolongation = refine_bilinear;
  _attribute[s.i].restriction = restriction_average;
  return s;
}

static scalar multigrid_init_vertex_scalar (scalar s, const char * name)
{
  s = cartesian_init_vertex_scalar (s, name);
  _attribute[s.i].restriction = restriction_vertex;
  return s;
}

static void multigrid_setup_vector (vector v)
{
   {
    _attribute[v.x.i].prolongation = refine_bilinear;
    _attribute[v.x.i].restriction = restriction_average;
  } 
#line 246
{
    _attribute[v.y.i].prolongation = refine_bilinear;
    _attribute[v.y.i].restriction = restriction_average;
  }
}

static vector multigrid_init_vector (vector v, const char * name)
{
  v = cartesian_init_vector (v, name);
  multigrid_setup_vector (v);
  return v;
}

static vector multigrid_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  
    _attribute[v.y.i].restriction = no_restriction;    _attribute[v.x.i].restriction = no_restriction;
  _attribute[v.x.i].restriction = restriction_face;
  return v;
}

static tensor multigrid_init_tensor (tensor t, const char * name)
{
  t = cartesian_init_tensor (t, name);
  
    multigrid_setup_vector (t.x);    multigrid_setup_vector (t.y);
  return t;
}

void multigrid_debug (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 278 "/home/spencer/basilisk/src/grid/multigrid-common.h"
cartesian_debug (point);

  FILE * plot = fopen ("plot", "a");
  if (point.level > 0) {
    char name[80] = "coarse";
    if (pid() > 0)
      sprintf (name, "coarse-%d", pid());
    FILE * fp = fopen (name, "w");
#line 297 "/home/spencer/basilisk/src/grid/multigrid-common.h"
      double xc = x - child.x*Delta/2., yc = y - child.y*Delta/2.;
      for (int k = 0; k <= 1; k++)
 for (int l = 0; l <= 1; l++) {
   {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){
     fprintf (fp, "%g %g %g ",
       xc + k*child.x*Delta*2. + _attribute[v.i].d.x*Delta,
       yc + l*child.y*Delta*2. + _attribute[v.i].d.y*Delta,
       coarse(v,k*child.x,l*child.y,0));}}
   fputc ('\n', fp);
 }
      fprintf (ferr, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 3 t ''", name);
      fprintf (plot, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 3 t ''", name);
#line 328 "/home/spencer/basilisk/src/grid/multigrid-common.h"
    fclose (fp);
  }

  if (is_coarse()) {
    char name[80] = "fine";
    if (pid() > 0)
      sprintf (name, "fine-%d", pid());
    FILE * fp = fopen (name, "w");
#line 350 "/home/spencer/basilisk/src/grid/multigrid-common.h"
      double xf = x - Delta/4., yf = y - Delta/4.;
      for (int k = -2; k <= 3; k++)
 for (int l = -2; l <= 3; l++) {
   {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){ {
     fprintf (fp, "%g %g ",
       xf + k*Delta/2. + _attribute[v.i].d.x*Delta/4.,
       yf + l*Delta/2. + _attribute[v.i].d.y*Delta/4.);
     if (allocated_child(k,l,0))
       fprintf (fp, "%g ", fine(v,k,l,0));
     else
       fputs ("n/a ", fp);
   }}}
   fputc ('\n', fp);
 }
      fprintf (ferr, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 2 t ''", name);
      fprintf (plot, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 2 t ''", name);
#line 388 "/home/spencer/basilisk/src/grid/multigrid-common.h"
    fclose (fp);
  }
  fflush (ferr);
  fclose (plot);
}

static void multigrid_restriction (scalar * list)
{
  scalar * listdef = NULL, * listc = NULL, * list2 = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant (s) && _attribute[s.i].block > 0) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
     list2 = list_add (list2, _attribute[s.i].v.x);     list2 = list_add (list2, _attribute[s.i].v.y);}
 else
   list2 = list_add (list2, s);
      }
    }}}

  if (listdef || listc) {
    for (int l = depth() - 1; l >= 0; l--) {      
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 415 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     _stencil_restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {

default_stencil (     point,((scalar[]){ s,{-1}}));
 }}}
      }  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 740 "/home/spencer/basilisk/src/grid/tree.h"
{ 
#line 731
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
    
#line 742
if (!is_leaf(cell)) 
#line 415 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 415 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
  
     _attribute[s.i].restriction (point, s);
 }}}
      }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}





}      
#line 424 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list2, l); };
    }
    pfree (listdef,__func__,__FILE__,__LINE__);
    pfree (listc,__func__,__FILE__,__LINE__);
    pfree (list2,__func__,__FILE__,__LINE__);
  }
}

void multigrid_methods()
{
  cartesian_methods();
  init_scalar = multigrid_init_scalar;
  init_vertex_scalar = multigrid_init_vertex_scalar;
  init_vector = multigrid_init_vector;
  init_face_vector = multigrid_init_face_vector;
  init_tensor = multigrid_init_tensor;
  restriction = multigrid_restriction;
  debug = multigrid_debug;
}







void subtree_size (scalar size, bool leaves)
{  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/grid/multigrid-common.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 457 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{_stencil_val_a(size,0,0,0);  }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;
    
#line 457 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 457 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(size,0,0,0) = 1;}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 463 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b,((scalar[]) {size,{-1}}), depth()); };
  for (int l = depth() - 1; l >= 0; l--) {    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 465 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 468 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(size,0,0,0); }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
      
#line 469 "/home/spencer/basilisk/src/grid/multigrid-common.h"
_stencil_val_a(size,0,0,0);  
    }  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 740 "/home/spencer/basilisk/src/grid/tree.h"
{ 
#line 731
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
    
#line 742
if (!is_leaf(cell)) 
#line 465 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 465 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{
      double sum = !leaves;      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 468 "/home/spencer/basilisk/src/grid/multigrid-common.h"
sum += val(size,0,0,0);      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
      
#line 469 "/home/spencer/basilisk/src/grid/multigrid-common.h"
val(size,0,0,0) = sum;
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}





}    
#line 471 "/home/spencer/basilisk/src/grid/multigrid-common.h"
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b,((scalar[]) {size,{-1}}), l); };
  }
}
#line 5 "/home/spencer/basilisk/src/grid/tree-common.h"




#line 21 "/home/spencer/basilisk/src/grid/tree-common.h"
int refine_cell (Point point, scalar * list, int flag, Cache * refined)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 23 "/home/spencer/basilisk/src/grid/tree-common.h"
int nr = 0;


  if (level > 0)
    for (int k = 0; k != 2*child.x; k += child.x)

      for (int l = 0; l != 2*child.y; l += child.y)




   if (aparent(k,l,m).pid >= 0 && is_leaf(aparent(k,l,m))) {
     Point p = point;


     p.level = point.level - 1;
     p.i = (point.i + 2)/2 + k;
     do { if (p.i < 2) p.i += 1 << p.level; else if (p.i >= 2 + (1 << p.level)) p.i -= 1 << p.level; } while(0);

       p.j = (point.j + 2)/2 + l;
       do { if (p.j < 2) p.j += 1 << p.level; else if (p.j >= 2 + (1 << p.level)) p.j -= 1 << p.level; } while(0);





     nr += refine_cell (p, list, flag, refined);
     aparent(k,l,m).flags |= flag;
   }



  increment_neighbors (point);

  int cflag = is_active(cell) ? (active|leaf) : leaf;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 59 "/home/spencer/basilisk/src/grid/tree-common.h"
cell.flags |= cflag;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 62 "/home/spencer/basilisk/src/grid/tree-common.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (is_local(cell) || _attribute[s.i].face)
      _attribute[s.i].refine (point, s);}}


  cell.flags &= ~leaf;

#if _MPI
  if (is_border(cell)) {
  
    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 71 "/home/spencer/basilisk/src/grid/tree-common.h"
{
      bool bord = false;      
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 73 "/home/spencer/basilisk/src/grid/tree-common.h"
{
 if (!is_local(cell) || (level > 0 && !is_local(aparent(0,0,0)))) {
   bord = true;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 75 "/home/spencer/basilisk/src/grid/tree-common.h"
;
 }
 if (is_refined_check())
    
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;     
#line 79 "/home/spencer/basilisk/src/grid/tree-common.h"
if (!is_local(cell)) {
       bord = true;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 80 "/home/spencer/basilisk/src/grid/tree-common.h"
;
     }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
} 
#line 82 "/home/spencer/basilisk/src/grid/tree-common.h"
if (bord)   
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 83 "/home/spencer/basilisk/src/grid/tree-common.h"
;
      }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
      
#line 85 "/home/spencer/basilisk/src/grid/tree-common.h"
if (bord)
 cell.flags |= border;
    }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }    
#line 88 "/home/spencer/basilisk/src/grid/tree-common.h"
if (refined)
      cache_append (refined, point, cell.flags);
    nr++;
  }
#endif
  return nr;
}





bool coarsen_cell (Point point, scalar * list)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 105 "/home/spencer/basilisk/src/grid/tree-common.h"
int pid = cell.pid;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 107 "/home/spencer/basilisk/src/grid/tree-common.h"
if (cell.neighbors || (cell.pid < 0 && cell.pid != pid))
      return false;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 112 "/home/spencer/basilisk/src/grid/tree-common.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].restriction (point, s);
    if (_attribute[s.i].coarsen)
      _attribute[s.i].coarsen (point, s);
  }}}


  cell.flags |= leaf;


  decrement_neighbors (point);

#if _MPI
  if (!is_local(cell)) {
    cell.flags &= ~(active|border);    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;      
#line 128 "/home/spencer/basilisk/src/grid/tree-common.h"
if (cell.neighbors)
  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 130 "/home/spencer/basilisk/src/grid/tree-common.h"
if (allocated(0,0,0) && is_local(cell) && !is_border(cell))
     cell.flags |= border;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
  
#line 132 "/home/spencer/basilisk/src/grid/tree-common.h"
}
#endif

  return true;
}

void coarsen_cell_recursive (Point point, scalar * list)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  


  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 143 "/home/spencer/basilisk/src/grid/tree-common.h"
if (cell.neighbors)       
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
{
  {
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 145 "/home/spencer/basilisk/src/grid/tree-common.h"
if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
   coarsen_cell_recursive (point, list);      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
}
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 148 "/home/spencer/basilisk/src/grid/tree-common.h"
if (!(coarsen_cell (point, list))) qassert ("/home/spencer/basilisk/src/grid/tree-common.h", 148, "coarsen_cell (point, list)");
}

void mpi_boundary_refine (scalar *);
void mpi_boundary_coarsen (int, int);
void mpi_boundary_update (scalar *);

static
scalar * list_add_depend (scalar * list, scalar s)
{
  if (is_constant(s) || _attribute[s.i].restriction == no_restriction)
    return list;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  {scalar*_i=(scalar*)( _attribute[s.i].depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    list = list_add_depend (list, d);}}
  return list_append (list, s);
}

typedef struct {
  int nc, nf;
} astats;

     
astats adapt_wavelet (scalar * slist,
        double * max,
        int maxlevel,
        int minlevel,
        scalar * list)
{tracing("adapt_wavelet","/home/spencer/basilisk/src/grid/tree-common.h",173);
  scalar * ilist = list;

  if (is_constant(cm)) {
    if (list == NULL || list == all)
      list = list_copy (all);
    boundary_internal ((scalar *)list, "/home/spencer/basilisk/src/grid/tree-common.h", 184);
    restriction (slist);
  }
  else {
    if (list == NULL || list == all) {
      list = list_copy (((scalar[]){cm, fm.x, fm.y,{-1}}));
      {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 list = list_add (list, s);}}
    }
    boundary_internal ((scalar *)list, "/home/spencer/basilisk/src/grid/tree-common.h", 193);
    scalar * listr = list_concat (slist,((scalar[]) {cm,{-1}}));
    restriction (listr);
    pfree (listr,__func__,__FILE__,__LINE__);
  }

  astats st = {0, 0};
  scalar * listc = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    listc = list_add_depend (listc, s);}}


  if (minlevel < 1)
    minlevel = 1;
  ((Tree *)grid)->refined.n = 0;
  static const int refined = 1 << user, too_fine = 1 << (user + 1);
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 209 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 209 "/home/spencer/basilisk/src/grid/tree-common.h"
{
    if (is_active(cell)) {
      static const int too_coarse = 1 << (user + 2);
      if (is_leaf (cell)) {
 if (cell.flags & too_coarse) {
   cell.flags &= ~too_coarse;
   refine_cell (point, listc, refined, &((Tree *)grid)->refined);
   st.nf++;
 }
 continue;
      }
      else {
 if (cell.flags & refined) {

   cell.flags &= ~too_coarse;
   continue;
 }

 bool local = is_local(cell);
 if (!local)
    
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;     
#line 230 "/home/spencer/basilisk/src/grid/tree-common.h"
if (is_local(cell)) {
       local = true;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 231 "/home/spencer/basilisk/src/grid/tree-common.h"
;
     }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
} 
#line 233 "/home/spencer/basilisk/src/grid/tree-common.h"
if (local) {
   int i = 0;
   static const int just_fine = 1 << (user + 3);
   {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
     double emax = max[i++], sc[1 << 2];
     int c = 0;
  
     
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;       
#line 240 "/home/spencer/basilisk/src/grid/tree-common.h"
sc[c++] = val(s,0,0,0);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }     
#line 241 "/home/spencer/basilisk/src/grid/tree-common.h"
_attribute[s.i].prolongation (point, s);
     c = 0;
  
     
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 243 "/home/spencer/basilisk/src/grid/tree-common.h"
{
       double e = fabs(sc[c] - val(s,0,0,0));
       if (e > emax && level < maxlevel) {
  cell.flags &= ~too_fine;
  cell.flags |= too_coarse;
       }
       else if ((e <= emax/1.5 || level > maxlevel) &&
         !(cell.flags & (too_coarse|just_fine))) {
  if (level >= minlevel)
    cell.flags |= too_fine;
       }
       else if (!(cell.flags & too_coarse)) {
  cell.flags &= ~too_fine;
  cell.flags |= just_fine;
       }
       val(s,0,0,0) = sc[c++];
     }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }   
#line 260 "/home/spencer/basilisk/src/grid/tree-common.h"
}}}
  
   
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 261 "/home/spencer/basilisk/src/grid/tree-common.h"
{
     cell.flags &= ~just_fine;
     if (!is_leaf(cell)) {
       cell.flags &= ~too_coarse;
       if (level >= maxlevel)
  cell.flags |= too_fine;
     }
     else if (!is_active(cell))
       cell.flags &= ~too_coarse;
   }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  } 
#line 271 "/home/spencer/basilisk/src/grid/tree-common.h"
}
      }
    }
    else
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 277 "/home/spencer/basilisk/src/grid/tree-common.h"
mpi_boundary_refine (listc);



  for (int l = depth(); l >= 0; l--) {
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
      
#line 283 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 283 "/home/spencer/basilisk/src/grid/tree-common.h"
if (!(cell.pid < 0)) {
 if (level == l) {
   if (!is_leaf(cell)) {
     if (cell.flags & refined)

       cell.flags &= ~(refined|too_fine);
     else if (cell.flags & too_fine) {
       if (is_local(cell) && coarsen_cell (point, listc))
  st.nc++;
       cell.flags &= ~too_fine;
     }
   }
   if (cell.flags & too_fine)
     cell.flags &= ~too_fine;
   else if (level > 0 && (aparent(0,0,0).flags & too_fine))
     aparent(0,0,0).flags &= ~too_fine;
   continue;
 }
 else if (is_leaf(cell))
   continue;
      }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
    
#line 304 "/home/spencer/basilisk/src/grid/tree-common.h"
mpi_boundary_coarsen (l, too_fine);
  }
  pfree (listc,__func__,__FILE__,__LINE__);

  mpi_all_reduce (st.nf, MPI_INT, MPI_SUM);
  mpi_all_reduce (st.nc, MPI_INT, MPI_SUM);
  if (st.nc || st.nf)
    mpi_boundary_update (list);

  if (list != ilist)
    pfree (list,__func__,__FILE__,__LINE__);

  {end_tracing("adapt_wavelet","/home/spencer/basilisk/src/grid/tree-common.h",316);return st;}
end_tracing("adapt_wavelet","/home/spencer/basilisk/src/grid/tree-common.h",317);}

void macro_refine (bool cond)
{
  {
    int refined;
    do {
      boundary_internal ((scalar *)all, "/home/spencer/basilisk/src/grid/tree-common.h", 324);
      refined = 0;
      ((Tree *)grid)->refined.n = 0;
#line 286 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
#line 126
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
    
#line 288
if (is_leaf (cell)) {
      if (is_active(cell) && is_local(cell))
 
#line 328 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 328 "/home/spencer/basilisk/src/grid/tree-common.h"
if (cond) {
   refine_cell (point, all, 0, &((Tree *)grid)->refined);
   refined++;
   continue;
 }}      
#line 291 "/home/spencer/basilisk/src/grid/foreach_cell.h"
continue;
    } 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

#line 293
}
      
#line 333 "/home/spencer/basilisk/src/grid/tree-common.h"
mpi_all_reduce (refined, MPI_INT, MPI_SUM);
      if (refined) {
 mpi_boundary_refine (all);
 mpi_boundary_update (all);
      }
    } while (refined);
  }
}

static void refine_level (int depth)
{
  int refined;
  do {
    refined = 0;
    ((Tree *)grid)->refined.n = 0;
#line 286 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
#line 126
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
    
#line 288
if (is_leaf (cell)) {
      if (is_active(cell) && is_local(cell))
      
#line 349 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 349 "/home/spencer/basilisk/src/grid/tree-common.h"
if (level < depth) {
 refine_cell (point, NULL, 0, &((Tree *)grid)->refined);
 refined++;
 continue;
      }}      
#line 291 "/home/spencer/basilisk/src/grid/foreach_cell.h"
continue;
    } 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

#line 293
}
    
#line 354 "/home/spencer/basilisk/src/grid/tree-common.h"
mpi_all_reduce (refined, MPI_INT, MPI_SUM);
    if (refined) {
      mpi_boundary_refine (NULL);
      mpi_boundary_update (NULL);
    }
  } while (refined);
}

void macro_unrefine (bool cond)
{
  {
    static const int too_fine = 1 << user;
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 366 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 366 "/home/spencer/basilisk/src/grid/tree-common.h"
{
      if (is_leaf(cell))
 continue;
      if (is_local(cell) && (cond))
 cell.flags |= too_fine;
    }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
    
#line 372 "/home/spencer/basilisk/src/grid/tree-common.h"
for (int _l = depth(); _l >= 0; _l--) {
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 373 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 373 "/home/spencer/basilisk/src/grid/tree-common.h"
{
 if (is_leaf(cell))
   continue;
 if (level == _l) {
   if (is_local(cell) && (cell.flags & too_fine)) {
     coarsen_cell (point, all);
     cell.flags &= ~too_fine;
   }
   continue;
 }
      }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
      
#line 384 "/home/spencer/basilisk/src/grid/tree-common.h"
mpi_boundary_coarsen (_l, too_fine);
    }
    mpi_boundary_update (all);
  }
}

     
static void halo_face (vectorl vl)
{tracing("halo_face","/home/spencer/basilisk/src/grid/tree-common.h",391);
  
    {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}    
#line 394
{scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}

  for (int l = depth() - 1; l >= 0; l--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 494 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _cache = ((Tree *)grid)->prolongation[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _cache.n; _k++) {
 point.i = _cache.p[_k].i;

 point.j = _cache.p[_k].j;      
#line 399 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 399 "/home/spencer/basilisk/src/grid/tree-common.h"
{
        if (vl.x) {
#line 409 "/home/spencer/basilisk/src/grid/tree-common.h"
   if ((!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0))
     {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,0,0) = (fine(s,0,0,0) + fine(s,0,1,0))/2.;}}
   if ((!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0))
     {scalar*_i=(scalar*)( vl.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,1,0,0) = (fine(s,2,0,0) + fine(s,2,1,0))/2.;}}
#line 425 "/home/spencer/basilisk/src/grid/tree-common.h"
 }        
#line 400
if (vl.y) {
#line 409 "/home/spencer/basilisk/src/grid/tree-common.h"
   if ((!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0))
     {scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,0,0) = (fine(s,0,0,0) + fine(s,1,0,0))/2.;}}
   if ((!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0))
     {scalar*_i=(scalar*)( vl.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,1,0) = (fine(s,0,2,0) + fine(s,1,2,0))/2.;}}
#line 425 "/home/spencer/basilisk/src/grid/tree-common.h"
 }}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 500
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
end_tracing("halo_face","/home/spencer/basilisk/src/grid/tree-common.h",426);
#line 426 "/home/spencer/basilisk/src/grid/tree-common.h"
}



static scalar tree_init_scalar (scalar s, const char * name)
{
  s = multigrid_init_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation;
  return s;
}

static void prolongation_vertex (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

  
#line 440 "/home/spencer/basilisk/src/grid/tree-common.h"
fine(s,1,1,0) = (val(s,0,0,0) + val(s,1,0,0) + val(s,0,1,0) + val(s,1,1,0))/4.;





  for (int i = 0; i <= 1; i++) {
    for (int j = 0; j <= 1; j++)





      if (allocated_child(2*i,2*j,0))
 fine(s,2*i,2*j,0) = val(s,i,j,0);


    
      if (neighbor(i,0,0).neighbors) {

 fine(s,2*i,1,0) = (val(s,i,0,0) + val(s,i,1,0))/2.;
#line 470 "/home/spencer/basilisk/src/grid/tree-common.h"
      }      
#line 458
if (neighbor(0,i,0).neighbors) {

 fine(s,1,2*i,0) = (val(s,0,i,0) + val(s,1,i,0))/2.;
#line 470 "/home/spencer/basilisk/src/grid/tree-common.h"
      }
  }
}

static scalar tree_init_vertex_scalar (scalar s, const char * name)
{
  s = multigrid_init_vertex_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation = prolongation_vertex;
  return s;
}

static void tree_setup_vector (vector v)
{
  
    _attribute[v.x.i].refine = _attribute[v.x.i].prolongation;    _attribute[v.y.i].refine = _attribute[v.y.i].prolongation;
}

static vector tree_init_vector (vector v, const char * name)
{
  v = multigrid_init_vector (v, name);
  tree_setup_vector (v);
  return v;
}


static void refine_face_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 497 "/home/spencer/basilisk/src/grid/tree-common.h"
vector v = _attribute[s.i].v;

  if (!(!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0) &&
      (is_local(cell) || is_local(neighbor(-1,0,0)))) {
    double g1 = (val(v.x,0,+1,0) - val(v.x,0,-1,0))/8.;
    for (int j = 0; j <= 1; j++)
      fine(v.x,0,j,0) = val(v.x,0,0,0) + (2*j - 1)*g1;
  }
  if (!(!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) && neighbor(1,0,0).neighbors &&
      (is_local(cell) || is_local(neighbor(1,0,0)))) {
    double g1 = (val(v.x,1,+1,0) - val(v.x,1,-1,0))/8.;
    for (int j = 0; j <= 1; j++)
      fine(v.x,2,j,0) = val(v.x,1,0,0) + (2*j - 1)*g1;
  }
  if (is_local(cell)) {
    double g1 = (val(v.x,0,+1,0) - val(v.x,0,-1,0) + val(v.x,1,+1,0) - val(v.x,1,-1,0))/16.;
    for (int j = 0; j <= 1; j++)
      fine(v.x,1,j,0) = (val(v.x,0,0,0) + val(v.x,1,0,0))/2. + (2*j - 1)*g1;
  }
#line 541 "/home/spencer/basilisk/src/grid/tree-common.h"
}
#line 495
static void refine_face_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 497 "/home/spencer/basilisk/src/grid/tree-common.h"
vector v = _attribute[s.i].v;

  if (!(!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0) &&
      (is_local(cell) || is_local(neighbor(0,-1,0)))) {
    double g1 = (val(v.y,+1,0,0) - val(v.y,-1,0,0))/8.;
    for (int j = 0; j <= 1; j++)
      fine(v.y,j,0,0) = val(v.y,0,0,0) + (2*j - 1)*g1;
  }
  if (!(!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) && neighbor(0,1,0).neighbors &&
      (is_local(cell) || is_local(neighbor(0,1,0)))) {
    double g1 = (val(v.y,+1,1,0) - val(v.y,-1,1,0))/8.;
    for (int j = 0; j <= 1; j++)
      fine(v.y,j,2,0) = val(v.y,0,1,0) + (2*j - 1)*g1;
  }
  if (is_local(cell)) {
    double g1 = (val(v.y,+1,0,0) - val(v.y,-1,0,0) + val(v.y,+1,1,0) - val(v.y,-1,1,0))/16.;
    for (int j = 0; j <= 1; j++)
      fine(v.y,j,1,0) = (val(v.y,0,0,0) + val(v.y,0,1,0))/2. + (2*j - 1)*g1;
  }
#line 541 "/home/spencer/basilisk/src/grid/tree-common.h"
}

void refine_face (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 545 "/home/spencer/basilisk/src/grid/tree-common.h"
vector v = _attribute[s.i].v;
  
    _attribute[v.x.i].prolongation (point, v.x);    _attribute[v.y.i].prolongation (point, v.y);
}

void refine_face_solenoidal (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 552 "/home/spencer/basilisk/src/grid/tree-common.h"
refine_face (point, s);

  if (is_local(cell)) {

    vector v = _attribute[s.i].v;
    double d[1 << 2], p[1 << 2];
    int i = 0;    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 559 "/home/spencer/basilisk/src/grid/tree-common.h"
{
      d[i] = 0.;
      
 d[i] += val(v.x,1,0,0) - val(v.x,0,0,0); d[i] += val(v.y,0,1,0) - val(v.y,0,0,0);
      i++;
    }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }

    
#line 566 "/home/spencer/basilisk/src/grid/tree-common.h"
p[0] = 0.;
    p[1] = (3.*d[3] + d[0])/4. + d[2]/2.;
    p[2] = (d[3] + 3.*d[0])/4. + d[2]/2.;
    p[3] = (d[3] + d[0])/2. + d[2];
    fine(v.x,1,1,0) += p[1] - p[0];
    fine(v.x,1,0,0) += p[3] - p[2];
    fine(v.y,0,1,0) += p[0] - p[2];
    fine(v.y,1,1,0) += p[1] - p[3];
#line 601 "/home/spencer/basilisk/src/grid/tree-common.h"
  }

}

static vector tree_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  
    _attribute[v.x.i].restriction = _attribute[v.x.i].refine = no_restriction;    _attribute[v.y.i].restriction = _attribute[v.y.i].refine = no_restriction;
  _attribute[v.x.i].restriction = restriction_face;
  _attribute[v.x.i].refine = refine_face;
  
    _attribute[v.x.i].prolongation = refine_face_x;    _attribute[v.y.i].prolongation = refine_face_y;
  return v;
}

static tensor tree_init_tensor (tensor t, const char * name)
{
  t = multigrid_init_tensor (t, name);
  
    tree_setup_vector (t.x);    tree_setup_vector (t.y);
  return t;
}

     
static void tree_boundary_level (scalar * list, int l)
{tracing("tree_boundary_level","/home/spencer/basilisk/src/grid/tree-common.h",626);
  int depth = l < 0 ? depth() : l;

  if (tree_is_full()) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, depth); };
    {end_tracing("tree_boundary_level","/home/spencer/basilisk/src/grid/tree-common.h",632);return;}
  }

  scalar * listdef = NULL, * listc = NULL, * list2 = NULL, * vlist = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant (s)) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
     list2 = list_add (list2, _attribute[s.i].v.x);     list2 = list_add (list2, _attribute[s.i].v.y);}
 else {
   list2 = list_add (list2, s);
   if (_attribute[s.i].restriction == restriction_vertex)
     vlist = list_add (vlist, s);
 }
      }
    }}}

  if (vlist) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 1708 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 1710
((Tree *)grid)->vertices
#line 436
).n; _k++) {
 point.i = (
#line 1710
((Tree *)grid)->vertices
#line 437
).p[_k].i;

 point.j = (
#line 1710
((Tree *)grid)->vertices
#line 439
).p[_k].j;




 point.level = (
#line 1710
((Tree *)grid)->vertices
#line 444
).p[_k].level;
 _flags = (
#line 1710
((Tree *)grid)->vertices
#line 445
).p[_k].flags; 
#line 1710
{
    int ig = -1; NOT_UNUSED (ig);

    int jg = -1; NOT_UNUSED (jg); 
#line 662 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 662 "/home/spencer/basilisk/src/grid/tree-common.h"
{
      if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) || (!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0) ||
   (!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0) || (!is_leaf (neighbor(-1,-1,0)) && neighbor(-1,-1,0).neighbors && neighbor(-1,-1,0).pid >= 0)) {

 {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   val(s,0,0,0) = is_vertex (child(0,0,0)) ? fine(s,0,0,0) : 1e30f;}}
      }
      else
 {
   if (child.y == 1 &&
       ((!is_leaf(cell) && !cell.neighbors && cell.pid >= 0) || (!is_leaf(neighbor(-1,0,0)) && !neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0))) {

     {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,0,0) = is_vertex(neighbor(0,-1,0)) && is_vertex(neighbor(0,1,0)) ?
  (val(s,0,-1,0) + val(s,0,1,0))/2. : 1e30f;}}
   }   
#line 671
if (child.x == 1 &&
       ((!is_leaf(cell) && !cell.neighbors && cell.pid >= 0) || (!is_leaf(neighbor(0,-1,0)) && !neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0))) {

     {scalar*_i=(scalar*)( vlist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
       val(s,0,0,0) = is_vertex(neighbor(-1,0,0)) && is_vertex(neighbor(1,0,0)) ?
  (val(s,-1,0,0) + val(s,1,0,0))/2. : 1e30f;}}
   }}
    }}
  
#line 1719 "/home/spencer/basilisk/src/grid/tree.h"
}      
#line 447
}
  }
}

#line 1720
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
#line 711 "/home/spencer/basilisk/src/grid/tree-common.h"
  pfree (vlist,__func__,__FILE__,__LINE__);

  if (listdef || listc) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, depth); };
    for (int l = depth - 1; l >= 0; l--) {      
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 716 "/home/spencer/basilisk/src/grid/tree-common.h"
{
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   _stencil_restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
default_stencil (   point,((scalar[]){ s,{-1}}));}}
      }  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 740 "/home/spencer/basilisk/src/grid/tree.h"
{ 
#line 731
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
    
#line 742
if (!is_leaf(cell)) 
#line 716 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 716 "/home/spencer/basilisk/src/grid/tree-common.h"
{
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   _attribute[s.i].restriction (point, s);}}
      }}      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}





}      
#line 722 "/home/spencer/basilisk/src/grid/tree-common.h"
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, l); };
    }
    pfree (listdef,__func__,__FILE__,__LINE__);
    pfree (listc,__func__,__FILE__,__LINE__);
    pfree (list2,__func__,__FILE__,__LINE__);
  }

  scalar * listr = NULL;
  vector * listf = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant (s) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].face)
 listf = vectors_add (listf, _attribute[s.i].v);
      else
 listr = list_add (listr, s);
    }}}

  if (listr || listf) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, 0); };
    for (int i = 0; i < depth; i++) {
#line 494 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (i <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _cache = ((Tree *)grid)->prolongation[i];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = i;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _cache.n; _k++) {
 point.i = _cache.p[_k].i;

 point.j = _cache.p[_k].j; 
#line 742 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 742 "/home/spencer/basilisk/src/grid/tree-common.h"
{
 {scalar*_i=(scalar*)( listr);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
          _attribute[s.i].prolongation (point, s);}}
 {vector*_i=(vector*)( listf);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
   {
     _attribute[v.x.i].prolongation (point, v.x);     _attribute[v.y.i].prolongation (point, v.y);}}}
      }}      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 500
}
}
      
#line 749 "/home/spencer/basilisk/src/grid/tree-common.h"
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, i + 1); };
    }
    pfree (listr,__func__,__FILE__,__LINE__);
    pfree (listf,__func__,__FILE__,__LINE__);
  }
end_tracing("tree_boundary_level","/home/spencer/basilisk/src/grid/tree-common.h",754);}

double treex (Point point) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 757 "/home/spencer/basilisk/src/grid/tree-common.h"
if (level == 0)
    return 0;

  double i = 2*child.x - child.y;
  if (i <= 1 && i >= -1) i = -i;




  return treex(parent) + i/(1 << 2*(level - 1));
}

double treey (Point point) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 770 "/home/spencer/basilisk/src/grid/tree-common.h"
if (level == 0)
    return 0;
  return treey(parent) + 4./(1 << 2*(level - 1));
}

void output_tree (FILE * fp)
{
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
    
#line 778 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 778 "/home/spencer/basilisk/src/grid/tree-common.h"
if (cell.neighbors)       
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 780 "/home/spencer/basilisk/src/grid/tree-common.h"
if (is_local(cell))
   fprintf (fp, "%g %g\n%g %g\n\n",
     treex(parent), treey(parent), treex(point), treey(point));      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}
#line 782 "/home/spencer/basilisk/src/grid/tree-common.h"
} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

#line 783 "/home/spencer/basilisk/src/grid/tree-common.h"
}

     
void tree_check()
{tracing("tree_check","/home/spencer/basilisk/src/grid/tree-common.h",786);


  long nleaves = 0, nactive = 0; 
#line 140 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    Point root = {0};
    for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)

      for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 67 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 791 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 791 "/home/spencer/basilisk/src/grid/tree-common.h"
{
    if (is_leaf(cell)) {
      if (!(cell.pid >= 0)) qassert ("/home/spencer/basilisk/src/grid/tree-common.h", 793, "cell.pid >= 0");
      nleaves++;
    }
    if (is_local(cell))
      if (!(is_active(cell) || (!is_leaf(cell) && !cell.neighbors && cell.pid >= 0))) qassert ("/home/spencer/basilisk/src/grid/tree-common.h", 797, "is_active(cell) || is_prolongation(cell)");
    if (is_active(cell))
      nactive++;

    int neighbors = 0;    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
      
#line 803 "/home/spencer/basilisk/src/grid/tree-common.h"
if (allocated(0,0,0) && (!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
 neighbors++;      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 805 "/home/spencer/basilisk/src/grid/tree-common.h"
if (!(cell.neighbors == neighbors)) qassert ("/home/spencer/basilisk/src/grid/tree-common.h", 805, "cell.neighbors == neighbors");


    if (!cell.neighbors)
      if (!(!allocated_child(0,0,0))) qassert ("/home/spencer/basilisk/src/grid/tree-common.h", 809, "!allocated_child(0)");
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 152 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}


  
#line 813 "/home/spencer/basilisk/src/grid/tree-common.h"
long reachable = 0;
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 814 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 814 "/home/spencer/basilisk/src/grid/tree-common.h"
{
    if (is_active(cell))
      reachable++;
    else
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 820 "/home/spencer/basilisk/src/grid/tree-common.h"
if (!(nactive == reachable)) qassert ("/home/spencer/basilisk/src/grid/tree-common.h", 820, "nactive == reachable");


  reachable = 0;
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
    
#line 825 "/home/spencer/basilisk/src/grid/tree-common.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 825 "/home/spencer/basilisk/src/grid/tree-common.h"
if (is_leaf(cell)) {
      reachable++;
      continue;
    }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 829 "/home/spencer/basilisk/src/grid/tree-common.h"
if (!(nleaves == reachable)) qassert ("/home/spencer/basilisk/src/grid/tree-common.h", 829, "nleaves == reachable");
end_tracing("tree_check","/home/spencer/basilisk/src/grid/tree-common.h",830);}

     
static void tree_restriction (scalar * list) {tracing("tree_restriction","/home/spencer/basilisk/src/grid/tree-common.h",833);
  boundary_internal ((scalar *)list, "/home/spencer/basilisk/src/grid/tree-common.h", 834);
  if (tree_is_full())
    multigrid_restriction (list);
end_tracing("tree_restriction","/home/spencer/basilisk/src/grid/tree-common.h",837);}

void tree_methods()
{
  multigrid_methods();
  init_scalar = tree_init_scalar;
  init_vertex_scalar = tree_init_vertex_scalar;
  init_vector = tree_init_vector;
  init_face_vector = tree_init_face_vector;
  init_tensor = tree_init_tensor;
  boundary_level = tree_boundary_level;
  boundary_face = halo_face;
  restriction = tree_restriction;
}
#line 1723 "/home/spencer/basilisk/src/grid/tree.h"


void tree_periodic (int dir)
{
  int depth = grid ? depth() : -1;
  if (grid)
    free_grid();
  periodic (dir);
  if (depth >= 0)
    init_grid (1 << depth);
}


#if _MPI
#line 1 "grid/tree-mpi.h"
#line 1 "/home/spencer/basilisk/src/grid/tree-mpi.h"

int debug_iteration = -1;

void debug_mpi (FILE * fp1);

typedef struct {
  CacheLevel * halo;
  void * buf;
  MPI_Request r;
  int depth;
  int pid;
  int maxdepth;
} Rcv;

typedef struct {
  Rcv * rcv;
  char * name;
  int npid;
} RcvPid;

typedef struct {
  RcvPid * rcv, * snd;
} SndRcv;

typedef struct {
  Boundary parent;

  SndRcv mpi_level, mpi_level_root, restriction;
  Array * send, * receive;
} MpiBoundary;

static void cache_level_init (CacheLevel * c)
{
  c->p = NULL;
  c->n = c->nm = 0;
}

static void rcv_append (Point point, Rcv * rcv)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 40 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (level > rcv->depth) {
    rcv->halo = (CacheLevel *) prealloc (rcv->halo, (level + 1)*sizeof(CacheLevel),__func__,__FILE__,__LINE__);
    for (int j = rcv->depth + 1; j <= level; j++)
      cache_level_init (&rcv->halo[j]);
    rcv->depth = level;
  }
  cache_level_append (&rcv->halo[level], point);
  if (level > rcv->maxdepth)
    rcv->maxdepth = level;
}

void rcv_print (Rcv * rcv, FILE * fp, const char * prefix)
{
  for (int l = 0; l <= rcv->depth; l++)
    if (rcv->halo[l].n > 0) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 452 "/home/spencer/basilisk/src/grid/tree.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 55 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 466 "/home/spencer/basilisk/src/grid/tree.h"
).n; _k++) {
 point.i = (
#line 55 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 467 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].i;

 point.j = (
#line 55 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 469 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].j; 
#line 56 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "/home/spencer/basilisk/src/grid/tree-mpi.h"
fprintf (fp, "%s%g %g %g %d %d\n", prefix, x, y, z, rcv->pid, level);}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 57 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}

static void rcv_free_buf (Rcv * rcv)
{
  if (rcv->buf) {
    prof_start ("rcv_pid_receive");
    MPI_Wait (&rcv->r, MPI_STATUS_IGNORE);
    pfree (rcv->buf,__func__,__FILE__,__LINE__);
    rcv->buf = NULL;
    prof_stop();
  }
}

static void rcv_destroy (Rcv * rcv)
{
  rcv_free_buf (rcv);
  for (int i = 0; i <= rcv->depth; i++)
    if (rcv->halo[i].n > 0)
      pfree (rcv->halo[i].p,__func__,__FILE__,__LINE__);
  pfree (rcv->halo,__func__,__FILE__,__LINE__);
}

static RcvPid * rcv_pid_new (const char * name)
{
  RcvPid * r = ((RcvPid *) pcalloc (1, sizeof(RcvPid),__func__,__FILE__,__LINE__));
  r->name = pstrdup (name,__func__,__FILE__,__LINE__);
  return r;
}

static Rcv * rcv_pid_pointer (RcvPid * p, int pid)
{
  if (!(pid >= 0 && pid < npe())) qassert ("/home/spencer/basilisk/src/grid/tree-mpi.h", 88, "pid >= 0 && pid < npe()");

  int i;
  for (i = 0; i < p->npid; i++)
    if (pid == p->rcv[i].pid)
      break;

  if (i == p->npid) {
    p->rcv = (Rcv *) prealloc (p->rcv, (++p->npid)*sizeof(Rcv),__func__,__FILE__,__LINE__);
    Rcv * rcv = &p->rcv[p->npid-1];
    rcv->pid = pid;
    rcv->depth = rcv->maxdepth = 0;
    rcv->halo = ((CacheLevel *) pmalloc ((1)*sizeof(CacheLevel),__func__,__FILE__,__LINE__));
    rcv->buf = NULL;
    cache_level_init (&rcv->halo[0]);
  }
  return &p->rcv[i];
}

static void rcv_pid_append (RcvPid * p, int pid, Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 109 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv_append (point, rcv_pid_pointer (p, pid));
}

static void rcv_pid_append_pids (RcvPid * p, Array * pids)
{

  for (int i = 0; i < p->npid; i++) {
    int pid = p->rcv[i].pid, j, * a;
    for (j = 0, a = pids->p; j < pids->len/sizeof(int); j++,a++)
      if (*a == pid)
 break;
    if (j == pids->len/sizeof(int))
      array_append (pids, &pid, sizeof(int));
  }
}

void rcv_pid_write (RcvPid * p, const char * name)
{
  for (int i = 0; i < p->npid; i++) {
    Rcv * rcv = &p->rcv[i];
    char fname[80];
    sprintf (fname, "%s-%d-%d", name, pid(), rcv->pid);
    FILE * fp = fopen (fname, "w");
    rcv_print (rcv, fp, "");
    fclose (fp);
  }
}

static void rcv_pid_print (RcvPid * p, FILE * fp, const char * prefix)
{
  for (int i = 0; i < p->npid; i++)
    rcv_print (&p->rcv[i], fp, prefix);
}

static void rcv_pid_destroy (RcvPid * p)
{
  for (int i = 0; i < p->npid; i++)
    rcv_destroy (&p->rcv[i]);
  pfree (p->rcv,__func__,__FILE__,__LINE__);
  pfree (p->name,__func__,__FILE__,__LINE__);
  pfree (p,__func__,__FILE__,__LINE__);
}

static Boundary * mpi_boundary = NULL;






void debug_mpi (FILE * fp1);

static void apply_bc (Rcv * rcv, scalar * list, scalar * listv,
        vector * listf, int l, MPI_Status s)
{
  double * b = rcv->buf;

#line 452 "/home/spencer/basilisk/src/grid/tree.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 165 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 466 "/home/spencer/basilisk/src/grid/tree.h"
).n; _k++) {
 point.i = (
#line 165 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 467 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].i;

 point.j = (
#line 165 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 469 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].j; 
#line 165 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 165 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      memcpy (&val(s,0,0,0), b, sizeof(double)*_attribute[s.i].block);
      b += _attribute[s.i].block;
    }}}
    {vector*_i=(vector*)( listf);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      { {
 memcpy (&val(v.x,0,0,0), b, sizeof(double)*_attribute[v.x.i].block);
 b += _attribute[v.x.i].block;
 if (*b != 1e30f && allocated(1,0,0))
   memcpy (&val(v.x,1,0,0), b, sizeof(double)*_attribute[v.x.i].block);
 b += _attribute[v.x.i].block;
      } 
#line 171
{
 memcpy (&val(v.y,0,0,0), b, sizeof(double)*_attribute[v.y.i].block);
 b += _attribute[v.y.i].block;
 if (*b != 1e30f && allocated(0,1,0))
   memcpy (&val(v.y,0,1,0), b, sizeof(double)*_attribute[v.y.i].block);
 b += _attribute[v.y.i].block;
      }}}}
    {scalar*_i=(scalar*)( listv);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      for (int i = 0; i <= 1; i++)
 for (int j = 0; j <= 1; j++)







          {
     if (*b != 1e30f && allocated(i,j,0))
       memcpy (&val(s,i,j,0), b, sizeof(double)*_attribute[s.i].block);
     b += _attribute[s.i].block;
          }

    }}}
  }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}  
#line 196 "/home/spencer/basilisk/src/grid/tree-mpi.h"
size_t size = b - (double *) rcv->buf;
  pfree (rcv->buf,__func__,__FILE__,__LINE__);
  rcv->buf = NULL;

  int rlen;
  MPI_Get_count (&s, MPI_DOUBLE, &rlen);
  if (rlen != size) {
    fprintf (ferr,
      "rlen (%d) != size (%ld), %d receiving from %d at level %d\n"
      "Calling debug_mpi(NULL)...\n"
      "Aborting...\n",
      rlen, size, pid(), rcv->pid, l);
    fflush (ferr);
    debug_mpi (NULL);
    MPI_Abort (MPI_COMM_WORLD, -2);
  }
}
#line 234 "/home/spencer/basilisk/src/grid/tree-mpi.h"
static void mpi_recv_check (void * buf, int count, MPI_Datatype datatype,
       int source, int tag,
       MPI_Comm comm, MPI_Status * status,
       const char * name)
{
#line 269 "/home/spencer/basilisk/src/grid/tree-mpi.h"
  int errorcode = MPI_Recv (buf, count, datatype, source, tag, comm, status);
  if (errorcode != MPI_SUCCESS) {
    char string[MPI_MAX_ERROR_STRING];
    int resultlen;
    MPI_Error_string (errorcode, string, &resultlen);
    fprintf (ferr,
      "ERROR MPI_Recv \"%s\" (count = %d, source = %d, tag = %d):\n%s\n"
      "Calling debug_mpi(NULL)...\n"
      "Aborting...\n",
      name, count, source, tag, string);
    fflush (ferr);
    debug_mpi (NULL);
    MPI_Abort (MPI_COMM_WORLD, -1);
  }





}

     
static int mpi_waitany (int count, MPI_Request array_of_requests[], int *indx,
   MPI_Status *status)
{tracing("mpi_waitany","/home/spencer/basilisk/src/grid/tree-mpi.h",291);
  { int _ret= MPI_Waitany (count, array_of_requests, indx, status);end_tracing("mpi_waitany","/home/spencer/basilisk/src/grid/tree-mpi.h",294);return _ret;}
end_tracing("mpi_waitany","/home/spencer/basilisk/src/grid/tree-mpi.h",295);}

static int list_lenb (scalar * list) {
  int len = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    len += _attribute[s.i].block;}}
  return len;
}

static int vectors_lenb (vector * list) {
  int len = 0;
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
    len += _attribute[v.x.i].block;}}
  return len;
}

static void rcv_pid_receive (RcvPid * m, scalar * list, scalar * listv,
        vector * listf, int l)
{
  if (m->npid == 0)
    return;

  prof_start ("rcv_pid_receive");

  int len = list_lenb (list) + 2*2*vectors_lenb (listf) +
    (1 << 2)*list_lenb (listv);

  MPI_Request r[m->npid];
  Rcv * rrcv[m->npid];
  int nr = 0;
  for (int i = 0; i < m->npid; i++) {
    Rcv * rcv = &m->rcv[i];
    if (l <= rcv->depth && rcv->halo[l].n > 0) {
      if (!(!rcv->buf)) qassert ("/home/spencer/basilisk/src/grid/tree-mpi.h", 328, "!rcv->buf");
      rcv->buf = pmalloc (sizeof (double)*rcv->halo[l].n*len,__func__,__FILE__,__LINE__);






      MPI_Irecv (rcv->buf, rcv->halo[l].n*len, MPI_DOUBLE, rcv->pid,
   (l), MPI_COMM_WORLD, &r[nr]);
      rrcv[nr++] = rcv;






    }
  }


  if (nr > 0) {
    int i;
    MPI_Status s;
    mpi_waitany (nr, r, &i, &s);
    while (i != MPI_UNDEFINED) {
      Rcv * rcv = rrcv[i];
      if (!(l <= rcv->depth && rcv->halo[l].n > 0)) qassert ("/home/spencer/basilisk/src/grid/tree-mpi.h", 355, "l <= rcv->depth && rcv->halo[l].n > 0");
      if (!(rcv->buf)) qassert ("/home/spencer/basilisk/src/grid/tree-mpi.h", 356, "rcv->buf");
      apply_bc (rcv, list, listv, listf, l, s);
      mpi_waitany (nr, r, &i, &s);
    }
  }

  prof_stop();
}

     
static void rcv_pid_wait (RcvPid * m)
{tracing("rcv_pid_wait","/home/spencer/basilisk/src/grid/tree-mpi.h",366);

  for (int i = 0; i < m->npid; i++)
    rcv_free_buf (&m->rcv[i]);
end_tracing("rcv_pid_wait","/home/spencer/basilisk/src/grid/tree-mpi.h",371);}

static void rcv_pid_send (RcvPid * m, scalar * list, scalar * listv,
     vector * listf, int l)
{
  if (m->npid == 0)
    return;

  prof_start ("rcv_pid_send");

  int len = list_lenb (list) + 2*2*vectors_lenb (listf) +
    (1 << 2)*list_lenb (listv);


  for (int i = 0; i < m->npid; i++) {
    Rcv * rcv = &m->rcv[i];
    if (l <= rcv->depth && rcv->halo[l].n > 0) {
      if (!(!rcv->buf)) qassert ("/home/spencer/basilisk/src/grid/tree-mpi.h", 388, "!rcv->buf");
      rcv->buf = pmalloc (sizeof (double)*rcv->halo[l].n*len,__func__,__FILE__,__LINE__);
      double * b = rcv->buf;

#line 452 "/home/spencer/basilisk/src/grid/tree.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 391 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 466 "/home/spencer/basilisk/src/grid/tree.h"
).n; _k++) {
 point.i = (
#line 391 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 467 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].i;

 point.j = (
#line 391 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv->halo[l]
#line 469 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].j; 
#line 391 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 391 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
 {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
   memcpy (b, &val(s,0,0,0), sizeof(double)*_attribute[s.i].block);
   b += _attribute[s.i].block;
 }}}
 {vector*_i=(vector*)( listf);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
   { {
     memcpy (b, &val(v.x,0,0,0), sizeof(double)*_attribute[v.x.i].block);
     b += _attribute[v.x.i].block;
     if (allocated(1,0,0))
       memcpy (b, &val(v.x,1,0,0), sizeof(double)*_attribute[v.x.i].block);
     else
       *b = 1e30f;
     b += _attribute[v.x.i].block;
   } 
#line 397
{
     memcpy (b, &val(v.y,0,0,0), sizeof(double)*_attribute[v.y.i].block);
     b += _attribute[v.y.i].block;
     if (allocated(0,1,0))
       memcpy (b, &val(v.y,0,1,0), sizeof(double)*_attribute[v.y.i].block);
     else
       *b = 1e30f;
     b += _attribute[v.y.i].block;
   }}}}
 {scalar*_i=(scalar*)( listv);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
   for (int i = 0; i <= 1; i++)
     for (int j = 0; j <= 1; j++)
#line 418 "/home/spencer/basilisk/src/grid/tree-mpi.h"
       {
  if (allocated(i,j,0))
    memcpy (b, &val(s,i,j,0), sizeof(double)*_attribute[s.i].block);
  else
    *b = 1e30f;
  b += _attribute[s.i].block;
       }

 }}}
      }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}      
#line 433 "/home/spencer/basilisk/src/grid/tree-mpi.h"
MPI_Isend (rcv->buf, (b - (double *) rcv->buf),
   MPI_DOUBLE, rcv->pid, (l), MPI_COMM_WORLD,
   &rcv->r);
    }
  }

  prof_stop();
}

static void rcv_pid_sync (SndRcv * m, scalar * list, int l)
{
  scalar * listr = NULL, * listv = NULL;
  vector * listf = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].block > 0) {
      if (_attribute[s.i].face)
 listf = vectors_add (listf, _attribute[s.i].v);
      else if (_attribute[s.i].restriction == restriction_vertex)
 listv = list_add (listv, s);
      else
 listr = list_add (listr, s);
    }}}
  rcv_pid_send (m->snd, listr, listv, listf, l);
  rcv_pid_receive (m->rcv, listr, listv, listf, l);
  rcv_pid_wait (m->snd);
  pfree (listr,__func__,__FILE__,__LINE__);
  pfree (listf,__func__,__FILE__,__LINE__);
  pfree (listv,__func__,__FILE__,__LINE__);
}

static void snd_rcv_destroy (SndRcv * m)
{
  rcv_pid_destroy (m->rcv);
  rcv_pid_destroy (m->snd);
}

static void snd_rcv_init (SndRcv * m, const char * name)
{
  char s[strlen(name) + 5];
  strcpy (s, name);
  strcat (s, ".rcv");
  m->rcv = rcv_pid_new (s);
  strcpy (s, name);
  strcat (s, ".snd");
  m->snd = rcv_pid_new (s);
}

static void mpi_boundary_destroy (Boundary * b)
{
  MpiBoundary * m = (MpiBoundary *) b;
  snd_rcv_destroy (&m->mpi_level);
  snd_rcv_destroy (&m->mpi_level_root);
  snd_rcv_destroy (&m->restriction);
  array_free (m->send);
  array_free (m->receive);
  pfree (m,__func__,__FILE__,__LINE__);
}

     
static void mpi_boundary_level (const Boundary * b, scalar * list, int l)
{tracing("mpi_boundary_level","/home/spencer/basilisk/src/grid/tree-mpi.h",492);
  MpiBoundary * m = (MpiBoundary *) b;
  rcv_pid_sync (&m->mpi_level, list, l);
  rcv_pid_sync (&m->mpi_level_root, list, l);
end_tracing("mpi_boundary_level","/home/spencer/basilisk/src/grid/tree-mpi.h",497);}

     
static void mpi_boundary_restriction (const Boundary * b, scalar * list, int l)
{tracing("mpi_boundary_restriction","/home/spencer/basilisk/src/grid/tree-mpi.h",500);
  MpiBoundary * m = (MpiBoundary *) b;
  rcv_pid_sync (&m->restriction, list, l);
end_tracing("mpi_boundary_restriction","/home/spencer/basilisk/src/grid/tree-mpi.h",504);}

void mpi_boundary_new()
{
  mpi_boundary = (Boundary *) ((MpiBoundary *) pcalloc (1, sizeof(MpiBoundary),__func__,__FILE__,__LINE__));
  mpi_boundary->destroy = mpi_boundary_destroy;
  mpi_boundary->level = mpi_boundary_level;
  mpi_boundary->restriction = mpi_boundary_restriction;
  MpiBoundary * mpi = (MpiBoundary *) mpi_boundary;
  snd_rcv_init (&mpi->mpi_level, "mpi_level");
  snd_rcv_init (&mpi->mpi_level_root, "mpi_level_root");
  snd_rcv_init (&mpi->restriction, "restriction");
  mpi->send = array_new();
  mpi->receive = array_new();
  add_boundary (mpi_boundary);
}

static FILE * fopen_prefix (FILE * fp, const char * name, char * prefix)
{
  if (fp) {
    sprintf (prefix, "%s-%d ", name, pid());
    return fp;
  }
  else {
    strcpy (prefix, "");
    char fname[80];
    if (debug_iteration >= 0)
      sprintf (fname, "%s-%d-%d", name, debug_iteration, pid());
    else
      sprintf (fname, "%s-%d", name, pid());
    return fopen (fname, "w");
  }
}

void debug_mpi (FILE * fp1)
{
  void output_cells_internal (FILE * fp);

  char prefix[80];
  FILE * fp;


  if (fp1 == NULL) {
    char name[80];
    sprintf (name, "halo-%d", pid()); remove (name);
    sprintf (name, "cells-%d", pid()); remove (name);
    sprintf (name, "faces-%d", pid()); remove (name);
    sprintf (name, "vertices-%d", pid()); remove (name);
    sprintf (name, "neighbors-%d", pid()); remove (name);
    sprintf (name, "mpi-level-rcv-%d", pid()); remove (name);
    sprintf (name, "mpi-level-snd-%d", pid()); remove (name);
    sprintf (name, "mpi-level-root-rcv-%d", pid()); remove (name);
    sprintf (name, "mpi-level-root-snd-%d", pid()); remove (name);
    sprintf (name, "mpi-restriction-rcv-%d", pid()); remove (name);
    sprintf (name, "mpi-restriction-snd-%d", pid()); remove (name);
    sprintf (name, "mpi-border-%d", pid()); remove (name);
    sprintf (name, "exterior-%d", pid()); remove (name);
    sprintf (name, "depth-%d", pid()); remove (name);
    sprintf (name, "refined-%d", pid()); remove (name);
  }


  fp = fopen_prefix (fp1, "halo", prefix);
  for (int l = 0; l < depth(); l++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 494 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _cache = ((Tree *)grid)->prolongation[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _cache.n; _k++) {
 point.i = _cache.p[_k].i;

 point.j = _cache.p[_k].j;
      
#line 569 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
        
#line 570 "/home/spencer/basilisk/src/grid/tree-mpi.h"
fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 570 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 500
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 571 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!fp1)
    fclose (fp);

  if (!fp1) {
    fp = fopen_prefix (fp1, "cells", prefix);
    output_cells_internal (fp);
    fclose (fp);
  }

  fp = fopen_prefix (fp1, "faces", prefix);

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 581 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 582 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 582 "/home/spencer/basilisk/src/grid/tree-mpi.h"
fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 582 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 582 "/home/spencer/basilisk/src/grid/tree-mpi.h"
fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 582 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}  
#line 583 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "vertices", prefix);

#line 1708 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 1710
((Tree *)grid)->vertices
#line 436
).n; _k++) {
 point.i = (
#line 1710
((Tree *)grid)->vertices
#line 437
).p[_k].i;

 point.j = (
#line 1710
((Tree *)grid)->vertices
#line 439
).p[_k].j;




 point.level = (
#line 1710
((Tree *)grid)->vertices
#line 444
).p[_k].level;
 _flags = (
#line 1710
((Tree *)grid)->vertices
#line 445
).p[_k].flags; 
#line 1710
{
    int ig = -1; NOT_UNUSED (ig);

    int jg = -1; NOT_UNUSED (jg);    
#line 588 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 588 "/home/spencer/basilisk/src/grid/tree-mpi.h"
fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);}
  
#line 1719 "/home/spencer/basilisk/src/grid/tree.h"
}      
#line 447
}
  }
}

#line 1720
}  
#line 589 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "neighbors", prefix); 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 593 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 593 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    int n = 0;    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
      
#line 596 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))
 n++;      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 598 "/home/spencer/basilisk/src/grid/tree-mpi.h"
fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, cell.neighbors);
    if (!(cell.neighbors == n)) qassert ("/home/spencer/basilisk/src/grid/tree-mpi.h", 599, "cell.neighbors == n");
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 601 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!fp1)
    fclose (fp);

  MpiBoundary * mpi = (MpiBoundary *) mpi_boundary;

  fp = fopen_prefix (fp1, "mpi-level-rcv", prefix);
  rcv_pid_print (mpi->mpi_level.rcv, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-level-root-rcv", prefix);
  rcv_pid_print (mpi->mpi_level_root.rcv, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-restriction-rcv", prefix);
  rcv_pid_print (mpi->restriction.rcv, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-level-snd", prefix);
  rcv_pid_print (mpi->mpi_level.snd, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-level-root-snd", prefix);
  rcv_pid_print (mpi->mpi_level_root.snd, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-restriction-snd", prefix);
  rcv_pid_print (mpi->restriction.snd, fp, prefix);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "mpi-border", prefix);
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 637 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 637 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    if (is_border(cell))
      fprintf (fp, "%s%g %g %g %d %d %d\n",
        prefix, x, y, z, level, cell.neighbors, cell.pid);
    else
      continue;
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 646 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "exterior", prefix);
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 650 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 650 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    if (!is_local(cell))
      fprintf (fp, "%s%g %g %g %d %d %d %d\n",
        prefix, x, y, z, level, cell.neighbors,
        cell.pid, cell.flags & leaf);






  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 662 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "depth", prefix);
  fprintf (fp, "depth: %d %d\n", pid(), depth());
  fprintf (fp, "======= mpi_level.snd ======\n");
  RcvPid * snd = mpi->mpi_level.snd;
  for (int i = 0; i < snd->npid; i++)
    fprintf (fp, "%d %d %d\n", pid(), snd->rcv[i].pid, snd->rcv[i].maxdepth);
  fprintf (fp, "======= mpi_level.rcv ======\n");
  snd = mpi->mpi_level.rcv;
  for (int i = 0; i < snd->npid; i++)
    fprintf (fp, "%d %d %d\n", pid(), snd->rcv[i].pid, snd->rcv[i].maxdepth);
  if (!fp1)
    fclose (fp);

  fp = fopen_prefix (fp1, "refined", prefix);
#line 423 "/home/spencer/basilisk/src/grid/tree.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 679 "/home/spencer/basilisk/src/grid/tree-mpi.h"
((Tree *)grid)->refined
#line 436 "/home/spencer/basilisk/src/grid/tree.h"
).n; _k++) {
 point.i = (
#line 679 "/home/spencer/basilisk/src/grid/tree-mpi.h"
((Tree *)grid)->refined
#line 437 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].i;

 point.j = (
#line 679 "/home/spencer/basilisk/src/grid/tree-mpi.h"
((Tree *)grid)->refined
#line 439 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].j;




 point.level = (
#line 679 "/home/spencer/basilisk/src/grid/tree-mpi.h"
((Tree *)grid)->refined
#line 444 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].level;
 _flags = (
#line 679 "/home/spencer/basilisk/src/grid/tree-mpi.h"
((Tree *)grid)->refined
#line 445 "/home/spencer/basilisk/src/grid/tree.h"
).p[_k].flags;
    
#line 680 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 680 "/home/spencer/basilisk/src/grid/tree-mpi.h"
fprintf (fp, "%s%g %g %g %d\n", prefix, x, y, z, level);}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 681 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!fp1)
    fclose (fp);
}

static void snd_rcv_free (SndRcv * p)
{
  char name[strlen(p->rcv->name) + 1];
  strcpy (name, p->rcv->name);
  rcv_pid_destroy (p->rcv);
  p->rcv = rcv_pid_new (name);
  strcpy (name, p->snd->name);
  rcv_pid_destroy (p->snd);
  p->snd = rcv_pid_new (name);
}

static bool is_root (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 698 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))     
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
      
#line 700 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_local(cell))
 return true;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}
  
#line 702 "/home/spencer/basilisk/src/grid/tree-mpi.h"
return false;
}


static bool is_local_prolongation (Point point, Point p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

  
#line 709 "/home/spencer/basilisk/src/grid/tree-mpi.h"
struct { int x, y; } dp = {p.i - point.i, p.j - point.j};



   {
    if (dp.x == 0 && ((!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0) || (!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0)))
      return true;
    if ((!is_leaf (neighbor(dp.x,0,0)) && neighbor(dp.x,0,0).neighbors && neighbor(dp.x,0,0).pid >= 0))
      return true;
  } 
#line 713
{
    if (dp.y == 0 && ((!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0) || (!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0)))
      return true;
    if ((!is_leaf (neighbor(0,dp.y,0)) && neighbor(0,dp.y,0).neighbors && neighbor(0,dp.y,0).pid >= 0))
      return true;
  }
  return false;
}



static void append_pid (Array * pids, int pid)
{
  for (int i = 0, * p = (int *) pids->p; i < pids->len/sizeof(int); i++, p++)
    if (*p == pid)
      return;
  array_append (pids, &pid, sizeof(int));
}

static int locals_pids (Point point, Array * pids)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 734 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_leaf(cell)) {
    if (is_local(cell)) {
      Point p = point;      
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 737 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
 if ((cell.pid >= 0 && cell.pid != pid()) &&
     ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) || is_local_prolongation (point, p)))
   append_pid (pids, cell.pid);
 if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))    
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 743 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((cell.pid >= 0 && cell.pid != pid()))
       append_pid (pids, cell.pid);      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}
      
#line 745 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 746 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
  }
  else     
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
{
  {
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 749 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
      if ((cell.pid >= 0 && cell.pid != pid()))
 append_pid (pids, cell.pid);
      if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0))  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 754 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((cell.pid >= 0 && cell.pid != pid()))
     append_pid (pids, cell.pid);      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}
    
#line 756 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
}
  
#line 757 "/home/spencer/basilisk/src/grid/tree-mpi.h"
return pids->len/sizeof(int);
}

static int root_pids (Point point, Array * pids)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 763 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((cell.pid >= 0 && cell.pid != pid()))
      append_pid (pids, cell.pid);      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 765 "/home/spencer/basilisk/src/grid/tree-mpi.h"
return pids->len/sizeof(int);
}







static void rcv_pid_row (RcvPid * m, int l, int * row)
{
  for (int i = 0; i < npe(); i++)
    row[i] = 0;
  for (int i = 0; i < m->npid; i++) {
    Rcv * rcv = &m->rcv[i];
    if (l <= rcv->depth && rcv->halo[l].n > 0)
      row[rcv->pid] = rcv->halo[l].n;
  }
}

void check_snd_rcv_matrix (SndRcv * sndrcv, const char * name)
{
  int maxlevel = depth();
  mpi_all_reduce (maxlevel, MPI_INT, MPI_MAX);
  int * row = ((int *) pmalloc ((npe())*sizeof(int),__func__,__FILE__,__LINE__));
  for (int l = 0; l <= maxlevel; l++) {
    int status = 0;
    if (pid() == 0) {


      int ** send = matrix_new (npe(), npe(), sizeof(int));
      int ** receive = matrix_new (npe(), npe(), sizeof(int));
      rcv_pid_row (sndrcv->snd, l, row);
      MPI_Gather (row, npe(), MPI_INT, &send[0][0], npe(), MPI_INT, 0,
    MPI_COMM_WORLD);
      rcv_pid_row (sndrcv->rcv, l, row);
      MPI_Gather (row, npe(), MPI_INT, &receive[0][0], npe(), MPI_INT, 0,
    MPI_COMM_WORLD);

      int * astatus = ((int *) pmalloc ((npe())*sizeof(int),__func__,__FILE__,__LINE__));
      for (int i = 0; i < npe(); i++)
 astatus[i] = 0;
      for (int i = 0; i < npe(); i++)
 for (int j = 0; j < npe(); j++)
   if (send[i][j] != receive[j][i]) {
     fprintf (ferr, "%s: %d sends    %d to   %d at level %d\n",
       name, i, send[i][j], j, l);
     fprintf (ferr, "%s: %d receives %d from %d at level %d\n",
       name, j, receive[j][i], i, l);
     fflush (ferr);
     for (int k = i - 2; k <= i + 2; k++)
       if (k >= 0 && k < npe())
  astatus[k] = 1;
     for (int k = j - 2; k <= j + 2; k++)
       if (k >= 0 && k < npe())
  astatus[k] = 1;
   }
      MPI_Scatter (astatus, 1, MPI_INT, &status, 1, MPI_INT, 0, MPI_COMM_WORLD);
      pfree (astatus,__func__,__FILE__,__LINE__);

      matrix_free (send);
      matrix_free (receive);
    }
    else {
      rcv_pid_row (sndrcv->snd, l, row);
      MPI_Gather (row, npe(), MPI_INT, NULL, npe(), MPI_INT, 0, MPI_COMM_WORLD);
      rcv_pid_row (sndrcv->rcv, l, row);
      MPI_Gather (row, npe(), MPI_INT, NULL, npe(), MPI_INT, 0, MPI_COMM_WORLD);
      MPI_Scatter (NULL, 1, MPI_INT, &status, 1, MPI_INT, 0, MPI_COMM_WORLD);
    }
    if (status) {
      fprintf (ferr,
        "check_snd_rcv_matrix \"%s\" failed\n"
        "Calling debug_mpi(NULL)...\n"
        "Aborting...\n",
        name);
      fflush (ferr);
      debug_mpi (NULL);
      MPI_Abort (MPI_COMM_WORLD, -3);
    }
  }
  pfree (row,__func__,__FILE__,__LINE__);
}

static bool has_local_child (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 852 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_local(cell))
      return true;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 854 "/home/spencer/basilisk/src/grid/tree-mpi.h"
return false;
}

     
void mpi_boundary_update_buffers()
{tracing("mpi_boundary_update_buffers","/home/spencer/basilisk/src/grid/tree-mpi.h",858);
  if (npe() == 1)
    {end_tracing("mpi_boundary_update_buffers","/home/spencer/basilisk/src/grid/tree-mpi.h",861);return;}

  prof_start ("mpi_boundary_update_buffers");

  MpiBoundary * m = (MpiBoundary *) mpi_boundary;
  SndRcv * mpi_level = &m->mpi_level;
  SndRcv * mpi_level_root = &m->mpi_level_root;
  SndRcv * restriction = &m->restriction;

  snd_rcv_free (mpi_level);
  snd_rcv_free (mpi_level_root);
  snd_rcv_free (restriction);

  static const unsigned short used = 1 << user;
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 875 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 875 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    if (is_active(cell) && !is_border(cell))



      continue;

    if (cell.neighbors) {

      Array pids = {NULL, 0, 0};
      int n = locals_pids (point, &pids);
      if (n) { 
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 888 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_local(cell))
     for (int i = 0, * p = (int *) pids.p; i < n; i++, p++)
       rcv_pid_append (mpi_level->snd, *p, point);      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
 
#line 891 "/home/spencer/basilisk/src/grid/tree-mpi.h"
pfree (pids.p,__func__,__FILE__,__LINE__);
      }

      bool locals = false;
      if (is_leaf(cell)) {
 if ((cell.pid >= 0 && cell.pid != pid())) {
   Point p = point;   
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 899 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((is_local(cell) &&
   ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) || is_local_prolongation (point, p))) ||
  is_root(point)) {
       locals = true;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 902 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
     }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
 
#line 904 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
      }
      else  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
{
  {
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 908 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_local(cell) || is_root(point)) {
     locals = true;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 909 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
   }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
}
      
#line 911 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (locals)  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 913 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((cell.pid >= 0 && cell.pid != pid()))
            rcv_pid_append (mpi_level->rcv, cell.pid, point),
       cell.flags |= used;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}


      
#line 918 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!is_leaf(cell)) {

 if (is_local(cell)) {
   Array pids = {NULL, 0, 0};

   int n = root_pids (point, &pids);
   if (n) {     
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
       
#line 926 "/home/spencer/basilisk/src/grid/tree-mpi.h"
for (int i = 0, * p = (int *) pids.p; i < n; i++, p++)
  if (cell.pid >= 0 && cell.pid != *p)
    rcv_pid_append (mpi_level_root->snd, *p, point);      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }

     
#line 930 "/home/spencer/basilisk/src/grid/tree-mpi.h"
for (int i = 0, * p = (int *) pids.p; i < n; i++, p++)
       rcv_pid_append (restriction->snd, *p, point);
     pfree (pids.p,__func__,__FILE__,__LINE__);
   }
 }

 else if ((cell.pid >= 0 && cell.pid != pid())) {
   bool root = false;   
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 939 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_local(cell)) {
       root = true;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 940 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
     }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
   
#line 942 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (root) {
     int pid = cell.pid;     
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
       
#line 945 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((cell.pid >= 0 && cell.pid != pid()))
  rcv_pid_append (mpi_level_root->rcv, pid, point),
    cell.flags |= used;      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }

     
#line 949 "/home/spencer/basilisk/src/grid/tree-mpi.h"
rcv_pid_append (restriction->rcv, pid, point);
   }
 }
      }
    }


    if (level > 0) {
      if (is_local(cell)) {

 Array pids = {NULL, 0, 0};
 if ((aparent(0,0,0).pid >= 0 && aparent(0,0,0).pid != pid()))
   append_pid (&pids, aparent(0,0,0).pid);
 int n = root_pids (parent, &pids);
 if (n) {
   for (int i = 0, * p = (int *) pids.p; i < n; i++, p++)
     rcv_pid_append (restriction->snd, *p, point);
   pfree (pids.p,__func__,__FILE__,__LINE__);
 }
      }
      else if ((cell.pid >= 0 && cell.pid != pid())) {

 if (is_local(aparent(0,0,0)) || has_local_child (parent))
   rcv_pid_append (restriction->rcv, cell.pid, point);
      }
    }
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}





  
#line 981 "/home/spencer/basilisk/src/grid/tree-mpi.h"
static const unsigned short keep = 1 << (user + 1);
  for (int l = depth(); l >= 0; l--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
      
#line 984 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 984 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (level == l) {
 if (level > 0 && (cell.pid < 0 || is_local(cell) || (cell.flags & used)))
   aparent(0,0,0).flags |= keep;
 if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) && !(cell.flags & keep))
   coarsen_cell (point, NULL);
 cell.flags &= ~(used|keep);
 continue;
      }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}


  
#line 994 "/home/spencer/basilisk/src/grid/tree-mpi.h"
m->send->len = m->receive->len = 0;
  rcv_pid_append_pids (mpi_level->snd, m->send);
  rcv_pid_append_pids (mpi_level_root->snd, m->send);
  rcv_pid_append_pids (mpi_level->rcv, m->receive);
  rcv_pid_append_pids (mpi_level_root->rcv, m->receive);

  prof_stop();
#line 1015 "/home/spencer/basilisk/src/grid/tree-mpi.h"
end_tracing("mpi_boundary_update_buffers","/home/spencer/basilisk/src/grid/tree-mpi.h",1015);}

     
void mpi_boundary_refine (scalar * list)
{tracing("mpi_boundary_refine","/home/spencer/basilisk/src/grid/tree-mpi.h",1018);
  prof_start ("mpi_boundary_refine");

  MpiBoundary * mpi = (MpiBoundary *) mpi_boundary;


  Array * snd = mpi->send;
  MPI_Request r[2*snd->len/sizeof(int)];
  int nr = 0;
  for (int i = 0, * dest = snd->p; i < snd->len/sizeof(int); i++,dest++) {
    int len = ((Tree *)grid)->refined.n;
    MPI_Isend (&((Tree *)grid)->refined.n, 1, MPI_INT, *dest,
        (128), MPI_COMM_WORLD, &r[nr++]);
    if (len > 0)
      MPI_Isend (((Tree *)grid)->refined.p, sizeof(Index)/sizeof(int)*len,
   MPI_INT, *dest, (128), MPI_COMM_WORLD, &r[nr++]);
  }



  Array * rcv = mpi->receive;
  Cache rerefined = {NULL, 0, 0};
  for (int i = 0, * source = rcv->p; i < rcv->len/sizeof(int); i++,source++) {
    int len;
    mpi_recv_check (&len, 1, MPI_INT, *source, (128),
      MPI_COMM_WORLD, MPI_STATUS_IGNORE,
      "mpi_boundary_refine (len)");
    if (len > 0) {
      Index p[len];
      mpi_recv_check (p, sizeof(Index)/sizeof(int)*len,
        MPI_INT, *source, (128),
        MPI_COMM_WORLD, MPI_STATUS_IGNORE,
        "mpi_boundary_refine (p)");
      Cache refined = {p, len, len};
#line 423 "/home/spencer/basilisk/src/grid/tree.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < refined.n; _k++) {
 point.i = refined.p[_k].i;

 point.j = refined.p[_k].j;




 point.level = refined.p[_k].level;
 _flags = refined.p[_k].flags;
 
#line 1054 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1054 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (level <= depth() && allocated(0,0,0)) {
   if (is_leaf(cell)) {
     bool neighbors = false;     
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
       
#line 1058 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (allocated(0,0,0) && (is_active(cell) || is_local(aparent(0,0,0)))) {
  neighbors = true;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 1059 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
       }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }

     
#line 1062 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (neighbors)
       refine_cell (point, list, 0, &rerefined);
   }
 }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
    
#line 1066 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
  }


  if (nr)
    MPI_Waitall (nr, r, MPI_STATUSES_IGNORE);


  pfree (((Tree *)grid)->refined.p,__func__,__FILE__,__LINE__);
  ((Tree *)grid)->refined = rerefined;

  prof_stop();



  mpi_all_reduce (rerefined.n, MPI_INT, MPI_SUM);
  if (rerefined.n)
    mpi_boundary_refine (list);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = true;}}
end_tracing("mpi_boundary_refine","/home/spencer/basilisk/src/grid/tree-mpi.h",1086);}

static void check_depth()
{
#line 1121 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}

typedef struct {
  int refined, leaf;
} Remote;



     
void mpi_boundary_coarsen (int l, int too_fine)
{tracing("mpi_boundary_coarsen","/home/spencer/basilisk/src/grid/tree-mpi.h",1130);
  if (npe() == 1)
    {end_tracing("mpi_boundary_coarsen","/home/spencer/basilisk/src/grid/tree-mpi.h",1133);return;}

  check_depth();

  if (!(sizeof(Remote) == sizeof(double))) qassert ("/home/spencer/basilisk/src/grid/tree-mpi.h", 1137, "sizeof(Remote) == sizeof(double)");

  scalar  remote=new_scalar("remote");
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1140 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1140 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    if (level == l) {
      if (is_local(cell)) {
 ((Remote *)&val(remote,0,0,0))->refined = (!is_leaf (cell) && cell.neighbors && cell.pid >= 0);
 ((Remote *)&val(remote,0,0,0))->leaf = is_leaf(cell);
      }
      else {
 ((Remote *)&val(remote,0,0,0))->refined = true;
 ((Remote *)&val(remote,0,0,0))->leaf = false;
      }
      continue;
    }
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 1155 "/home/spencer/basilisk/src/grid/tree-mpi.h"
mpi_boundary_level (mpi_boundary,((scalar[]) {remote,{-1}}), l);
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1157 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1157 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    if (level == l) {
      if (!is_local(cell)) {
 if ((!is_leaf (cell) && cell.neighbors && cell.pid >= 0) && !((Remote *)&val(remote,0,0,0))->refined)
   coarsen_cell_recursive (point, NULL);
 else if (is_leaf(cell) && cell.neighbors && ((Remote *)&val(remote,0,0,0))->leaf) {
   int pid = cell.pid;   
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 1165 "/home/spencer/basilisk/src/grid/tree-mpi.h"
cell.pid = pid;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
 
#line 1166 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
      }
      continue;
    }
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

  
#line 1174 "/home/spencer/basilisk/src/grid/tree-mpi.h"
check_depth();

  if (l > 0) {
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1177 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1177 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
      if (level == l) {
 val(remote,0,0,0) = is_local(cell) ? cell.neighbors : 0;
 continue;
      }
      if (is_leaf(cell))
 continue;
    }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
    
#line 1185 "/home/spencer/basilisk/src/grid/tree-mpi.h"
mpi_boundary_level (mpi_boundary,((scalar[]) {remote,{-1}}), l);
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1186 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1186 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
      if (level == l)
 if (!is_local(cell) && is_local(aparent(0,0,0)) && val(remote,0,0,0)) {
   aparent(0,0,0).flags &= ~too_fine;
   continue;
 }
      if (is_leaf(cell))
 continue;
    }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 1195 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}delete((scalar*)((scalar[]){remote,{-1}}));
end_tracing("mpi_boundary_coarsen","/home/spencer/basilisk/src/grid/tree-mpi.h",1196);}

static void flag_border_cells()
{
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1200 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1200 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    if (is_active(cell)) {
      short flags = cell.flags & ~border;      
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 1203 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
 if (!is_local(cell) || (level > 0 && !is_local(aparent(0,0,0)))) {
   flags |= border;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 1205 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
 }

 if (is_refined_check())    
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 1210 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!is_local(cell)) {
       flags |= border;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 1211 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
     }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}
 
#line 1213 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (flags & border)   
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 1214 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
      }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
      
#line 1216 "/home/spencer/basilisk/src/grid/tree-mpi.h"
cell.flags = flags;
    }
    else {
      cell.flags &= ~border;

    }
    if (is_leaf(cell)) {
      if (cell.neighbors) { 
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 1225 "/home/spencer/basilisk/src/grid/tree-mpi.h"
cell.flags &= ~border;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
 
#line 1226 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_border(cell)) {
   bool remote = false;   
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = (
#line 1228 "/home/spencer/basilisk/src/grid/tree-mpi.h"
2/2
#line 19 "/home/spencer/basilisk/src/grid/neighbors.h"
);
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 1229 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (!is_local(cell)) {
       remote = true;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 1230 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
     }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
   
#line 1232 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (remote)      
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
       
#line 1234 "/home/spencer/basilisk/src/grid/tree-mpi.h"
cell.flags |= border;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}
 
#line 1235 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
      }
      continue;
    }
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

#line 1240 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}

static int balanced_pid (long index, long nt, int nproc)
{
  long ne = ( 1 > (nt/nproc) ? 1 : (nt/nproc)), nr = nt % nproc;
  int pid = index < nr*(ne + 1) ?
    index/(ne + 1) :
    nr + (index - nr*(ne + 1))/ne;
  return ( (nproc - 1) < pid ? (nproc - 1) : pid);
}


     
void mpi_partitioning()
{tracing("mpi_partitioning","/home/spencer/basilisk/src/grid/tree-mpi.h",1253);
  prof_start ("mpi_partitioning");

  long nt = 0; 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;
    
#line 1259 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1259 "/home/spencer/basilisk/src/grid/tree-mpi.h"
nt++;}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}


  
#line 1262 "/home/spencer/basilisk/src/grid/tree-mpi.h"
long i = 0;
  ((Tree *)grid)->dirty = true;
#line 255 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 156
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   if ((
#line 264
(
#line 1264 "/home/spencer/basilisk/src/grid/tree-mpi.h"
is_active (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 182
))
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }







      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 if ((
#line 264
(
#line 1264 "/home/spencer/basilisk/src/grid/tree-mpi.h"
is_active (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 196
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 if ((
#line 264
(
#line 1264 "/home/spencer/basilisk/src/grid/tree-mpi.h"
is_active (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 201
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };
 if ((
#line 264
(
#line 1264 "/home/spencer/basilisk/src/grid/tree-mpi.h"
is_active (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 206
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
#line 246 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      default:
    
#line 1265 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1265 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_active (cell)) {
      if (is_leaf (cell)) {
 cell.pid = balanced_pid (i++, nt, npe());
 if (cell.neighbors > 0) {
   int pid = cell.pid;   
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 1271 "/home/spencer/basilisk/src/grid/tree-mpi.h"
cell.pid = pid;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
 
#line 1272 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
 if (!is_local(cell))
   cell.flags &= ~active;
      }
      else {
 cell.pid = child(0,0,0).pid;
 bool inactive = true; 
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 1280 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_active(cell)) {
     inactive = false;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 1281 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
   }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
 
#line 1283 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (inactive)
   cell.flags &= ~active;
      }
    }}      
#line 249 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
    }
  }
}
  
#line 266
}
}

  
#line 1288 "/home/spencer/basilisk/src/grid/tree-mpi.h"
flag_border_cells();

  prof_stop();

  mpi_boundary_update_buffers();
end_tracing("mpi_partitioning","/home/spencer/basilisk/src/grid/tree-mpi.h",1293);}

void restore_mpi (FILE * fp, scalar * list1)
{
  long index = 0, nt = 0, start = ftell (fp);
  scalar  size=new_scalar("size"), * list = list_concat (((scalar[]){size,{-1}}), list1);;
  long offset = sizeof(double)*list_len(list);


  static const unsigned short set = 1 << user;
  scalar * listm = is_constant(cm) ? NULL : (scalar *)((vector[]){fm,{{-1},{-1}}});
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
    
#line 1305 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1305 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (balanced_pid (index, nt, npe()) <= pid()) {
      unsigned flags;
      if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
 fprintf (ferr, "restore(): error: expecting 'flags'\n");
 exit (1);
      }
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
 double val;
 if (fread (&val, sizeof(double), 1, fp) != 1) {
   fprintf (ferr, "restore(): error: expecting scalar\n");
   exit (1);
 }
 if (s.i != INT_MAX)
   val(s,0,0,0) = val;
      }}}
      if (level == 0)
 nt = val(size,0,0,0);
      cell.pid = balanced_pid (index, nt, npe());
      cell.flags |= set;
      if (!(flags & leaf) && is_leaf(cell)) {
 if (balanced_pid (index + val(size,0,0,0) - 1, nt, npe()) < pid()) {
   fseek (fp, (sizeof(unsigned) + offset)*(val(size,0,0,0) - 1), SEEK_CUR);
   index += val(size,0,0,0);
   continue;
 }
 refine_cell (point, listm, 0, NULL);
      }
      index++;
      if (is_leaf(cell))
 continue;
    }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}


  
#line 1338 "/home/spencer/basilisk/src/grid/tree-mpi.h"
fseek (fp, start, SEEK_SET);
  index = 0;
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1340 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1340 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    unsigned flags;
    if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
      fprintf (ferr, "restore(): error: expecting 'flags'\n");
      exit (1);
    }
    if (cell.flags & set)
      fseek (fp, offset, SEEK_CUR);
    else {
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
 double val;
 if (fread (&val, sizeof(double), 1, fp) != 1) {
   fprintf (ferr, "restore(): error: expecting a scalar\n");
   exit (1);
 }
 if (s.i != INT_MAX)
   val(s,0,0,0) = val;
      }}}
      cell.pid = balanced_pid (index, nt, npe());
      if (is_leaf(cell) && cell.neighbors) {
 int pid = cell.pid; 
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 1362 "/home/spencer/basilisk/src/grid/tree-mpi.h"
cell.pid = pid;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
      
#line 1363 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
    }
    if (!(flags & leaf) && is_leaf(cell)) {
      bool locals = false;      
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 1368 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if ((cell.flags & set) && (is_local(cell) || is_root(point))) {
   locals = true;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 1369 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
 }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
      
#line 1371 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (locals)
 refine_cell (point, listm, 0, NULL);
      else {
 fseek (fp, (sizeof(unsigned) + offset)*(val(size,0,0,0) - 1), SEEK_CUR);
 index += val(size,0,0,0);
 continue;
      }
    }
    index++;
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

#line 255
{
  {



    Point root = {2,2,0};
#line 156
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   if ((
#line 264
(
#line 1385 "/home/spencer/basilisk/src/grid/tree-mpi.h"
is_active (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 182
))
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }







      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 if ((
#line 264
(
#line 1385 "/home/spencer/basilisk/src/grid/tree-mpi.h"
is_active (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 196
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 if ((
#line 264
(
#line 1385 "/home/spencer/basilisk/src/grid/tree-mpi.h"
is_active (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 201
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };
 if ((
#line 264
(
#line 1385 "/home/spencer/basilisk/src/grid/tree-mpi.h"
is_active (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 206
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
#line 246 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      default: 
#line 1385 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1385 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
    cell.flags &= ~set;
    if (is_active (cell)) {
      if (is_leaf (cell)) {
 if (cell.neighbors > 0) {
   int pid = cell.pid;   
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 1392 "/home/spencer/basilisk/src/grid/tree-mpi.h"
cell.pid = pid;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
 
#line 1393 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
 if (!is_local(cell))
   cell.flags &= ~active;
      }
      else if (!is_local(cell)) {
 bool inactive = true; 
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 1400 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_active(cell)) {
     inactive = false;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 1401 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
   }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
 
#line 1403 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (inactive)
   cell.flags &= ~active;
      }
    }
  }}      
#line 249 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
    }
  }
}
  
#line 266
}
}

  
#line 1409 "/home/spencer/basilisk/src/grid/tree-mpi.h"
flag_border_cells();

  mpi_boundary_update (list);
  pfree (list,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){size,{-1}}));
}
#line 1435 "/home/spencer/basilisk/src/grid/tree-mpi.h"
     
double z_indexing (scalar index, bool leaves)
{tracing("z_indexing","/home/spencer/basilisk/src/grid/tree-mpi.h",1436);



  scalar  size=new_scalar("size");
  subtree_size (size, leaves);






  double maxi = -1.;
  if (pid() == 0) 
#line 53 "/home/spencer/basilisk/src/grid/config.h"
{
#line 1451 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
      
#line 1452 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{ _stencil_val(size,0,0,0);   }  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (0 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[0];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = 0;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 1452 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1452 "/home/spencer/basilisk/src/grid/tree-mpi.h"
maxi = val(size,0,0,0) - 1.;}      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 1452 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
#line 53 "/home/spencer/basilisk/src/grid/config.h"
}
  




  
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 1458 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{_stencil_val_a(index,0,0,0);  }  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (0 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[0];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = 0;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
    
#line 1458 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1458 "/home/spencer/basilisk/src/grid/tree-mpi.h"
val(index,0,0,0) = 0;}      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
  
#line 1459 "/home/spencer/basilisk/src/grid/tree-mpi.h"
for (int l = 0; l < depth(); l++) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b,((scalar[]) {index,{-1}}), l); };
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1461 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1461 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
      if (level == l) {
 if (is_leaf(cell)) {
   if (is_local(cell) && cell.neighbors) {
     int i = val(index,0,0,0);     
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
       
#line 1467 "/home/spencer/basilisk/src/grid/tree-mpi.h"
val(index,0,0,0) = i;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
   
#line 1468 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
 }
 else {
   bool loc = is_local(cell);
   if (!loc)      
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
       
#line 1474 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (is_local(cell)) {
  loc = true;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 1475 "/home/spencer/basilisk/src/grid/tree-mpi.h"
;
       }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}
   
#line 1477 "/home/spencer/basilisk/src/grid/tree-mpi.h"
if (loc) {
     int i = val(index,0,0,0) + !leaves;     
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 1479 "/home/spencer/basilisk/src/grid/tree-mpi.h"
{
       val(index,0,0,0) = i;
       i += val(size,0,0,0);
     }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
   
#line 1483 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
 }
 continue;
      }
      if (is_leaf(cell))
 continue;
    }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 1490 "/home/spencer/basilisk/src/grid/tree-mpi.h"
}
  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b,((scalar[]) {index,{-1}}), depth()); };

  {delete((scalar*)((scalar[]){size,{-1}}));{end_tracing("z_indexing","/home/spencer/basilisk/src/grid/tree-mpi.h",1493);return maxi;}}delete((scalar*)((scalar[]){size,{-1}}));
end_tracing("z_indexing","/home/spencer/basilisk/src/grid/tree-mpi.h",1494);}
#line 1738 "/home/spencer/basilisk/src/grid/tree.h"
#line 1 "grid/balance.h"
#line 1 "/home/spencer/basilisk/src/grid/balance.h"


typedef struct {
  short leaf, prolongation;
  int pid;
} NewPid;



#if TRASH
# define is_newpid() (!isnan(val(newpid,0,0,0)) && ((NewPid *)&val(newpid,0,0,0))->pid > 0)
#else
# define is_newpid() (((NewPid *)&val(newpid,0,0,0))->pid > 0)
#endif

Array * linear_tree (size_t size, scalar newpid)
{
  const unsigned short sent = 1 << user, next = 1 << (user + 1);
  Array * a = array_new();

#line 270 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    Point root = {0};
    for (root.i = 0; root.i <= 2*2; root.i++)

      for (root.j = 0; root.j <= 2*2; root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 156 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   if (true)
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }







      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 if (true)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 if (true)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };
 if (true)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
#line 246 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      default:    
#line 22 "/home/spencer/basilisk/src/grid/balance.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 22 "/home/spencer/basilisk/src/grid/balance.h"
if (level > 0 && (cell.flags & (sent|next)))
      aparent(0,0,0).flags |= next;}

      
#line 249 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 282 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}  
#line 25 "/home/spencer/basilisk/src/grid/balance.h"
bool empty = true; 
#line 140 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    Point root = {0};
    for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)

      for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 67 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 26 "/home/spencer/basilisk/src/grid/balance.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 26 "/home/spencer/basilisk/src/grid/balance.h"
{
    if (cell.flags & sent) {
      array_append (a, &cell, size);
      cell.flags &= ~sent;
      empty = false;
    }
    else {
      if (cell.pid >= 0 && ((NewPid *)&val(newpid,0,0,0))->leaf)
 if (!(is_leaf(cell))) qassert ("/home/spencer/basilisk/src/grid/balance.h", 34, "is_leaf(cell)");
      if (is_refined_check()) {


 bool prolo = false;
  
 
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 40 "/home/spencer/basilisk/src/grid/balance.h"
if (((NewPid *)&val(newpid,0,0,0))->prolongation)
     prolo = true;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  } 
#line 42 "/home/spencer/basilisk/src/grid/balance.h"
if (prolo) {

   cell.flags |= leaf;
   array_append (a, &cell, sizeof(Cell));
   cell.flags &= ~leaf;
 }
 else
   array_append (a, &cell, sizeof(Cell));
      }
      else
 array_append (a, &cell, sizeof(Cell));
    }
    if (cell.flags & next)
      cell.flags &= ~next;
    else
      continue;
  }}

 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 152 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}  
#line 60 "/home/spencer/basilisk/src/grid/balance.h"
if (empty)
    a->len = 0;
  return a;
}

void macro_foreach_tree (Array * t, size_t size, scalar * list, scalar newpid)
{
  {
    const unsigned short _sent = 1 << user, _next = 1 << (user + 1);
    scalar * _list = list;
    char * _i = (char *) (t)->p; 
#line 140 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    Point root = {0};
    for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)

      for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 67 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 71 "/home/spencer/basilisk/src/grid/balance.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 71 "/home/spencer/basilisk/src/grid/balance.h"
{
      Cell * c = (Cell *) _i;
      if (c->flags & _sent) {
 _i += size;
 ;
      }
      else
 _i += sizeof(Cell);
      if (c->flags & _next) {
 if (!(c->neighbors)) qassert ("/home/spencer/basilisk/src/grid/balance.h", 80, "c->neighbors");
 if (!(c->flags & leaf) && is_leaf(cell) &&
     (!is_newpid() || !((NewPid *)&val(newpid,0,0,0))->leaf))

   refine_cell (point, _list, 0, NULL);
 else if (!cell.neighbors)

   alloc_children (point);
      }
      else
 continue;
    }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 152 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}  
#line 92 "/home/spencer/basilisk/src/grid/balance.h"
}
}

Array * neighborhood (scalar newpid, int nextpid, FILE * fp)
{
  const unsigned short sent = 1 << user;

#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 98 "/home/spencer/basilisk/src/grid/balance.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 98 "/home/spencer/basilisk/src/grid/balance.h"
{

    bool root = false;
    if ((!is_local(cell) || ((NewPid *)&val(newpid,0,0,0))->pid - 1 != nextpid) && (!is_leaf (cell) && cell.neighbors && cell.pid >= 0)) {
  
      
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 103 "/home/spencer/basilisk/src/grid/balance.h"
if (is_local(cell) && ((NewPid *)&val(newpid,0,0,0))->pid - 1 == nextpid) {
   root = true;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 104 "/home/spencer/basilisk/src/grid/balance.h"
;
 }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }      
#line 106 "/home/spencer/basilisk/src/grid/balance.h"
if (root && cell.pid != nextpid) { 
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 108 "/home/spencer/basilisk/src/grid/balance.h"
if (cell.pid != nextpid && is_newpid()) {
     if (fp)
       fprintf (fp, "%g %g %g %d %d root\n",
         x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid);
     cell.flags |= sent;
   }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
      
#line 114 "/home/spencer/basilisk/src/grid/balance.h"
}
    }

    if ((is_local(cell) && ((NewPid *)&val(newpid,0,0,0))->pid - 1 == nextpid) || root) {      
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 119 "/home/spencer/basilisk/src/grid/balance.h"
if (cell.neighbors && cell.pid != nextpid)
    
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;     
#line 121 "/home/spencer/basilisk/src/grid/balance.h"
if (cell.pid != nextpid && is_newpid()) {
       if (fp)
  fprintf (fp, "%g %g %g %d %d nextpid\n",
    x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid);
       cell.flags |= sent;
     }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 127 "/home/spencer/basilisk/src/grid/balance.h"
}
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}  
#line 132 "/home/spencer/basilisk/src/grid/balance.h"
return linear_tree (sizeof(Cell) + datasize, newpid);
}

static void send_tree (Array * a, int to, MPI_Request * r)
{
  MPI_Isend (&a->len, 1, MPI_LONG, to, (256), MPI_COMM_WORLD, &r[0]);
  if (a->len > 0) {
    MPI_Isend (a->p, a->len, MPI_BYTE, to, (256), MPI_COMM_WORLD, &r[1]);
    ((Tree *)grid)->dirty = true;
  }
}

static void receive_tree (int from, scalar newpid, FILE * fp)
{
  Array a;
  mpi_recv_check (&a.len, 1, MPI_LONG, from, (256),
    MPI_COMM_WORLD, MPI_STATUS_IGNORE, "receive_tree (len)");
  if (a.len > 0) {
    a.p = pmalloc (a.len,__func__,__FILE__,__LINE__);
    if (fp)
      fprintf (fp, "receiving %ld from %d\n", a.len, from);
    mpi_recv_check (a.p, a.len, MPI_BYTE, from, (256),
      MPI_COMM_WORLD, MPI_STATUS_IGNORE, "receive_tree (p)");
#line 66
{
  {
    const unsigned short _sent = 1 << user, _next = 1 << (user + 1);
    scalar * _list = NULL;
    char * _i = (char *) ((
#line 156
&a
#line 70
))->p; 
#line 140 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    Point root = {0};
    for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)

      for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 67 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 71 "/home/spencer/basilisk/src/grid/balance.h"
{
      Cell * c = (Cell *) _i;
      if (c->flags & _sent) {
 _i += (
#line 156
sizeof(Cell) + datasize
#line 74
); 
#line 156
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "/home/spencer/basilisk/src/grid/balance.h"
{
      memcpy (((char *)&cell) + sizeof(Cell), ((char *)c) + sizeof(Cell),
       datasize);
      if (!(((NewPid *)&val(newpid,0,0,0))->pid > 0)) qassert ("/home/spencer/basilisk/src/grid/balance.h", 159, "NEWPID()->pid > 0");
      if (fp)
 fprintf (fp, "%g %g %g %d %d %d %d %d %d recv\n",
   x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid,
   c->flags & leaf,
   cell.flags & leaf, from, ((NewPid *)&val(newpid,0,0,0))->leaf);
    }}      
#line 76
}
      else
 _i += sizeof(Cell);
      if (c->flags & _next) {
 if (!(c->neighbors)) qassert ("/home/spencer/basilisk/src/grid/balance.h", 80, "c->neighbors");
 if (!(c->flags & leaf) && is_leaf(cell) &&
     (!is_newpid() || !((NewPid *)&val(newpid,0,0,0))->leaf))

   refine_cell (point, _list, 0, NULL);
 else if (!cell.neighbors)

   alloc_children (point);
      }
      else
 continue;
    } 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 152 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}  
#line 92 "/home/spencer/basilisk/src/grid/balance.h"
}
}
    
#line 166
pfree (a.p,__func__,__FILE__,__LINE__);
    ((Tree *)grid)->dirty = true;
  }
}

static void wait_tree (Array * a, MPI_Request * r)
{
  MPI_Wait (&r[0], MPI_STATUS_IGNORE);
  if (a->len > 0)
    MPI_Wait (&r[1], MPI_STATUS_IGNORE);
}

static void check_flags()
{







}

struct {
  int min;
  bool leaves;

  int npe;
} mpi = {
  1,
  true
};

     
bool balance()
{tracing("balance","/home/spencer/basilisk/src/grid/balance.h",200);
  if (npe() == 1)
    {end_tracing("balance","/home/spencer/basilisk/src/grid/balance.h",203);return false;}

  if (!(sizeof(NewPid) == sizeof(double))) qassert ("/home/spencer/basilisk/src/grid/balance.h", 205, "sizeof(NewPid) == sizeof(double)");

  check_flags();

  long nl = 0, nt = 0;
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 210 "/home/spencer/basilisk/src/grid/balance.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 210 "/home/spencer/basilisk/src/grid/balance.h"
{
    if (is_local(cell)) {
      nt++;
      if (is_leaf(cell))
 nl++;
    }
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

  
#line 220 "/home/spencer/basilisk/src/grid/balance.h"
grid->n = grid->tn = nl;
  grid->maxdepth = depth();
  long nmin = nl, nmax = nl;

  mpi_all_reduce (nmax, MPI_LONG, MPI_MAX);
  mpi_all_reduce (nmin, MPI_LONG, MPI_MIN);
  mpi_all_reduce (grid->tn, MPI_LONG, MPI_SUM);
  mpi_all_reduce (grid->maxdepth, MPI_INT, MPI_MAX);
  if (mpi.leaves)
    nt = grid->tn;
  else
    mpi_all_reduce (nt, MPI_LONG, MPI_SUM);

  long ne = ( 1 > (nt/npe()) ? 1 : (nt/npe()));

  if (ne < mpi.min) {
    mpi.npe = ( 1 > (nt/mpi.min) ? 1 : (nt/mpi.min));
    ne = ( 1 > (nt/mpi.npe) ? 1 : (nt/mpi.npe));
  }
  else
    mpi.npe = npe();

  if (nmax - nmin <= 1)
    {end_tracing("balance","/home/spencer/basilisk/src/grid/balance.h",243);return false;}

  scalar  newpid=new_scalar("newpid");
  double zn = z_indexing (newpid, mpi.leaves);
  if (pid() == 0)
    if (!(zn + 1 == nt)) qassert ("/home/spencer/basilisk/src/grid/balance.h", 248, "zn + 1 == nt");

  FILE * fp = NULL;
#line 260 "/home/spencer/basilisk/src/grid/balance.h"
  bool next = false, prev = false; 
#line 140 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    Point root = {0};
    for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)

      for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 67 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 261 "/home/spencer/basilisk/src/grid/balance.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 261 "/home/spencer/basilisk/src/grid/balance.h"
{
    if (is_local(cell)) {
      int pid = balanced_pid (val(newpid,0,0,0), nt, mpi.npe);
      pid = ( pid < (cell.pid - 1) ? (cell.pid - 1) : pid > (cell.pid + 1) ? (cell.pid + 1) : pid);
      if (pid == pid() + 1)
 next = true;
      else if (pid == pid() - 1)
 prev = true;
      ((NewPid *)&val(newpid,0,0,0))->pid = pid + 1;
      ((NewPid *)&val(newpid,0,0,0))->leaf = is_leaf(cell);
      ((NewPid *)&val(newpid,0,0,0))->prolongation = (!is_leaf(cell) && !cell.neighbors && cell.pid >= 0);
      if (fp)
 fprintf (fp, "%g %g %d %d newpid\n", x, y, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid);
    }
    else
      val(newpid,0,0,0) = 0;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 152 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}
  
#line 278 "/home/spencer/basilisk/src/grid/balance.h"
for (int l = 0; l <= depth(); l++)
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b,((scalar[]) {newpid,{-1}}), l); };
#line 304 "/home/spencer/basilisk/src/grid/balance.h"
  Array * anext = next ? neighborhood (newpid, pid() + 1, fp) : array_new();
  Array * aprev = prev ? neighborhood (newpid, pid() - 1, fp) : array_new();

  if (fp)
    fflush (fp);

  check_flags();


  MPI_Request rprev[2], rnext[2];
  if (pid() > 0)
    send_tree (aprev, pid() - 1, rprev);
  if (pid() < npe() - 1)
    send_tree (anext, pid() + 1, rnext);


  if (pid() < npe() - 1)
    receive_tree (pid() + 1, newpid, fp);
  if (pid() > 0)
    receive_tree (pid() - 1, newpid, fp);


  if (pid() > 0)
    wait_tree (aprev, rprev);
  array_free (aprev);
  if (pid() < npe() - 1)
    wait_tree (anext, rnext);
  array_free (anext);

  if (fp)
    fflush (fp);


  int pid_changed = false; 
#line 140 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    Point root = {0};
    for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)

      for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{

#line 67 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 338 "/home/spencer/basilisk/src/grid/balance.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 338 "/home/spencer/basilisk/src/grid/balance.h"
{
    if (cell.pid >= 0) {
      if (is_newpid()) {
 if (fp)
   fprintf (fp, "%g %g %g %d %d %d %d %d new\n",
     x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid,
     is_leaf(cell), cell.neighbors, ((NewPid *)&val(newpid,0,0,0))->leaf);
 if (cell.pid != ((NewPid *)&val(newpid,0,0,0))->pid - 1) {
   cell.pid = ((NewPid *)&val(newpid,0,0,0))->pid - 1;
   cell.flags &= ~(active|border);
   if (is_local(cell))
     cell.flags |= active;
   pid_changed = true;
 }
 if (((NewPid *)&val(newpid,0,0,0))->leaf && !is_leaf(cell) && cell.neighbors)
   coarsen_cell_recursive (point, NULL);
      }
      else if (level > 0 && ((NewPid *)&coarse(newpid,0,0,0))->leaf)
 cell.pid = aparent(0,0,0).pid;
    }

    if (!cell.neighbors && allocated_child(0,0,0)) {
      if (fp)
 fprintf (fp, "%g %g %g %d %d freechildren\n",
   x, y, z, ((NewPid *)&val(newpid,0,0,0))->pid - 1, cell.pid);
      free_children (point);
    }
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}
  
#line 152 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
}

  
#line 367 "/home/spencer/basilisk/src/grid/balance.h"
if (((Tree *)grid)->dirty || pid_changed) {
#line 255 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 156
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   if ((
#line 264
(
#line 370 "/home/spencer/basilisk/src/grid/balance.h"
!is_leaf (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 182
))
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }







      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 if ((
#line 264
(
#line 370 "/home/spencer/basilisk/src/grid/balance.h"
!is_leaf (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 196
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 if ((
#line 264
(
#line 370 "/home/spencer/basilisk/src/grid/balance.h"
!is_leaf (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 201
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 4; };
 if ((
#line 264
(
#line 370 "/home/spencer/basilisk/src/grid/balance.h"
!is_leaf (cell)
#line 264 "/home/spencer/basilisk/src/grid/foreach_cell.h"
)
#line 206
))
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; };
 break;
#line 246 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      default:
      
#line 371 "/home/spencer/basilisk/src/grid/balance.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 371 "/home/spencer/basilisk/src/grid/balance.h"
if (!is_leaf(cell) && !is_local(cell)) {
 unsigned short flags = cell.flags & ~active; 
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 374 "/home/spencer/basilisk/src/grid/balance.h"
if (is_active(cell)) {
     flags |= active;  
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
(_k = _l = 2)
#line 375 "/home/spencer/basilisk/src/grid/balance.h"
;
   }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  } 
#line 377 "/home/spencer/basilisk/src/grid/balance.h"
cell.flags = flags;
      }}      
#line 249 "/home/spencer/basilisk/src/grid/foreach_cell.h"
}
    }
  }
}
  
#line 266
}
}

    
#line 380 "/home/spencer/basilisk/src/grid/balance.h"
flag_border_cells();
    pid_changed = true;
  }

  if (fp)
    fclose (fp);

  mpi_all_reduce (pid_changed, MPI_INT, MPI_MAX);
  if (pid_changed)
    mpi_boundary_update_buffers();

  {delete((scalar*)((scalar[]){newpid,{-1}}));{end_tracing("balance","/home/spencer/basilisk/src/grid/balance.h",391);return pid_changed;}}delete((scalar*)((scalar[]){newpid,{-1}}));
end_tracing("balance","/home/spencer/basilisk/src/grid/balance.h",392);}

void mpi_boundary_update (scalar * list)
{
  mpi_boundary_update_buffers();
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = true;}}
  grid->tn = 0;
  boundary_internal ((scalar *)list, "/home/spencer/basilisk/src/grid/balance.h", 400);
  while (balance());
}
#line 1739 "/home/spencer/basilisk/src/grid/tree.h"
#else
void mpi_boundary_refine (scalar * list){}
void mpi_boundary_coarsen (int a, int b){}
void mpi_boundary_update (scalar * list) {
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = true;}}
  boundary_internal ((scalar *)list, "/home/spencer/basilisk/src/grid/tree.h", 1745);
}
#endif
#line 4 "/home/spencer/basilisk/src/grid/quadtree.h"

void quadtree_methods() {
  tree_methods();
}
#line 15 "sessile-ibm-axi-osc-cpp.c"
#line 1 "sessile-ibm-axi-osc.c"


#line 1 "../ibm-gcm.h"
#line 1 "./../ibm-gcm.h"


#line 1 "./fractions.h"
#line 1 "/home/spencer/basilisk/src/fractions.h"
#line 12 "/home/spencer/basilisk/src/fractions.h"
#line 1 "./geometry.h"
#line 1 "/home/spencer/basilisk/src/geometry.h"
#line 35 "/home/spencer/basilisk/src/geometry.h"
double line_alpha (double c, coord n)
{
  double alpha, n1, n2;

  n1 = fabs (n.x); n2 = fabs (n.y);
  if (n1 > n2)
    do { double _tmp_ = n1; n1 = n2; n2 = _tmp_; } while(false);

  c = ( c < 0. ? 0. : c > 1. ? 1. : c);
  double v1 = n1/2.;
  if (c <= v1/n2)
    alpha = sqrt (2.*c*n1*n2);
  else if (c <= 1. - v1/n2)
    alpha = c*n2 + v1;
  else
    alpha = n1 + n2 - sqrt (2.*n1*n2*(1. - c));

  if (n.x < 0.)
    alpha += n.x;
  if (n.y < 0.)
    alpha += n.y;

  return alpha - (n.x + n.y)/2.;
}
#line 163 "/home/spencer/basilisk/src/geometry.h"
double line_area (double nx, double ny, double alpha)
{
  double a, v, area;

  alpha += (nx + ny)/2.;
  if (nx < 0.) {
    alpha -= nx;
    nx = - nx;
  }
  if (ny < 0.) {
    alpha -= ny;
    ny = - ny;
  }

  if (alpha <= 0.)
    return 0.;

  if (alpha >= nx + ny)
    return 1.;

  if (nx < 1e-10)
    area = alpha/ny;
  else if (ny < 1e-10)
    area = alpha/nx;
  else {
    v = ( alpha*alpha);

    a = alpha - nx;
    if (a > 0.)
      v -= a*a;

    a = alpha - ny;
    if (a > 0.)
      v -= a*a;

    area = v/(2.*nx*ny);
  }

  return ( area < 0. ? 0. : area > 1. ? 1. : area);
}
#line 267 "/home/spencer/basilisk/src/geometry.h"
double rectangle_fraction (coord n, double alpha, coord a, coord b)
{
  coord n1;
   {
    alpha -= n.x*(b.x + a.x)/2.;
    n1.x = n.x*(b.x - a.x);
  } 
#line 270
{
    alpha -= n.y*(b.y + a.y)/2.;
    n1.y = n.y*(b.y - a.y);
  }
  return line_area(n1.x, n1.y, alpha);
}
#line 292 "/home/spencer/basilisk/src/geometry.h"
int facets (coord n, double alpha, coord p[2])
{
  int i = 0;
  for (double s = -0.5; s <= 0.5; s += 1.)
    {
      if (fabs (n.y) > 1e-4 && i < 2) {
 double a = (alpha - s*n.x)/n.y;
 if (a >= -0.5 && a <= 0.5) {
   p[i].x = s;
   p[i++].y = a;
 }
      }      
#line 297
if (fabs (n.x) > 1e-4 && i < 2) {
 double a = (alpha - s*n.y)/n.x;
 if (a >= -0.5 && a <= 0.5) {
   p[i].y = s;
   p[i++].x = a;
 }
      }}
  return i;
}
#line 382 "/home/spencer/basilisk/src/geometry.h"
double line_length_center (coord m, double alpha, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  
    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }    
#line 388
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }

  p->x = p->y = p->z = 0.;

  if (alpha <= 0. || alpha >= n.x + n.y)
    return 0.;

  
    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = (m.y < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }    
#line 399
if (n.y < 1e-4) {
      p->y = 0.;
      p->x = (m.x < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }

  if (alpha >= n.x) {
    p->x += 1.;
    p->y += (alpha - n.x)/n.y;
  }
  else
    p->x += alpha/n.x;

  double ax = p->x, ay = p->y;
  if (alpha >= n.y) {
    p->y += 1.;
    ay -= 1.;
    p->x += (alpha - n.y)/n.x;
    ax -= (alpha - n.y)/n.x;
  }
  else {
    p->y += alpha/n.y;
    ay -= alpha/n.y;
  }

   {
    p->x /= 2.;
    p->x = ( (p->x) < 0. ? 0. : (p->x) > 1. ? 1. : (p->x));
    if (m.x < 0.)
      p->x = 1. - p->x;
    p->x -= 0.5;
  } 
#line 424
{
    p->y /= 2.;
    p->y = ( (p->y) < 0. ? 0. : (p->y) > 1. ? 1. : (p->y));
    if (m.y < 0.)
      p->y = 1. - p->y;
    p->y -= 0.5;
  }

  return sqrt (ax*ax + ay*ay);
}
#line 512 "/home/spencer/basilisk/src/geometry.h"
void line_center (coord m, double alpha, double a, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  
    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }    
#line 518
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }

  p->z = 0.;
  if (alpha <= 0.) {
    p->x = p->y = -0.5;
    return;
  }

  if (alpha >= n.x + n.y) {
    p->x = p->y = 0.;
    return;
  }

  
    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = ( (int)((m.y) > 0 ? 1 : -1))*(a/2. - 0.5);
      return;
    }    
#line 535
if (n.y < 1e-4) {
      p->y = 0.;
      p->x = ( (int)((m.x) > 0 ? 1 : -1))*(a/2. - 0.5);
      return;
    }

  p->x = p->y = ( alpha*alpha*alpha);

   {
    double b = alpha - n.x;
    if (b > 0.) {
      p->x -= ( b*b)*(alpha + 2.*n.x);
      p->y -= ( b*b*b);
    }
  } 
#line 543
{
    double b = alpha - n.y;
    if (b > 0.) {
      p->y -= ( b*b)*(alpha + 2.*n.y);
      p->x -= ( b*b*b);
    }
  }

   {
    p->x /= 6.*( (n.x)*(n.x))*n.y*a;
    p->x = ( (int)((m.x) > 0 ? 1 : -1))*(p->x - 0.5);
  } 
#line 551
{
    p->y /= 6.*( (n.y)*(n.y))*n.x*a;
    p->y = ( (int)((m.y) > 0 ? 1 : -1))*(p->y - 0.5);
  }
}
#line 13 "/home/spencer/basilisk/src/fractions.h"





#line 1 "./myc2d.h"
#line 1 "/home/spencer/basilisk/src/myc2d.h"





coord mycs (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 8 "/home/spencer/basilisk/src/myc2d.h"
int ix;
  double c_t,c_b,c_r,c_l;
  double mx0,my0,mx1,my1,mm1,mm2;


  c_t = val(c,-1,1,0) + val(c,0,1,0) + val(c,1,1,0);
  c_b = val(c,-1,-1,0) + val(c,0,-1,0) + val(c,1,-1,0);
  c_r = val(c,1,-1,0) + val(c,1,0,0) + val(c,1,1,0);
  c_l = val(c,-1,-1,0) + val(c,-1,0,0) + val(c,-1,1,0);



  mx0 = 0.5*(c_l - c_r);
  my0 = 0.5*(c_b - c_t);


  if (fabs(mx0) <= fabs(my0)) {
    my0 = my0 > 0. ? 1. : -1.;
    ix = 1;
  }
  else {
    mx0 = mx0 > 0. ? 1. : -1.;
    ix = 0;
  }


  mm1 = val(c,-1,-1,0) + 2.0*val(c,-1,0,0) + val(c,-1,1,0);
  mm2 = val(c,1,-1,0) + 2.0*val(c,1,0,0) + val(c,1,1,0);
  mx1 = mm1 - mm2 + 1e-30;
  mm1 = val(c,-1,-1,0) + 2.0*val(c,0,-1,0) + val(c,1,-1,0);
  mm2 = val(c,-1,1,0) + 2.0*val(c,0,1,0) + val(c,1,1,0);
  my1 = mm1 - mm2 + 1e-30;


  if (ix) {
    mm1 = fabs(my1);
    mm1 = fabs(mx1)/mm1;
    if (mm1 > fabs(mx0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }
  else {
    mm1 = fabs(mx1);
    mm1 = fabs(my1)/mm1;
    if (mm1 > fabs(my0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }



  mm1 = fabs(mx0) + fabs(my0);
  coord n = {mx0/mm1, my0/mm1, 0};

  return n;
}
#line 13 "/home/spencer/basilisk/src/fractions.h"





#line 1 "./myc2d.h"
#line 1 "/home/spencer/basilisk/src/myc2d.h"





static void _stencil_mycs (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 13 "/home/spencer/basilisk/src/myc2d.h"
_stencil_val(c,-1,1,0); _stencil_val(c,0,1,0); _stencil_val(c,1,1,0);     
_stencil_val(c,-1,-1,0); _stencil_val(c,0,-1,0); _stencil_val(c,1,-1,0); 
     _stencil_val(c,1,-1,0); _stencil_val(c,1,0,0); _stencil_val(c,1,1,0); 
     _stencil_val(c,-1,-1,0); _stencil_val(c,-1,0,0); _stencil_val(c,-1,1,0);
            
      
   
            
     
       
    



     
      





_stencil_val(c,-1,-1,0);_stencil_val(c,-1,0,0); _stencil_val(c,-1,1,0);      
_stencil_val(c,1,-1,0);_stencil_val(c,1,0,0); _stencil_val(c,1,1,0);  
     
        _stencil_val(c,-1,-1,0);_stencil_val(c,0,-1,0); _stencil_val(c,1,-1,0);
       _stencil_val(c,-1,1,0);_stencil_val(c,0,1,0); _stencil_val(c,1,1,0);  
#line 64
return ;
}
#line 19 "/home/spencer/basilisk/src/fractions.h"
#line 40 "/home/spencer/basilisk/src/fractions.h"
void fraction_refine (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 47 "/home/spencer/basilisk/src/fractions.h"
double cc = val(c,0,0,0);
  if (cc <= 0. || cc >= 1.)
     
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;      
#line 50 "/home/spencer/basilisk/src/fractions.h"
val(c,0,0,0) = cc;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}  
#line 51 "/home/spencer/basilisk/src/fractions.h"
else {




    coord n = mycs (point, c);
    double alpha = line_alpha (cc, n);
  






    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 64 "/home/spencer/basilisk/src/fractions.h"
{
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
 nc.x = child.x*n.x; nc.y = child.y*n.y;
      val(c,0,0,0) = rectangle_fraction (nc, alpha, a, b);
    }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 71 "/home/spencer/basilisk/src/fractions.h"
}
}











static void alpha_refine (Point point, scalar alpha)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 86 "/home/spencer/basilisk/src/fractions.h"
vector n = _attribute[alpha.i].n;
  double alphac = 2.*val(alpha,0,0,0);
  coord m;
  
    m.x = val(n.x,0,0,0);    m.y = val(n.y,0,0,0);
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 91 "/home/spencer/basilisk/src/fractions.h"
{
    val(alpha,0,0,0) = alphac;
    
      val(alpha,0,0,0) -= child.x*m.x/2.;      val(alpha,0,0,0) -= child.y*m.y/2.;
  }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 96 "/home/spencer/basilisk/src/fractions.h"
}
#line 120 "/home/spencer/basilisk/src/fractions.h"
     
void fractions (scalar Phi, scalar c,
  vector s, double val)
{tracing("fractions","/home/spencer/basilisk/src/fractions.h",121);

  vector   as=(s).x.i>0?(s):new_face_vector("as");
#line 136 "/home/spencer/basilisk/src/fractions.h"
  vector p;
  p.x = as.y; p.y = as.x;
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 146, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 146 "/home/spencer/basilisk/src/fractions.h"
{ 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 146 "/home/spencer/basilisk/src/fractions.h"
{





_stencil_val(Phi,0,0,0);_stencil_val(Phi,1,0,0);{ {






_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,1,0,0);      _stencil_val_a(p.x,0,0,0);
_stencil_val(Phi,0,0,0);
 { _stencil_val(p.x,0,0,0);_stencil_val_a(p.x,0,0,0);   }    
}
      








{_stencil_val(Phi,0,0,0); _stencil_val(Phi,1,0,0);_stencil_val_a(p.x,0,0,0);       }}





           
#line 171 "/home/spencer/basilisk/src/fractions.h"
    
  
} 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 146 "/home/spencer/basilisk/src/fractions.h"
{





_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,1,0);{ {






_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,0,1,0);      _stencil_val_a(p.y,0,0,0);
_stencil_val(Phi,0,0,0);
 { _stencil_val(p.y,0,0,0);_stencil_val_a(p.y,0,0,0);   }    
}
      








{_stencil_val(Phi,0,0,0); _stencil_val(Phi,0,1,0);_stencil_val_a(p.y,0,0,0);       }}





           
#line 171 "/home/spencer/basilisk/src/fractions.h"
    
  
}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 146 "/home/spencer/basilisk/src/fractions.h"
{
  
#line 707 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 146 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 146 "/home/spencer/basilisk/src/fractions.h"
{





    if ((val(Phi,0,0,0) - val)*(val(Phi,1,0,0) - val) < 0.) {






      val(p.x,0,0,0) = (val(Phi,0,0,0) - val)/(val(Phi,0,0,0) - val(Phi,1,0,0));
      if (val(Phi,0,0,0) < val)
 val(p.x,0,0,0) = 1. - val(p.x,0,0,0);
    }
#line 171 "/home/spencer/basilisk/src/fractions.h"
    else
      val(p.x,0,0,0) = (val(Phi,0,0,0) > val || val(Phi,1,0,0) > val);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}  
#line 699
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 146 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 146 "/home/spencer/basilisk/src/fractions.h"
{





    if ((val(Phi,0,0,0) - val)*(val(Phi,0,1,0) - val) < 0.) {






      val(p.y,0,0,0) = (val(Phi,0,0,0) - val)/(val(Phi,0,0,0) - val(Phi,0,1,0));
      if (val(Phi,0,0,0) < val)
 val(p.y,0,0,0) = 1. - val(p.y,0,0,0);
    }
#line 171 "/home/spencer/basilisk/src/fractions.h"
    else
      val(p.y,0,0,0) = (val(Phi,0,0,0) > val || val(Phi,0,1,0) > val);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 173 "/home/spencer/basilisk/src/fractions.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 196 "/home/spencer/basilisk/src/fractions.h"
  scalar s_z = c;
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 197, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 199 "/home/spencer/basilisk/src/fractions.h"
{    
#line 231 "/home/spencer/basilisk/src/fractions.h"
    
    
     { 
_stencil_val(p.y,0,0,0); _stencil_val(p.y,1,0,0);    

} 
#line 233
{ 
_stencil_val(p.x,0,0,0); _stencil_val(p.x,0,1,0);    

}





{
      { _stencil_val(p.x,0,0,0);_stencil_val_a(s_z,0,0,0); } 
{      





      
   






      
      for (int i = 0; i <= 1; i++)
 {
   {_stencil_val(p.x,0,i,0); _stencil_val(p.x,0,i,0); {              
     _stencil_val(p.x,0,i,0);_stencil_val(Phi,0,i,0); 
          
     
   }      }   
#line 261
{_stencil_val(p.y,i,0,0); _stencil_val(p.y,i,0,0); {              
     _stencil_val(p.y,i,0,0);_stencil_val(Phi,i,0,0); 
          
     
   }      }}








{
 {_stencil_val(p.x,0,0,0);_stencil_val(p.y,0,0,0);_stencil_val(p.x,0,0,0);_stencil_val(p.y,0,0,0);_stencil_val_a(s_z,0,0,0);         }
{
 {_stencil_val_a(s_z,0,0,0);     } 
{



 _stencil_val_a(s_z,0,0,0);  

      }}}
#line 274 "/home/spencer/basilisk/src/fractions.h"
         
          
      
    







}}  
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;  
#line 199 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 199 "/home/spencer/basilisk/src/fractions.h"
{
#line 231 "/home/spencer/basilisk/src/fractions.h"
    coord n;
    double nn = 0.;
     {
      n.x = val(p.y,0,0,0) - val(p.y,1,0,0);
      nn += fabs(n.x);
    } 
#line 233
{
      n.y = val(p.x,0,0,0) - val(p.x,0,1,0);
      nn += fabs(n.y);
    }





    if (nn == 0.)
      val(s_z,0,0,0) = val(p.x,0,0,0);
    else {





      
 n.x /= nn; n.y /= nn;






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (val(p.x,0,i,0) > 0. && val(p.x,0,i,0) < 1.) {
     double a = ( (int)((val(Phi,0,i,0) - val) > 0 ? 1 : -1))*(val(p.x,0,i,0) - 0.5);
     alpha += n.x*a + n.y*(i - 0.5);
     ni++;
   }   
#line 261
if (val(p.y,i,0,0) > 0. && val(p.y,i,0,0) < 1.) {
     double a = ( (int)((val(Phi,i,0,0) - val) > 0 ? 1 : -1))*(val(p.y,i,0,0) - 0.5);
     alpha += n.y*a + n.x*(i - 0.5);
     ni++;
   }}
#line 274 "/home/spencer/basilisk/src/fractions.h"
      if (ni == 0)
 val(s_z,0,0,0) = ( (val(p.x,0,0,0)) > (val(p.y,0,0,0)) ? (val(p.x,0,0,0)) : (val(p.y,0,0,0)));
      else if (ni != 4)
 val(s_z,0,0,0) = line_area (n.x, n.y, alpha/ni);
      else {



 val(s_z,0,0,0) = 0.;

      }
    }
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 286 "/home/spencer/basilisk/src/fractions.h"
if((s).x.i<=0)delete((scalar*)((vector[]){as,{{-1},{-1}}}));
#line 351 "/home/spencer/basilisk/src/fractions.h"
end_tracing("fractions","/home/spencer/basilisk/src/fractions.h",351);}





void macro_fraction (scalar f, double func)
{
  {
    scalar  phi=new_vertex_scalar("phi");    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 361, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
      
#line 362 "/home/spencer/basilisk/src/fractions.h"
{_stencil_val_a(phi,0,0,0);  }  
#line 338 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 1708 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 1710
((Tree *)grid)->vertices
#line 436
).n; _k++) {
 point.i = (
#line 1710
((Tree *)grid)->vertices
#line 437
).p[_k].i;

 point.j = (
#line 1710
((Tree *)grid)->vertices
#line 439
).p[_k].j;




 point.level = (
#line 1710
((Tree *)grid)->vertices
#line 444
).p[_k].level;
 _flags = (
#line 1710
((Tree *)grid)->vertices
#line 445
).p[_k].flags; 
#line 1710
{
    int ig = -1; NOT_UNUSED (ig);

    int jg = -1; NOT_UNUSED (jg);      
#line 362 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 362 "/home/spencer/basilisk/src/fractions.h"
val(phi,0,0,0) = func;}
  
#line 1719 "/home/spencer/basilisk/src/grid/tree.h"
}      
#line 447
}
  }
}

#line 1720
}    
#line 363 "/home/spencer/basilisk/src/fractions.h"
fractions (phi, f
#line 121
,
(  vector) {0}, 0.
#line 363
);delete((scalar*)((scalar[]){phi,{-1}}));
  }
}

void macro_solid (scalar cs, vector fs, double func)
{
  {
    scalar  phi=new_vertex_scalar("phi");    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 371, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
      
#line 372 "/home/spencer/basilisk/src/fractions.h"
{_stencil_val_a(phi,0,0,0);  }  
#line 338 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 1708 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 1710
((Tree *)grid)->vertices
#line 436
).n; _k++) {
 point.i = (
#line 1710
((Tree *)grid)->vertices
#line 437
).p[_k].i;

 point.j = (
#line 1710
((Tree *)grid)->vertices
#line 439
).p[_k].j;




 point.level = (
#line 1710
((Tree *)grid)->vertices
#line 444
).p[_k].level;
 _flags = (
#line 1710
((Tree *)grid)->vertices
#line 445
).p[_k].flags; 
#line 1710
{
    int ig = -1; NOT_UNUSED (ig);

    int jg = -1; NOT_UNUSED (jg);      
#line 372 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 372 "/home/spencer/basilisk/src/fractions.h"
val(phi,0,0,0) = func;}
  
#line 1719 "/home/spencer/basilisk/src/grid/tree.h"
}      
#line 447
}
  }
}

#line 1720
}    
#line 373 "/home/spencer/basilisk/src/fractions.h"
fractions (phi, cs, fs
#line 122
, 0.
#line 373
);delete((scalar*)((scalar[]){phi,{-1}}));
  }
}
#line 401 "/home/spencer/basilisk/src/fractions.h"
coord youngs_normal (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 403 "/home/spencer/basilisk/src/fractions.h"
coord n;
  double nn = 0.;
  if (!(2 == 2)) qassert ("/home/spencer/basilisk/src/fractions.h", 405, "dimension == 2");
   {
    n.x = (val(c,-1,1,0) + 2.*val(c,-1,0,0) + val(c,-1,-1,0) -
    val(c,+1,1,0) - 2.*val(c,+1,0,0) - val(c,+1,-1,0));
    nn += fabs(n.x);
  } 
#line 406
{
    n.y = (val(c,1,-1,0) + 2.*val(c,0,-1,0) + val(c,-1,-1,0) -
    val(c,1,+1,0) - 2.*val(c,0,+1,0) - val(c,-1,+1,0));
    nn += fabs(n.y);
  }

  if (nn > 0.)
    {
      n.x /= nn;      n.y /= nn;}
  else
    n.x = 1.;
  return n;
}





coord facet_normal (Point point, scalar c, vector s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 426 "/home/spencer/basilisk/src/fractions.h"
if (s.x.i >= 0) {
    coord n;
    double nn = 0.;
     {
      n.x = val(s.x,0,0,0) - val(s.x,1,0,0);
      nn += fabs(n.x);
    } 
#line 429
{
      n.y = val(s.y,0,0,0) - val(s.y,0,1,0);
      nn += fabs(n.y);
    }
    if (nn > 0.)
      {
 n.x /= nn; n.y /= nn;}
    else
      {
 n.x = 1./2; n.y = 1./2;}
    return n;
  }
  return mycs (point, c);
}
#line 424
static void _stencil_facet_normal (Point point, scalar c, vector s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 426 "/home/spencer/basilisk/src/fractions.h"
if (s.x.i >= 0) {    
    
    
     { 
_stencil_val(s.x,0,0,0); _stencil_val(s.x,1,0,0);    

} 
#line 429
{ 
_stencil_val(s.y,0,0,0); _stencil_val(s.y,0,1,0);    

}
      
   
       
    
       
  
    return ;
  } 
_stencil_mycs (point, c);  return;
}
#line 451 "/home/spencer/basilisk/src/fractions.h"
     
void reconstruction (const scalar c, vector n, scalar alpha)
{tracing("reconstruction","/home/spencer/basilisk/src/fractions.h",452);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 454, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 454 "/home/spencer/basilisk/src/fractions.h"
{





_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{ {
      _stencil_val_a(alpha,0,0,0);  
      
 {_stencil_val_a(n.x,0,0,0);  } {_stencil_val_a(n.y,0,0,0);  }
    } 
{  






       _stencil_mycs (point, c);
      
 {_stencil_val_a(n.x,0,0,0);  } {_stencil_val_a(n.y,0,0,0);  }
_stencil_val(c,0,0,0);      _stencil_val_a(alpha,0,0,0);    
    }}  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 454 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 454 "/home/spencer/basilisk/src/fractions.h"
{





    if (val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) {
      val(alpha,0,0,0) = 0.;
      
 val(n.x,0,0,0) = 0.; val(n.y,0,0,0) = 0.;
    }
    else {






      coord m = mycs (point, c);
      
 val(n.x,0,0,0) = m.x; val(n.y,0,0,0) = m.y;
      val(alpha,0,0,0) = line_alpha (val(c,0,0,0), m);
    }
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 486 "/home/spencer/basilisk/src/fractions.h"
  
    _attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;    _attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;




  _attribute[alpha.i].n = n;
  _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;

end_tracing("reconstruction","/home/spencer/basilisk/src/fractions.h",495);}
#line 515 "/home/spencer/basilisk/src/fractions.h"
     
void output_facets (scalar c, FILE * fp, vector s)
{tracing("output_facets","/home/spencer/basilisk/src/fractions.h",516);
{  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 518, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 519 "/home/spencer/basilisk/src/fractions.h"
{_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {  
       _stencil_facet_normal (point, c, s);     
      _stencil_val(c,0,0,0); 



            
           
        
     
 
#line 539 "/home/spencer/basilisk/src/fractions.h"
    }        }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;
    
#line 519 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 519 "/home/spencer/basilisk/src/fractions.h"
if (val(c,0,0,0) > 1e-6 && val(c,0,0,0) < 1. - 1e-6) {
      coord n = facet_normal (point, c, s);
      double alpha = line_alpha (val(c,0,0,0), n);



      coord segment[2];
      if (facets (n, alpha, segment) == 2)
 fprintf (fp, "%g %g\n%g %g\n\n",
   x + segment[0].x*Delta, y + segment[0].y*Delta,
   x + segment[1].x*Delta, y + segment[1].y*Delta);
#line 539 "/home/spencer/basilisk/src/fractions.h"
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 539 "/home/spencer/basilisk/src/fractions.h"
}

  fflush (fp);
end_tracing("output_facets","/home/spencer/basilisk/src/fractions.h",542);}







     
double interface_area (scalar c)
{tracing("interface_area","/home/spencer/basilisk/src/fractions.h",551);
  double area = 0.;  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 554, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 555 "/home/spencer/basilisk/src/fractions.h"
{_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
       _stencil_mycs (point, c);     
      _stencil_val(c,0,0,0); 
          
    }        }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:area)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;
    
#line 555 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 555 "/home/spencer/basilisk/src/fractions.h"
if (val(c,0,0,0) > 1e-6 && val(c,0,0,0) < 1. - 1e-6) {
      coord n = mycs (point, c), p;
      double alpha = line_alpha (val(c,0,0,0), n);
      area += pow(Delta, 2 - 1)*line_length_center(n,alpha,&p);
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 559 "/home/spencer/basilisk/src/fractions.h"
{mpi_all_reduce_array(&area,MPI_DOUBLE,MPI_SUM,1);}
  {end_tracing("interface_area","/home/spencer/basilisk/src/fractions.h",560);return area;}
end_tracing("interface_area","/home/spencer/basilisk/src/fractions.h",561);}
#line 4 "./../ibm-gcm.h"
#line 14 "./../ibm-gcm.h"
scalar  ibm={0};
scalar  ibm0={1};
vector  ibmf={{2},{3}};
vector  ibmf0={{4},{5}};


scalar  ibmCells={6};
vector  ibmFaces={{7},{8}};

double (* metric_ibm_factor) (Point, coord) = NULL;





bool local_bc_coordinates = true;
#line 40 "./../ibm-gcm.h"
typedef struct fragment {
    coord n;
    double alpha;
    double c;
} fragment;


void fill_fragment (double c, coord n, fragment * frag)
{
    frag->c = c;
    frag->n = n;
    frag->alpha = line_alpha (c, n);
}

typedef struct PointIBM {
    int i, j, k;
} PointIBM;
#line 68 "./../ibm-gcm.h"
bid immersed;





static inline
double ibm_area_center (Point point, scalar s, double* x1, double* y1, double* z1)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 77 "./../ibm-gcm.h"
vector mp = _attribute[s.i].mp;
    *x1 = val(mp.x,0,0,0), *y1 = val(mp.y,0,0,0), *z1 = _val_higher_dimension;
    return 1;
}


double macro2_dirichlet (double expr, Point point,
    scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 86 "./../ibm-gcm.h"
return data ? ibm_area_center (point, s, &x, &y, &z),
    ((bool *)data)[0] = true, expr : 2.*expr - val(s,0,0,0);
}


double macro2_dirichlet_homogeneous (double expr, Point point,
         scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 94 "./../ibm-gcm.h"
return data ? ((bool *)data)[0] = true, 0 : - val(s,0,0,0);
}


double macro2_neumann (double expr, Point point,
  scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 101 "./../ibm-gcm.h"
return data ? ibm_area_center (point, s, &x, &y, &z),
    ((bool *)data)[0] = false, expr : Delta*expr + val(s,0,0,0);
}


double macro2_neumann_homogeneous (double expr, Point point,
       scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 109 "./../ibm-gcm.h"
return data ? ((bool *)data)[0] = false, 0 : val(s,0,0,0);
}


double macro_navier_slip (double expr, Point point,
    scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 116 "./../ibm-gcm.h"
return data ? ibm_area_center (point, s, &x, &y, &z),
    ((bool *)data)[0] = true, ((bool *)data)[1] = true, expr : 2.*expr - val(s,0,0,0);
}

coord cross_product (coord a, coord b)
{
    coord c = {
        (a.y*b.z) - (a.z*b.y) ,
      -((a.x*b.z) - (b.x*a.z)),
        (a.x*b.y) - (a.y*b.x)
    };
    return c;
}

double determinant (coord a, coord b)
{
    coord c = cross_product(a,b);
    return sqrt(( (c.x)*(c.x)) + ( (c.y)*(c.y)) + ( (c.z)*(c.z)));
}


int approx_equal (coord p1, coord p2, double TOL)
{
    return fabs(p1.x - p2.x) <= TOL && fabs(p1.y - p2.y) <= TOL && fabs(p1.z - p2.z) <= TOL;
}

int approx_equal_double (double a, double b, double TOL)
{
    return fabs(a - b) <= TOL;
}


double dot_product_norm (coord a, coord b)
{
    normalize(&a); normalize(&b);

    double product = 0;
    
        product += a.x*b.x;        product += a.y*b.y;

    return product;
}

double dot_product (coord a, coord b)
{
    double product = 0;
    
        product += a.x*b.x;        product += a.y*b.y;

    return product;
}

double dot_product_angle (coord a, coord b)
{
    double product = ( (dot_product(a, b)) < (-1) ? (-1) : (dot_product(a, b)) > 1 ? 1 : (dot_product(a, b)));
    if (!(fabs(product) <= 1)) qassert ("./../ibm-gcm.h", 171, "fabs(product) <= 1");
    return acos(dot_product(a, b));
}


void normalize2 (coord * n)
{
    double norm = 0;
    
        norm += ( (n->x)*(n->x));        norm += ( (n->y)*(n->y));
    norm = sqrt(norm);
    
        n->x /= norm + 1e-30;        n->y /= norm + 1e-30;
}





void normal_and_tangents (coord * n, coord * t1, coord * t2)
{
    normalize2(n);


    coord t1_tmp = {-n->y, n->x};
    *t1 = t1_tmp;
    *t2 = (coord){0,0,0};
#line 216 "./../ibm-gcm.h"
}
#line 226 "./../ibm-gcm.h"
bool empty_neighbor (Point point, coord * pc, coord * n, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 228 "./../ibm-gcm.h"
coord pc_temp, cellCenter = {x, y, z};
    double ibm_temp = val(ibm,0,0,0);
    double max_d = 1e6;
    int neighbor = 0;    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 233 "./../ibm-gcm.h"
{
        double distance2Cell = sqrt(( (x - cellCenter.x)*(x - cellCenter.x)) + ( (y - cellCenter.y)*(y - cellCenter.y)) + ( (z - cellCenter.z)*(z - cellCenter.z)));
        if (val(ibm,0,0,0) == 0 && ibm_temp == 1 && distance2Cell < max_d) {
            pc_temp.x = (cellCenter.x + x) / 2.;
            pc_temp.y = (cellCenter.y + y) / 2.;
            pc_temp.z = (cellCenter.z + z) / 2.;

            max_d = sqrt(( (x - cellCenter.x)*(x - cellCenter.x)) + ( (y - cellCenter.y)*(y - cellCenter.y)) + ( (z - cellCenter.z)*(z - cellCenter.z)));

            neighbor = 1;
            *pc = pc_temp;
        }
    }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }



    
#line 249 "./../ibm-gcm.h"
coord n_temp = {pc_temp.x != cellCenter.x,
                    pc_temp.y != cellCenter.y,
                    pc_temp.z != cellCenter.z};
     {
        n_temp.x *= ( (int)((pc_temp.x - cellCenter.x) > 0 ? 1 : (pc_temp.x - cellCenter.x) < 0 ? -1 : 0));
    } 
#line 252
{
        n_temp.y *= ( (int)((pc_temp.y - cellCenter.y) > 0 ? 1 : (pc_temp.y - cellCenter.y) < 0 ? -1 : 0));
    }

    *n = n_temp;

    return neighbor;
}
#line 226 "./../ibm-gcm.h"
static void _stencil_empty_neighbor (Point point,_stencil_undefined * pc,_stencil_undefined * n, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;     
#line 229 "./../ibm-gcm.h"
_stencil_val(ibm,0,0,0);    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 233 "./../ibm-gcm.h"
{                      
        
_stencil_val(ibm,0,0,0);    









}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }    
                      
                       



    
    
                           
     

      

    
#line 258 "./../ibm-gcm.h"
return ;
}
#line 270 "./../ibm-gcm.h"
bool fluid_neighbor (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 273 "./../ibm-gcm.h"
for(int i = -1; i <= 1; i++)
        if (val(ibm,i,0,0) > 0.5)
            return true;


    for(int j = -1; j <= 1; j++)
        if (val(ibm,0, j,0) > 0.5)
            return true;
#line 289 "./../ibm-gcm.h"
    return false;
}
#line 270 "./../ibm-gcm.h"
static void _stencil_fluid_neighbor (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 273 "./../ibm-gcm.h"
for(int i = -1; i <= 1; i++)
        {_stencil_val(ibm,i,0,0); 
               }


    for(int j = -1; j <= 1; j++)
        {_stencil_val(ibm,0, j,0); 
               }
#line 289 "./../ibm-gcm.h"
    return ;
}
#line 301 "./../ibm-gcm.h"
bool match_level (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 303 "./../ibm-gcm.h"
{
        if (val(ibm,0,0,0) > 0.5 && is_leaf(cell) && is_active(cell))
            return true;
    }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 307 "./../ibm-gcm.h"
return false;
}
#line 301 "./../ibm-gcm.h"
static void _stencil_match_level (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 303 "./../ibm-gcm.h"
{
_stencil_val(ibm,0,0,0);    

}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 307 "./../ibm-gcm.h"
return ;
}







bool is_ghost_cell (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 318 "./../ibm-gcm.h"
return val(ibm,0,0,0) <= 0.5 && fluid_neighbor(point, ibm) && match_level(point, ibm);
}
#line 316
static void _stencil_is_ghost_cell (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 318 "./../ibm-gcm.h"
_stencil_val(ibm,0,0,0); _stencil_fluid_neighbor(point, ibm); _stencil_match_level(point, ibm);   return    ;
}
#line 330 "./../ibm-gcm.h"
double centroid_point (Point point, scalar ibm, coord * midPoint, coord * n, double * alpha)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 332 "./../ibm-gcm.h"
coord cellCenter = {x, y, z};
    *n = facet_normal (point, ibm, ibmf);
    *alpha = line_alpha (val(ibm,0,0,0), *n);
    double area = line_length_center(*n,*alpha,midPoint);

    
        midPoint->x = cellCenter.x + midPoint->x*Delta;        midPoint->y = cellCenter.y + midPoint->y*Delta;
    return area;
}
#line 330 "./../ibm-gcm.h"
static void _stencil_centroid_point (Point point, scalar ibm,_stencil_undefined * midPoint,_stencil_undefined * n,_stencil_undefined * alpha)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;     
#line 333 "./../ibm-gcm.h"
_stencil_facet_normal (point, ibm, ibmf);
     _stencil_val(ibm,0,0,0);    




return ;
}
#line 351 "./../ibm-gcm.h"
     
void reconstruction_ibm (const scalar c, const vector cf, vector n, scalar alpha)
{tracing("reconstruction_ibm","./../ibm-gcm.h",352);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 354, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 354 "./../ibm-gcm.h"
{
_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{ {
            _stencil_val_a(alpha,0,0,0);  
            
                {_stencil_val_a(n.x,0,0,0);  }                {_stencil_val_a(n.y,0,0,0);  }
        } 
{  
             _stencil_facet_normal (point, c, cf);
            
                {_stencil_val_a(n.x,0,0,0);  }                {_stencil_val_a(n.y,0,0,0);  }
_stencil_val(c,0,0,0);            _stencil_val_a(alpha,0,0,0);   
        }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 354 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 354 "./../ibm-gcm.h"
{
        if (val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) {
            val(alpha,0,0,0) = 0.;
            
                val(n.x,0,0,0) = 0.;                val(n.y,0,0,0) = 0.;
        }
        else {
            coord m = facet_normal (point, c, cf);
            
                val(n.x,0,0,0) = m.x;                val(n.y,0,0,0) = m.y;
            val(alpha,0,0,0) = line_alpha(val(c,0,0,0), m);
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}        
#line 370 "./../ibm-gcm.h"
_attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;        _attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;

    _attribute[alpha.i].n = n;
    _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;

end_tracing("reconstruction_ibm","./../ibm-gcm.h",375);}
#line 392 "./../ibm-gcm.h"
coord closest_interface (Point point, vector midPoints, scalar ibm, vector normals,
                         fragment * frag, coord * fluidCell, PointIBM * bioff)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 395 "./../ibm-gcm.h"
fragment temp_frag;
    coord temp_midPoint, temp_fluidCell = {0,0};
    coord n;
    PointIBM ptemp = {0,0,0};

    double min_distance = 1e6;

     for(int i = -1; i <= 1; i++) {
        double dx = val(midPoints.x,i,0,0) - x;
        double dy = val(midPoints.y,i,0,0) - y;
        double dz = _val_higher_dimension - z;
        if ((val(midPoints.x,i,0,0) || val(midPoints.y,i,0,0) || _val_higher_dimension) &&
             sqrt(( dx*dx) + ( dy*dy) + ( dz*dz)) < min_distance) {
            temp_midPoint.x = val(midPoints.x,i,0,0);
            temp_midPoint.y = val(midPoints.y,i,0,0);
            temp_midPoint.z = _val_higher_dimension;

            n.x = val(normals.x,i,0,0); n.y = val(normals.y,i,0,0); n.z = _val_higher_dimension;

            fill_fragment (val(ibm,i,0,0), n, &temp_frag);
            temp_fluidCell.x = i*Delta + x;
            temp_fluidCell.y = y;
            temp_fluidCell.z = z;
            min_distance = sqrt(( dx*dx) + ( dy*dy) + ( dz*dz));
            ptemp = (PointIBM){i,0,0};
        }
     }

     for(int j = -1; j <= 1; j++) {
        double dx = val(midPoints.x,0,j,0) - x;
        double dy = val(midPoints.y,0,j,0) - y;
        double dz = _val_higher_dimension - z;
        if ((val(midPoints.x,0,j,0) || val(midPoints.y,0,j,0) || _val_higher_dimension) &&
             sqrt(( dx*dx) + ( dy*dy) + ( dz*dz)) < min_distance) {
            temp_midPoint.x = val(midPoints.x,0,j,0);
            temp_midPoint.y = val(midPoints.y,0,j,0);
            temp_midPoint.z = _val_higher_dimension;

            n.x = val(normals.x,0,j,0); n.y = val(normals.y,0,j,0); n.z = _val_higher_dimension;

            fill_fragment (val(ibm,0,j,0), n, &temp_frag);
            temp_fluidCell.x = x;
            temp_fluidCell.y = j*Delta + y;
            temp_fluidCell.z = z;
            min_distance = sqrt(( dx*dx) + ( dy*dy) + ( dz*dz));
            ptemp = (PointIBM){0,j,0};
        }
     }
#line 466 "./../ibm-gcm.h"
    *fluidCell = temp_fluidCell;
    *frag = temp_frag;
    *bioff = ptemp;

    return temp_midPoint;
}
#line 392 "./../ibm-gcm.h"
static void _stencil_closest_interface (Point point, vector midPoints, scalar ibm, vector normals,
_stencil_undefined * frag,_stencil_undefined * fluidCell,_stencil_undefined * bioff)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;            
    
    
    
    

    

     
#line 402 "./../ibm-gcm.h"
for(int i = -1; i <= 1; i++) {    
         _stencil_val(midPoints.x,i,0,0);    
         _stencil_val(midPoints.y,i,0,0);    
         _stencil_val_higher_dimension;
_stencil_val(midPoints.x,i,0,0); _stencil_val(midPoints.y,i,0,0); _stencil_val_higher_dimension; 
{ 
_stencil_val(midPoints.x,i,0,0); 
             _stencil_val(midPoints.y,i,0,0);
              _stencil_val_higher_dimension;
              
_stencil_val(normals.x,i,0,0);             _stencil_val(normals.y,i,0,0);   _stencil_val_higher_dimension;  

_stencil_val(ibm,i,0,0);        





}     
}

     for(int j = -1; j <= 1; j++) {    
         _stencil_val(midPoints.x,0,j,0);    
         _stencil_val(midPoints.y,0,j,0);    
         _stencil_val_higher_dimension;
_stencil_val(midPoints.x,0,j,0); _stencil_val(midPoints.y,0,j,0); _stencil_val_higher_dimension; 
{ 
_stencil_val(midPoints.x,0,j,0);
              _stencil_val(midPoints.y,0,j,0);
              _stencil_val_higher_dimension;
              
_stencil_val(normals.x,0,j,0);              _stencil_val(normals.y,0,j,0);   _stencil_val_higher_dimension;  

_stencil_val(ibm,0,j,0);        





}     
} 
#line 466 "./../ibm-gcm.h"
      
     
      

    return ;
}
#line 482 "./../ibm-gcm.h"
coord boundary_int (Point point, fragment frag, coord fluidCell, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 484 "./../ibm-gcm.h"
double mag = sqrt(( (frag.n.x)*(frag.n.x)) + ( (frag.n.y)*(frag.n.y)) + ( (frag.n.z)*(frag.n.z))) + 1e-30;
    coord n = frag.n, ghostCell = {x,y,z};

    normalize2(&n);

    double offset = 0;
    offset += n.x * -( (int)((fluidCell.x - x) > 0 ? 1 : (fluidCell.x - x) < 0 ? -1 : 0));
    offset += n.y * -( (int)((fluidCell.y - y) > 0 ? 1 : (fluidCell.y - y) < 0 ? -1 : 0));
    offset += n.z * -( (int)((fluidCell.z - z) > 0 ? 1 : (fluidCell.z - z) < 0 ? -1 : 0));
    coord boundaryInt = {(-frag.alpha / mag - offset) * n.x,
                         (-frag.alpha / mag - offset) * n.y,
                         (-frag.alpha / mag - offset) * n.z};

    
        boundaryInt.x = ghostCell.x + boundaryInt.x*Delta;        boundaryInt.y = ghostCell.y + boundaryInt.y*Delta;

    return boundaryInt;
}
#line 482 "./../ibm-gcm.h"
static void _stencil_boundary_int (Point point,_stencil_undefined * frag,_stencil_undefined * fluidCell,_stencil_undefined * ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;            
                               
                                                 
    
    

    

     
                        
                         
                         
    

    
            

    
#line 500 "./../ibm-gcm.h"
return ;
}

coord direction_vector (coord p0, coord p1)
{
    return (coord){p1.x - p0.x, p1.y - p0.y, p1.z - p0.z};
}







coord image_point (coord boundaryInt, coord ghostCell)
{
     double dx = boundaryInt.x - ghostCell.x;
     double dy = boundaryInt.y - ghostCell.y;
     double dz = boundaryInt.z - ghostCell.z;

     coord imagePoint = {ghostCell.x + 2*dx, ghostCell.y + 2*dy, ghostCell.z + 2*dz};

     return imagePoint;
}






coord fresh_image_point (coord boundaryInt, coord freshCell)
{
     double dx = freshCell.x - boundaryInt.x;
     double dy = freshCell.y - boundaryInt.y;
     double dz = freshCell.z - boundaryInt.z;

     coord imagePoint = {freshCell.x + dx, freshCell.y + dy, freshCell.z + dz};

     return imagePoint;
}
#line 550 "./../ibm-gcm.h"
bool borders_boundary (Point point, int * useri, int * userj, int * userk)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;


    
#line 554 "./../ibm-gcm.h"
for (int d = 0; d < 2; d++) {
     for (int kk = -1; kk <= 1; kk += 2) {
            int _i = 0, _j = 0, _k = 0;
         if (d == 0)
                _i = kk;
            else if (d == 1)
                _j = kk;
            else if (d == 2)
                _k = kk;

            if (neighbor(-_i,-_j,-_k).pid < 0) {

                if (useri) *useri = -_i;
                if (userj) *userj = -_j;
                if (userk) *userk = -_k;

                return true;
            }
            (void) _i; (void) _j; (void) _k;
        }
    }

    return false;
}
#line 550 "./../ibm-gcm.h"
static void _stencil_borders_boundary (Point point,_stencil_undefined * useri,_stencil_undefined * userj,_stencil_undefined * userk)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;


    
#line 554 "./../ibm-gcm.h"
for (int d = 0; d < 2; d++) {
     for (int kk = -1; kk <= 1; kk += 2) {
            int _i = 0, _j = 0, _k = 0;
         if (d == 0)
                _i = kk;
            else if (d == 1)
                _j = kk;
            else if (d == 2)
                _k = kk;

_stencil_neighbor(-_i,-_j,-_k); 

                
             

               
            

(void) _i; (void) _j; (void) _k;
        }
    }

    return ;
}
#line 618 "./../ibm-gcm.h"
double extrapolate_scalar (Point point, scalar s, coord interpolatePoint, coord n, scalar p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

    
#line 621 "./../ibm-gcm.h"
double weight[5][5] = {0};
    double weightSum = 0.;
    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            if (val(s,i,j,0) > 0.5) {

                coord cellCenter = {x + Delta*i,y + Delta*j}, d;
                
                    d.x = interpolatePoint.x - cellCenter.x;                    d.y = interpolatePoint.y - cellCenter.y;

                double distanceMag = sqrt(( (d.x)*(d.x)) + ( (d.y)*(d.y)));
                double normalProjection = (n.x * d.x) + (n.y * d.y);

                weight[i][j] = ( distanceMag*distanceMag) * fabs(normalProjection);

                weightSum += weight[i][j];
            }
            else
                weight[i][j] = 0.;
        }
    }

    double interpolatedScalar = 0;

    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            interpolatedScalar += (weight[i][j]/(weightSum + 1e-30)) * val(p,i,j,0);
        }
    }
#line 685 "./../ibm-gcm.h"
    return interpolatedScalar;
}
#line 618 "./../ibm-gcm.h"
static void _stencil_extrapolate_scalar (Point point, scalar s,_stencil_undefined * interpolatePoint,_stencil_undefined * n, scalar p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;      

    
    
    
#line 623 "./../ibm-gcm.h"
for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
_stencil_val(s,i,j,0);        
#line 640
}
    }   

    

    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) { 
_stencil_val(p,i,j,0);        
}
    }
#line 685 "./../ibm-gcm.h"
    return ;
}
#line 698 "./../ibm-gcm.h"
void gauss_elim(int m, int n, double matrix[m][n], double sol[m])
{

    for (int i = 0; i < m; i++) {


        int max_row = i;
        for (int r = i + 1; r < m; r++) {
            if (fabs(matrix[r][i]) > fabs(matrix[max_row][i])) {
                max_row = r;
            }
        }


        if (max_row != i) {
            for (int c = 0; c < n; c++) {
                double temp = matrix[i][c];
                matrix[i][c] = matrix[max_row][c];
                matrix[max_row][c] = temp;
            }
        }


        if (fabs(matrix[i][i]) < 1e-12) {
            fprintf(ferr, "ERROR: Pivot is zero (matrix is singular or nearly singular)\n");
            return;
        }


        for (int r = i + 1; r < m; r++) {
            double factor = matrix[r][i] / matrix[i][i];

            for (int c = i; c < n; c++) {
                matrix[r][c] -= factor * matrix[i][c];
            }
        }
    }


    for (int i = m - 1; i >= 0; i--) {

        sol[i] = matrix[i][n - 1];


        for (int c = i + 1; c < m; c++) {
            sol[i] -= matrix[i][c] * sol[c];
        }


        sol[i] /= matrix[i][i];
    }
}
#line 761 "./../ibm-gcm.h"
int image_offsets (Point point, coord imagePoint, int *xOffset, int *yOffset, int *zOffset)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 763 "./../ibm-gcm.h"
coord ghostCell = {x,y,z};
    int offset_x = 0, offset_y = 0, offset_z = 0;
     {
        double d = fabs(imagePoint.x - ghostCell.x) / Delta;
        int dsign = ( (int)((imagePoint.x - ghostCell.x) > 0 ? 1 : -1));
        if (d >= 1.5) {
            offset_x = 2 * dsign;
        }
        else if (d >= 0.5) {
            offset_x = 1 * dsign;
        }
    } 
#line 765
{
        double d = fabs(imagePoint.y - ghostCell.y) / Delta;
        int dsign = ( (int)((imagePoint.y - ghostCell.y) > 0 ? 1 : -1));
        if (d >= 1.5) {
            offset_y = 2 * dsign;
        }
        else if (d >= 0.5) {
            offset_y = 1 * dsign;
        }
    }
    if (xOffset != NULL && yOffset != NULL) {
        *xOffset = offset_x;
        *yOffset = offset_y;
    }
    if (zOffset != NULL) {
        *zOffset = offset_z;
    }

    return 1;
}
#line 761 "./../ibm-gcm.h"
static void _stencil_image_offsets (Point point,_stencil_undefined * imagePoint,_stencil_undefined *xOffset,_stencil_undefined *yOffset,_stencil_undefined *zOffset)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;            
    
    
                       
        
         
               
         
           
            
                
         
               
     
          
         
     
     
         
     

    
#line 783 "./../ibm-gcm.h"
return ;
}
#line 798 "./../ibm-gcm.h"
extern vector u;

void fluid_only (Point point, int xx, int yy, int zz, int i, int j, int k,
                 coord * pTemp, coord * velocity, vector midPoints,
                 int bOffset_X, int bOffset_Y, int bOffset_Z,
                 vector normals, coord imagePoint)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 805 "./../ibm-gcm.h"
int off_x = xx + i, off_y = yy + j, off_z = zz + k;
    if (val(ibm,off_x,off_y,off_z) <= 0.5 && val(ibm,off_x,off_y,off_z) > 0.) {
        pTemp->x = val(midPoints.x,off_x,off_y,off_z);
        pTemp->y = val(midPoints.y,off_x,off_y,off_z);
        pTemp->z = _val_higher_dimension;

        if (local_bc_coordinates) {
            coord gcvelocity = {val(u.x,off_x, off_y, off_z),
                                val(u.y,off_x, off_y, off_z),
                                _val_higher_dimension};
            coord n = {val(normals.x,off_x, off_y, off_z),
                       val(normals.y,off_x, off_y, off_z),
                       _val_higher_dimension};
            coord t1, t2;
            normal_and_tangents (&n, &t1, &t2);
            coord gcprojVelocity = {dot_product(gcvelocity, n),
                                    dot_product(gcvelocity, t1),
                                    dot_product(gcvelocity, t2)};

            coord projVelocity = {0,0,0};

            coord boundp = {val(midPoints.x,off_x,off_y,off_z),
                            val(midPoints.y,off_x,off_y,off_z),
                            _val_higher_dimension};

            coord d = {-n.x, -n.y, -n.z};

             {
                if (bOffset_X == off_x)
                    pTemp->x += bOffset_X * Delta;

                bool bctype[2] = {false, false};


                double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, bctype);
                bool dirichlet = bctype[0], nslip = bctype[1];
                if (dirichlet) {
                    if (nslip) {
                        projVelocity.x = 0;
                        
                            pTemp->x = boundp.x + vb*d.x;                            pTemp->y = boundp.y + vb*d.y;
                    }
                    else {
                        projVelocity.x = vb;
                    }
                }
                else {
                    projVelocity.x = gcprojVelocity.x;


                }
            } 
#line 832
{
                if (bOffset_X == off_y)
                    pTemp->y += bOffset_X * Delta;

                bool bctype[2] = {false, false};


                double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, bctype);
                bool dirichlet = bctype[0], nslip = bctype[1];
                if (dirichlet) {
                    if (nslip) {
                        projVelocity.y = 0;
                        
                            pTemp->y = boundp.y + vb*d.y;                            pTemp->x = boundp.x + vb*d.x;
                    }
                    else {
                        projVelocity.y = vb;
                    }
                }
                else {
                    projVelocity.y = gcprojVelocity.y;


                }
            }

            double gcn = projVelocity.x, gct1 = projVelocity.y, gct2 = projVelocity.z;
            
                velocity->x = gcn*n.x + gct1*t1.x + gct2*t2.x;                velocity->y = gcn*n.y + gct1*t1.y + gct2*t2.y;
        }
        else {
             {
                bool dirichlet = true;
                double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, &dirichlet);
                if (dirichlet)
                    velocity->x = vb;
                else
                    velocity->x = val(u.x,xx + i, yy + j, zz + k);
                } 
#line 863
{
                bool dirichlet = true;
                double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, &dirichlet);
                if (dirichlet)
                    velocity->y = vb;
                else
                    velocity->y = val(u.y, yy + j,xx + i, zz + k);
                }
        }
    }
    (void) off_z;
}
#line 886 "./../ibm-gcm.h"
coord image_velocity (Point point, vector u, coord imagePoint, vector midPoints, vector normals)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

    
#line 889 "./../ibm-gcm.h"
int boundaryOffsetX = 0, boundaryOffsetY = 0, boundaryOffsetZ = 0;
    borders_boundary (point, &boundaryOffsetX, &boundaryOffsetY, &boundaryOffsetZ);

    int xOffset = 0, yOffset = 0, zOffset = 0;
    image_offsets (point, imagePoint, &xOffset, &yOffset, &zOffset);

    if (!(abs(xOffset) <= 2 && abs(yOffset) <= 2 && abs(zOffset) <= 2)) qassert ("./../ibm-gcm.h", 895, "abs(xOffset) <= 2 && abs(yOffset) <= 2 && abs(zOffset) <= 2");

    coord imageCell = {x + Delta*xOffset, y + Delta*yOffset, z + Delta*zOffset};

    int i = ( (int)((imagePoint.x - imageCell.x) > 0 ? 1 : -1));
    int j = ( (int)((imagePoint.y - imageCell.y) > 0 ? 1 : -1));
    int k = ( (int)((imagePoint.z - imageCell.z) > 0 ? 1 : -1));

    int xx = xOffset, yy = yOffset, zz = zOffset;

    coord velocity[(int)pow(2, 2)];
    velocity[0].x = val(u.x,xx,yy,zz);
    velocity[1].x = val(u.x,xx+i,yy,zz);
    velocity[2].x = val(u.x,xx+i,yy+j,zz);
    velocity[3].x = val(u.x,xx,yy+j,zz);

    velocity[0].y = val(u.y,xx,yy,zz);
    velocity[1].y = val(u.y,xx+i,yy,zz);
    velocity[2].y = val(u.y,xx+i,yy+j,zz);
    velocity[3].y = val(u.y,xx,yy+j,zz);
#line 937 "./../ibm-gcm.h"
    coord p0 = {imageCell.x, imageCell.y, imageCell.z};
    coord p1 = {imageCell.x + i*Delta, imageCell.y, imageCell.z};
    coord p2 = {imageCell.x + i*Delta, imageCell.y + j*Delta, imageCell.z};
    coord p3 = {imageCell.x, imageCell.y + j*Delta, imageCell.z};
#line 950 "./../ibm-gcm.h"
    fluid_only (point, xx, yy, zz, 0, 0, 0, &p0, &velocity[0], midPoints,
                boundaryOffsetX, boundaryOffsetY, boundaryOffsetZ, normals, imagePoint);

    fluid_only (point, xx, yy, zz, i, 0, 0, &p1, &velocity[1], midPoints,
                boundaryOffsetX, boundaryOffsetY, boundaryOffsetZ, normals, imagePoint);

    fluid_only (point, xx, yy, zz, i, j, 0, &p2, &velocity[2], midPoints,
                boundaryOffsetX, boundaryOffsetY, boundaryOffsetZ, normals, imagePoint);

    fluid_only (point, xx, yy, zz, 0, j, 0, &p3, &velocity[3], midPoints,
                boundaryOffsetX, boundaryOffsetY, boundaryOffsetZ, normals, imagePoint);
#line 976 "./../ibm-gcm.h"
    double vanderVelo_x[4][5] = {
        {p0.x*p0.y, p0.x, p0.y, 1, velocity[0].x},
        {p1.x*p1.y, p1.x, p1.y, 1, velocity[1].x},
        {p2.x*p2.y, p2.x, p2.y, 1, velocity[2].x},
        {p3.x*p3.y, p3.x, p3.y, 1, velocity[3].x},
    };

    double vanderVelo_y[4][5] = {
        {p0.x*p0.y, p0.x, p0.y, 1, velocity[0].y},
        {p1.x*p1.y, p1.x, p1.y, 1, velocity[1].y},
        {p2.x*p2.y, p2.x, p2.y, 1, velocity[2].y},
        {p3.x*p3.y, p3.x, p3.y, 1, velocity[3].y},
    };

    int m = 4, n = 5;
    double coeff_x[4], coeff_y[4];
#line 1030 "./../ibm-gcm.h"
    
        gauss_elim (m, n, vanderVelo_x, coeff_x);        gauss_elim (m, n, vanderVelo_y, coeff_y);

    coord temp_velo = {0,0,0};


    temp_velo.x = coeff_x[0] * imagePoint.x * imagePoint.y +
                  coeff_x[1] * imagePoint.x +
                  coeff_x[2] * imagePoint.y +
                  coeff_x[3];

    temp_velo.y = coeff_y[0] * imagePoint.x * imagePoint.y +
                  coeff_y[1] * imagePoint.x +
                  coeff_y[2] * imagePoint.y +
                  coeff_y[3];
#line 1074 "./../ibm-gcm.h"
    (void) zz; (void) k;

    return temp_velo;

}


void get_interpolation_points (Point point, const int m, coord pints[m],
                               PointIBM pnodes[m], PointIBM poff, PointIBM pnode)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1084 "./../ibm-gcm.h"
coord icell = {x + Delta*poff.i, y + Delta*poff.j, z + Delta*poff.k};

    pints[0] = (coord){icell.x, icell.y, icell.z};
    pints[1] = (coord){icell.x + pnode.i*Delta, icell.y, icell.z};
    pints[2] = (coord){icell.x + pnode.i*Delta, icell.y + pnode.j*Delta, icell.z};
    pints[3] = (coord){icell.x, icell.y + pnode.j*Delta, icell.z};

    pnodes[0] = (PointIBM){0, 0, 0};
    pnodes[1] = (PointIBM){pnode.i, 0, 0};
    pnodes[2] = (PointIBM){pnode.i, pnode.j, 0};
    pnodes[3] = (PointIBM){0, pnode.j, 0};
#line 1108 "./../ibm-gcm.h"
}





void fluid_only2 (Point point, const int n, double rmatrix[n],
                  PointIBM poff, PointIBM pnode, PointIBM pbound,
                  char dir, coord * pcell, coord velocity, coord ipoint,
                  vector midPoints, vector normals, scalar alphas)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;



    
#line 1122 "./../ibm-gcm.h"
double val = 0;
    if (dir == 'n') val = velocity.x;
    else if (dir == 't') val = velocity.y;
    else if (dir == 'r') val = velocity.z;

    int xx = poff.i + pnode.i, yy = poff.j + pnode.j, zz = poff.k + pnode.k;
    int type = 0;



    if (val(ibm,xx,yy,zz) <= 0.5 && val(ibm,xx,yy,zz) > 0.) {
        *pcell = (coord){val(midPoints.x,xx,yy,zz), val(midPoints.y,xx,yy,zz), _val_higher_dimension};


        if (xx == pbound.i) pcell->x += pbound.i*Delta;
        if (yy == pbound.j) pcell->y += pbound.j*Delta;
        if (zz == pbound.k) pcell->z += pbound.k*Delta;


        bool bctype[2] = {false, false};
        double bc = 0;

        if (dir == 'n') bc = _attribute[u.x.i].boundary[immersed] (point, point, u.x, bctype);
        else if (dir == 't') bc = _attribute[u.y.i].boundary[immersed] (point, point, u.y, bctype);



        bool dirichlet = bctype[0], navierslip = bctype[1];

        if (dirichlet && !navierslip) {
            val = bc;
            type = 0;
        }
        else if (dirichlet && navierslip) {
            if (!(dir != 'n')) qassert ("./../ibm-gcm.h", 1156, "dir != 'n'");
            val = bc;
            type = 2;
        }
        else {
            val = bc;
            type = 1;
        }
    }

    if (type == 0) {


        memcpy(rmatrix, (double[]){pcell->x*pcell->y, pcell->x, pcell->y, 1, val}, ((int)pow(2,2) + 1)*sizeof(double));





    }
    else if (type == 1) {
        coord n = {val(normals.x,xx,yy,zz), val(normals.y,xx,yy,zz), _val_higher_dimension};
        normalize(&n);

        memcpy(rmatrix, (double[]){n.x*pcell->y + n.y*pcell->x, n.x, n.y, 0, val}, ((int)pow(2,2) + 1)*sizeof(double));







    }
    else if (type == 2) {
        coord n = {val(normals.x,xx,yy,zz), val(normals.y,xx,yy,zz), _val_higher_dimension};
        double mag = sqrt(( (n.x)*(n.x)) + ( (n.y)*(n.y)) + ( (n.z)*(n.z))) + 1e-30;
        normalize(&n);
        double alpha = val(alphas,xx,yy,zz);

        coord gc = {x + xx*Delta, y + yy*Delta, z + zz*Delta}, bi;
        
            bi.x = alpha/mag * n.x;            bi.y = alpha/mag * n.y;

        
            pcell->x = gc.x + bi.x*Delta;            pcell->y = gc.y + bi.y*Delta;

        coord d = direction_vector(gc, *pcell);
        double dmag = sqrt(( (d.x)*(d.x)) + ( (d.y)*(d.y)) + ( (d.z)*(d.z)));
        double term = (1 - dmag/(val + 1e-30));


        memcpy(rmatrix, (double[]){gc.x*gc.y - (pcell->x*pcell->y)*term,
                                   gc.x - pcell->x*term,
                                   gc.y - pcell->y*term,
                                   1 - term, 0}, ((int)pow(2,2) + 1)*sizeof(double));
#line 1221 "./../ibm-gcm.h"
    }

    (void) zz;
}
#line 1114
static void _stencil_fluid_only2 (Point point,_stencil_undefined * n,_stencil_undefined * rmatrix,
_stencil_undefined * poff,_stencil_undefined * pnode,_stencil_undefined * pbound,
                  char dir,_stencil_undefined * pcell,_stencil_undefined * velocity,_stencil_undefined * ipoint,
                  vector midPoints, vector normals, scalar alphas)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;                     



       
       
       
               

    
    
#line 1132 "./../ibm-gcm.h"
_stencil_val(ibm,o_stencil,o_stencil,o_stencil); _stencil_val(ibm,o_stencil,o_stencil,o_stencil); {
_stencil_val(midPoints.x,o_stencil,o_stencil,o_stencil); _stencil_val(midPoints.y,o_stencil,o_stencil,o_stencil); _stencil_val_higher_dimension;        
#line 1144
if (dir == 'n') {default_stencil ( point,((scalar[]){ u.x,{-1}})); }
        else if (dir == 't') {default_stencil ( point,((scalar[]){ u.y,{-1}})); }      



         
              
             
         
           

           
                
              
              
         
            
              
              
         
    }

{        


        





     
    { {   
         _stencil_val_higher_dimension; _stencil_val(normals.y,o_stencil,o_stencil,o_stencil);_stencil_val(normals.x,o_stencil,o_stencil,o_stencil);          
        

        







    } 
{   
         _stencil_val_higher_dimension; _stencil_val(normals.y,o_stencil,o_stencil,o_stencil);_stencil_val(normals.x,o_stencil,o_stencil,o_stencil);              
        
        
         _stencil_val(alphas,o_stencil,o_stencil,o_stencil);                                 

        
         
               

        
                

        
        
           
                                     
                                     
                                         


        
#line 1221 "./../ibm-gcm.h"
    }}}


}


void get_interpolation_matrix (Point point, int m, int n, double matrix[m][n], char dir,
                               coord velo[m], PointIBM poff, PointIBM pnode, PointIBM pbound,
                               coord ipoint, vector midPoints, vector normals, scalar alphas)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

    
#line 1232 "./../ibm-gcm.h"
coord pints[((int)pow(2,2))];
    PointIBM pnodes[((int)pow(2,2))];
    get_interpolation_points(point, m, pints, pnodes, poff, pnode);


    for (int row = 0; row < m; ++row) {



        fluid_only2(point, n, matrix[row], poff, pnodes[row], pbound, dir,
                    &pints[row], velo[row], ipoint, midPoints, normals, alphas);
    }
}
#line 1227
static void _stencil_get_interpolation_matrix (Point point,_stencil_undefined * m,_stencil_undefined * n,_stencil_undefined * matrix, char dir,
_stencil_undefined * velo,_stencil_undefined * poff,_stencil_undefined * pnode,_stencil_undefined * pbound,
_stencil_undefined * ipoint, vector midPoints, vector normals, scalar alphas)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;       

    
    
       


          
#line 1237 "./../ibm-gcm.h"
{



        _stencil_fluid_only2(point,
NULL 
#line 1241
,
NULL 
#line 1241
,
NULL 
#line 1241
,
NULL 
#line 1241
,
NULL 
#line 1241
, dir,
NULL                    ,NULL ,NULL , midPoints, normals, alphas);
    }
}

coord image_velocity2 (Point point, vector u, coord imagePoint, PointIBM bioff,
                       vector midPoints, vector normals, scalar alphas)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

    
#line 1250 "./../ibm-gcm.h"
int boffx = 0, boffy = 0, boffz = 0;
    borders_boundary (point, &boffx, &boffy, &boffz);

    int xOffset = 0, yOffset = 0, zOffset = 0;
    image_offsets (point, imagePoint, &xOffset, &yOffset, &zOffset);

    if (!(abs(xOffset) <= 2 && abs(yOffset) <= 2 && abs(zOffset) <= 2)) qassert ("./../ibm-gcm.h", 1256, "abs(xOffset) <= 2 && abs(yOffset) <= 2 && abs(zOffset) <= 2");

    coord imageCell = {x + Delta*xOffset, y + Delta*yOffset, z + Delta*zOffset};

    int i = ( (int)((imagePoint.x - imageCell.x) > 0 ? 1 : -1));
    int j = ( (int)((imagePoint.y - imageCell.y) > 0 ? 1 : -1));
    int k = ( (int)((imagePoint.z - imageCell.z) > 0 ? 1 : -1));

    int xx = xOffset, yy = yOffset, zz = zOffset;



    coord velocity[((int)pow(2,2))];
    velocity[0].x = val(u.x,xx,yy,zz);
    velocity[1].x = val(u.x,xx+i,yy,zz);
    velocity[2].x = val(u.x,xx+i,yy+j,zz);
    velocity[3].x = val(u.x,xx,yy+j,zz);

    velocity[0].y = val(u.y,xx,yy,zz);
    velocity[1].y = val(u.y,xx+i,yy,zz);
    velocity[2].y = val(u.y,xx+i,yy+j,zz);
    velocity[3].y = val(u.y,xx,yy+j,zz);
#line 1301 "./../ibm-gcm.h"
    coord n = {val(normals.x,bioff.i,bioff.j,bioff.k),
               val(normals.y,bioff.i,bioff.j,bioff.k),
               _val_higher_dimension}, t1, t2;
    normal_and_tangents (&n, &t1, &t2);

    for (int i = 0; i < ((int)pow(2,2)); ++i) {
        coord projvelo = {dot_product(velocity[i], n),
                          dot_product(velocity[i], t1),
                          dot_product(velocity[i], t2)};
        velocity[i] = (coord){projvelo.x, projvelo.y, projvelo.z};
    }


    double veloMatrix_x[((int)pow(2,2))][((int)pow(2,2) + 1)];
    get_interpolation_matrix(point, ((int)pow(2,2)), ((int)pow(2,2) + 1), veloMatrix_x, 'n', velocity,
                            (PointIBM){xx,yy,zz}, (PointIBM){i,j,k},
                            (PointIBM){boffx,boffy,boffz}, imagePoint,
                             midPoints, normals, alphas);
    double veloMatrix_y[((int)pow(2,2))][((int)pow(2,2) + 1)];
    get_interpolation_matrix(point, ((int)pow(2,2)), ((int)pow(2,2) + 1), veloMatrix_y, 't', velocity,
                            (PointIBM){xx,yy,zz}, (PointIBM){i,j,k},
                            (PointIBM){boffx,boffy,boffz}, imagePoint,
                             midPoints, normals, alphas);

    double coeff_x[((int)pow(2,2))], coeff_y[((int)pow(2,2))];
#line 1337 "./../ibm-gcm.h"
    
        gauss_elim (((int)pow(2,2)), ((int)pow(2,2) + 1), veloMatrix_x, coeff_x);        gauss_elim (((int)pow(2,2)), ((int)pow(2,2) + 1), veloMatrix_y, coeff_y);


    coord imageVelo = {0,0,0};

    imageVelo.x = coeff_x[0] * imagePoint.x * imagePoint.y +
                  coeff_x[1] * imagePoint.x +
                  coeff_x[2] * imagePoint.y +
                  coeff_x[3];

    imageVelo.y = coeff_y[0] * imagePoint.x * imagePoint.y +
                  coeff_y[1] * imagePoint.x +
                  coeff_y[2] * imagePoint.y +
                  coeff_y[3];
#line 1383 "./../ibm-gcm.h"
    double iux = imageVelo.x, iuy = imageVelo.y, iuz = imageVelo.z;
    
        imageVelo.x = iux*n.x + iuy*t1.x + iuz*t2.x;        imageVelo.y = iux*n.y + iuy*t1.y + iuz*t2.y;

    (void) zz; (void) k;

    return imageVelo;
}
#line 1246
static void _stencil_image_velocity2 (Point point, vector u,_stencil_undefined * imagePoint,_stencil_undefined * bioff,
                       vector midPoints, vector normals, scalar alphas)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;         

    
    
#line 1251 "./../ibm-gcm.h"
_stencil_borders_boundary (point,NULL,NULL,NULL );         

    
    _stencil_image_offsets (point,NULL,NULL,NULL,NULL );                                                                   

        

    

    
    
    

     




_stencil_val(u.x,o_stencil,o_stencil,o_stencil);      
_stencil_val(u.x,o_stencil,o_stencil,o_stencil);
      _stencil_val(u.x,o_stencil,o_stencil,o_stencil);
      _stencil_val(u.x,o_stencil,o_stencil,o_stencil);
      
_stencil_val(u.y,o_stencil,o_stencil,o_stencil);      
_stencil_val(u.y,o_stencil,o_stencil,o_stencil);
      _stencil_val(u.y,o_stencil,o_stencil,o_stencil);
      _stencil_val(u.y,o_stencil,o_stencil,o_stencil);     
     
#line 1301 "./../ibm-gcm.h"
    
               
_stencil_val_higher_dimension;               
#line 1302
_stencil_val(normals.y,o_stencil,o_stencil,o_stencil);
#line 1301
_stencil_val(normals.x,o_stencil,o_stencil,o_stencil);    
                           
                           
        
            
          
    

             


    
    

_stencil_get_interpolation_matrix(point,


NULL 
#line 1315
,


NULL   
#line 1315
,


NULL 
#line 1315
, 'n',


NULL 
#line 1315
,


NULL                            
#line 1316
,

NULL 
#line 1316
,

NULL                            
#line 1317
,
NULL 
#line 1317
,
                             midPoints, normals, alphas);   
    
    _stencil_get_interpolation_matrix(point,


NULL 
#line 1320
,


NULL   
#line 1320
,


NULL 
#line 1320
, 't',


NULL 
#line 1320
,


NULL                            
#line 1321
,

NULL 
#line 1321
,

NULL                            
#line 1322
,
NULL 
#line 1322
,
                             midPoints, normals, alphas);              

    
#line 1337 "./../ibm-gcm.h"
          
        


     

          
                     
                     
                  

           
                     
                     
                  
#line 1383 "./../ibm-gcm.h"
    
    
              

       

    return ;
}
#line 1407 "./../ibm-gcm.h"
double image_pressure (Point point, scalar p, coord imagePoint)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

    
#line 1410 "./../ibm-gcm.h"
int xOffset = 0, yOffset = 0, zOffset;
    image_offsets (point, imagePoint, &xOffset, &yOffset, &zOffset);

    if (!(abs(xOffset) <= 2 && abs(yOffset) <= 2 && abs(zOffset) <= 2)) qassert ("./../ibm-gcm.h", 1413, "abs(xOffset) <= 2 && abs(yOffset) <= 2 && abs(zOffset) <= 2");

    coord imageCell = {x + Delta * xOffset, y + Delta * yOffset, z + Delta * zOffset};

    int i = ( (int)((imagePoint.x - imageCell.x) > 0 ? 1 : -1));
    int j = ( (int)((imagePoint.y - imageCell.y) > 0 ? 1 : -1));
    int k = ( (int)((imagePoint.z - imageCell.z) > 0 ? 1 : -1));

    int xx = xOffset, yy = yOffset, zz = zOffset;

    double pressure[(int)pow(2, 2)];
    pressure[0] = val(p,xx,yy,zz);
    pressure[1] = val(p,xx+i,yy,zz);
    pressure[2] = val(p,xx+i,yy+j,zz);
    pressure[3] = val(p,xx,yy+j,zz);







    coord p0 = {imageCell.x, imageCell.y, imageCell.z};
    coord p1 = {imageCell.x + i*Delta, imageCell.y, imageCell.z};
    coord p2 = {imageCell.x + i*Delta, imageCell.y + j*Delta, imageCell.z};
    coord p3 = {imageCell.x, imageCell.y + j*Delta, imageCell.z};
#line 1447 "./../ibm-gcm.h"
    double vanderPressure[4][5] = {
        {p0.x*p0.y, p0.x, p0.y, 1, pressure[0]},
        {p1.x*p1.y, p1.x, p1.y, 1, pressure[1]},
        {p2.x*p2.y, p2.x, p2.y, 1, pressure[2]},
        {p3.x*p3.y, p3.x, p3.y, 1, pressure[3]},
    };

    int m = 4, n = 5;
    double coeff[4];
#line 1472 "./../ibm-gcm.h"
    gauss_elim (m, n, vanderPressure, coeff);


    double temp_pressure = coeff[0] * imagePoint.x*imagePoint.y +
                           coeff[1] * imagePoint.x +
                           coeff[2] * imagePoint.y +
                           coeff[3];
#line 1490 "./../ibm-gcm.h"
    (void) zz; (void) k;

    return temp_pressure;
}
#line 1407 "./../ibm-gcm.h"
static void _stencil_image_pressure (Point point, scalar p,_stencil_undefined * imagePoint)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;       

    
    
#line 1411 "./../ibm-gcm.h"
_stencil_image_offsets (point,NULL,NULL,NULL,NULL );                                                                         

        

    

    
    
    

     


_stencil_val(p,o_stencil,o_stencil,o_stencil);      
_stencil_val(p,o_stencil,o_stencil,o_stencil);
      _stencil_val(p,o_stencil,o_stencil,o_stencil);
      _stencil_val(p,o_stencil,o_stencil,o_stencil);  
                                
                              
                                      
        
            
            
            
                                     
     







    
    
    
    
#line 1447 "./../ibm-gcm.h"
    

    
        
#line 1472 "./../ibm-gcm.h"
    


    
#line 1490 "./../ibm-gcm.h"
       

    return ;
}
#line 1525 "./../ibm-gcm.h"
     
int fractions_cleanup (scalar c, vector s,
         double smin, bool opposite)
{tracing("fractions_cleanup","./../ibm-gcm.h",1526);







  int changed = 1, schanged = 0, i;
  for (i = 0; i < 100 && changed; i++) {  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 1542, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 1542 "./../ibm-gcm.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
      
#line 1543 "./../ibm-gcm.h"
{_stencil_val(s.x,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,-1,0,0); _stencil_val(s.x,0,0,0);
 {_stencil_val_a(s.x,0,0,0);  }        } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
      
#line 1543 "./../ibm-gcm.h"
{_stencil_val(s.y,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,-1,0); _stencil_val(s.y,0,0,0);
 {_stencil_val_a(s.y,0,0,0);  }        }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 1542 "./../ibm-gcm.h"
{  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);
      
#line 1543 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1543 "./../ibm-gcm.h"
if (val(s.x,0,0,0) && ((!val(c,0,0,0) || !val(c,-1,0,0)) || val(s.x,0,0,0) < smin))
 val(s.x,0,0,0) = 0.;}  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);
      
#line 1543 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1543 "./../ibm-gcm.h"
if (val(s.y,0,0,0) && ((!val(c,0,0,0) || !val(c,0,-1,0)) || val(s.y,0,0,0) < smin))
 val(s.y,0,0,0) = 0.;}  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 1544 "./../ibm-gcm.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}

    
#line 1546 "./../ibm-gcm.h"
changed = 0;    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 1547, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
      
#line 1548 "./../ibm-gcm.h"
{_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
 
  {
   for (int i = 0; i <= 1; i++)
     {_stencil_val(s.x,i,0,0);
          } 









_stencil_val(s.x,0,0,0); _stencil_val(s.x,1,0,0);
     {_stencil_val_a(c,0,0,0);   }
#line 1563 "./../ibm-gcm.h"
          
 
} 
#line 1550
{
   for (int i = 0; i <= 1; i++)
     {_stencil_val(s.y,0,i,0);
          } 









_stencil_val(s.y,0,0,0); _stencil_val(s.y,0,1,0);
     {_stencil_val_a(c,0,0,0);   }
#line 1563 "./../ibm-gcm.h"
          
 
}
   







{_stencil_val_a(c,0,0,0);   }      
}      }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:changed)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;
      
#line 1548 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1548 "./../ibm-gcm.h"
if (val(c,0,0,0) > 0. && val(c,0,0,0) < 1.) {
 int n = 0;
  {
   for (int i = 0; i <= 1; i++)
     if (val(s.x,i,0,0) > 0.)
       n++;
#line 1563 "./../ibm-gcm.h"
   if (opposite && val(s.x,0,0,0) == 0. && val(s.x,1,0,0) == 0.)
     val(c,0,0,0) = 0., changed++;
 } 
#line 1550
{
   for (int i = 0; i <= 1; i++)
     if (val(s.y,0,i,0) > 0.)
       n++;
#line 1563 "./../ibm-gcm.h"
   if (opposite && val(s.y,0,0,0) == 0. && val(s.y,0,1,0) == 0.)
     val(c,0,0,0) = 0., changed++;
 }







 if (n < 2)
   val(c,0,0,0) = 0., changed++;
      }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1575 "./../ibm-gcm.h"
{mpi_all_reduce_array(&changed,MPI_INT,MPI_SUM,1);}

    schanged += changed;
  }
  if (changed)
    fprintf (ferr, "WARNING: fractions_cleanup() did not converge after "
      "%d iterations\n", i);
  {end_tracing("fractions_cleanup","./../ibm-gcm.h",1582);return schanged;}
end_tracing("fractions_cleanup","./../ibm-gcm.h",1583);}
#line 1602 "./../ibm-gcm.h"
static inline

double ibm_geometry (Point point, coord * p, coord * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1606 "./../ibm-gcm.h"
*n = facet_normal (point, ibm, ibmf);
    double alpha = line_alpha (val(ibm,0,0,0), *n);




    double area = line_length_center(*n,alpha,p);
    
        n->x *= -1;        n->y *= -1;
    normalize (n);

    return area;
}
#line 1602 "./../ibm-gcm.h"
static void 

_stencil_ibm_geometry (Point point,_stencil_undefined * p,_stencil_undefined * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 1606 "./../ibm-gcm.h"
_stencil_facet_normal (point, ibm, ibmf);    
_stencil_val(ibm,0,0,0);   




    
     
          
    

    return ;
}


static inline
double ibm0_geometry (Point point, coord * p, coord * n, scalar ibm1, vector ibmf1)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1624 "./../ibm-gcm.h"
*n = facet_normal (point, ibm1, ibmf1);
    double alpha = line_alpha (val(ibm1,0,0,0), *n);
    double area = line_length_center(*n,alpha,p);
    
        n->x *= -1;        n->y *= -1;
    normalize (n);

    return area;
}


void normalize_norm (coord n, coord * newn)
{
    double norm = fabs(n.y) + fabs(n.x) + fabs(n.z);
    coord nNorm = {n.x/norm, n.y/norm, n.z/norm};
    *newn = nNorm;
}
#line 1651 "./../ibm-gcm.h"

int borders_ghost_x (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1654 "./../ibm-gcm.h"
for (int i = -1; i <= 1; i += 2) {
        if (val(ibm,i,0,0) < 0.5 && val(ibm,i,0,0) > 0) {
            return i;
        }
    }
    return 0;
}
#line 1652
int borders_ghost_y (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1654 "./../ibm-gcm.h"
for (int i = -1; i <= 1; i += 2) {
        if (val(ibm,0,i,0) < 0.5 && val(ibm,0,i,0) > 0) {
            return i;
        }
    }
    return 0;
}
#line 1675 "./../ibm-gcm.h"
coord offset_normal (Point point, vector sf, int xoffset, int yoffset)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1677 "./../ibm-gcm.h"
if (!(abs(xoffset) <= 1 && abs(yoffset) <= 1)) qassert ("./../ibm-gcm.h", 1677, "abs(xoffset) <= 1 && abs(yoffset) <= 1");

    double nx = val(sf.x,xoffset,yoffset,0) - val(sf.x,xoffset + 1,yoffset,0);
    double ny = val(sf.y,xoffset,yoffset,0) - val(sf.y,xoffset,yoffset + 1,0);

    double mag = sqrt(( nx*nx) + ( ny*ny));

    coord n;
    if (mag == 0) {
         {
            n.x = 1./2;
        } 
#line 1686
{
            n.y = 1./2;
        }
    }
    else {
        n.x = nx / mag; n.y = ny / mag;
    }
    return n;
}
#line 1799 "./../ibm-gcm.h"

static inline double dirichlet_gradient_x (Point point, scalar s, scalar ibm,
        coord n, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;


  
#line 1806 "./../ibm-gcm.h"
double d[2], v[2] = {1e30f,1e30f};
  bool defined = true;
  
    if (defined && !val(ibmf.x,(n.x > 0.),0,0))
      defined = false;    
#line 1809
if (defined && !val(ibmf.y,0,(n.y > 0.),0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*( (int)((n.x) > 0 ? 1 : -1));
      d[l] = (i - p.x)/n.x;
      double y1 = p.y + d[l]*n.y;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

      if (val(ibmf.x,i + (i < 0),j,0) && val(ibmf.y,i,j,0) && val(ibmf.y,i,j+1,0) &&
   val(ibm,i,j-1,0) && val(ibm,i,j,0) && val(ibm,i,j+1,0))
 v[l] = ((((val(s,i,j-1,0)))*((y1) - 1.) + ((val(s,i,j+1,0)))*((y1) + 1.))*(y1)/2. - ((val(s,i,j,0)))*((y1) - 1.)*((y1) + 1.));
#line 1843 "./../ibm-gcm.h"
      else
 break;
    }



  if (v[0] == 1e30f) {





    d[0] = ( 1e-3 > (fabs(p.x/n.x)) ? 1e-3 : (fabs(p.x/n.x)));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != 1e30f)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}
#line 1800
static inline double dirichlet_gradient_y (Point point, scalar s, scalar ibm,
        coord n, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;


  
#line 1806 "./../ibm-gcm.h"
double d[2], v[2] = {1e30f,1e30f};
  bool defined = true;
  
    if (defined && !val(ibmf.y,0,(n.y > 0.),0))
      defined = false;    
#line 1809
if (defined && !val(ibmf.x,(n.x > 0.),0,0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*( (int)((n.y) > 0 ? 1 : -1));
      d[l] = (i - p.y)/n.y;
      double y1 = p.x + d[l]*n.x;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;

      if (val(ibmf.y,j,i + (i < 0),0) && val(ibmf.x,j,i,0) && val(ibmf.x,j+1,i,0) &&
   val(ibm,j-1,i,0) && val(ibm,j,i,0) && val(ibm,j+1,i,0))
 v[l] = ((((val(s,j-1,i,0)))*((y1) - 1.) + ((val(s,j+1,i,0)))*((y1) + 1.))*(y1)/2. - ((val(s,j,i,0)))*((y1) - 1.)*((y1) + 1.));
#line 1843 "./../ibm-gcm.h"
      else
 break;
    }



  if (v[0] == 1e30f) {





    d[0] = ( 1e-3 > (fabs(p.y/n.y)) ? 1e-3 : (fabs(p.y/n.y)));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != 1e30f)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}
#line 1799 "./../ibm-gcm.h"

static void _stencil_dirichlet_gradient_x (Point point, scalar s, scalar ibm,
_stencil_undefined * n,_stencil_undefined * p,_stencil_undefined * bc,
_stencil_undefined * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;       


  
  
  
    
#line 1809 "./../ibm-gcm.h"
{_stencil_val(ibmf.x,o_stencil,0,0  ); 
          }    
#line 1809
{_stencil_val(ibmf.y,0,o_stencil,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                                
       
         
      
      
        

_stencil_val(ibmf.x,    o_stencil,o_stencil,0); _stencil_val(ibmf.y,o_stencil,o_stencil,0); _stencil_val(ibmf.y,o_stencil,o_stencil,0);
   _stencil_val(ibm,o_stencil,o_stencil,0); _stencil_val(ibm,o_stencil,o_stencil,0); _stencil_val(ibm,o_stencil,o_stencil,0);
#line 1819
{
 
{_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);              }
 
#line 1844
}

            
#line 1843 "./../ibm-gcm.h"
      
    
}         
     
   



     





   
     
  







return   ;
}
#line 1800
static void _stencil_dirichlet_gradient_y (Point point, scalar s, scalar ibm,
_stencil_undefined * n,_stencil_undefined * p,_stencil_undefined * bc,
_stencil_undefined * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;       


  
  
  
    
#line 1809 "./../ibm-gcm.h"
{_stencil_val(ibmf.y,0,o_stencil,0  ); 
          }    
#line 1809
{_stencil_val(ibmf.x,o_stencil,0,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                                
       
         
      
      
        

_stencil_val(ibmf.y,o_stencil,    o_stencil,0); _stencil_val(ibmf.x,o_stencil,o_stencil,0); _stencil_val(ibmf.x,o_stencil,o_stencil,0);
   _stencil_val(ibm,o_stencil,o_stencil,0); _stencil_val(ibm,o_stencil,o_stencil,0); _stencil_val(ibm,o_stencil,o_stencil,0);
#line 1819
{
 
{_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);_stencil_val(s,o_stencil,o_stencil,0);              }
 
#line 1844
}

            
#line 1843 "./../ibm-gcm.h"
      
    
}         
     
   



     





   
     
  







return   ;
}

double dirichlet_gradient (Point point, scalar s, scalar ibm,
      coord n, coord p, double bc, double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

  
    
#line 1875 "./../ibm-gcm.h"
if (fabs(n.x) >= fabs(n.y))
      return dirichlet_gradient_x (point, s, ibm, n, p, bc, coef);    
#line 1875
if (fabs(n.y) >= fabs(n.x))
      return dirichlet_gradient_y (point, s, ibm, n, p, bc, coef);
#line 1886 "./../ibm-gcm.h"
  return 1e30f;
}
#line 1870
static void _stencil_dirichlet_gradient (Point point, scalar s, scalar ibm,
_stencil_undefined * n,_stencil_undefined * p,_stencil_undefined * bc,_stencil_undefined * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

  
      
#line 1876 "./../ibm-gcm.h"
{ _stencil_dirichlet_gradient_x (point, s, ibm,NULL ,NULL ,NULL ,NULL );}      { _stencil_dirichlet_gradient_y (point, s, ibm,NULL ,NULL ,NULL ,NULL );}
       
#line 1886 "./../ibm-gcm.h"
  return ;
}

static inline
coord ibm_gradient (Point point, vector u, coord p, coord n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1892 "./../ibm-gcm.h"
coord dudn;
     {
        bool dirichlet = false;
        double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, &dirichlet);
        if (dirichlet) {
            double val;
            dudn.x = dirichlet_gradient (point, u.x, ibm, n, p, vb, &val);
        }
        else
            dudn.x = vb;
        if (dudn.x == 1e30f)
          dudn.x = 0.;
    } 
#line 1893
{
        bool dirichlet = false;
        double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, &dirichlet);
        if (dirichlet) {
            double val;
            dudn.y = dirichlet_gradient (point, u.y, ibm, n, p, vb, &val);
        }
        else
            dudn.y = vb;
        if (dudn.y == 1e30f)
          dudn.y = 0.;
    }
    return dudn;
}
#line 1889
static void 
_stencil_ibm_gradient (Point point, vector u,_stencil_undefined * p,_stencil_undefined * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
    
     
#line 1893 "./../ibm-gcm.h"
{     
        
        default_stencil ( point,((scalar[]){ u.x,{-1}}) ); 
{ 
             
_stencil_dirichlet_gradient (point, u.x, ibm,NULL ,NULL ,NULL ,NULL );        
}    




} 
#line 1893
{     
        
        default_stencil ( point,((scalar[]){ u.y,{-1}}) ); 
{ 
             
_stencil_dirichlet_gradient (point, u.y, ibm,NULL ,NULL ,NULL ,NULL );        
}    




}
    return ;
}

double ibm_vorticity (Point point, vector u, coord p, coord n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 1910 "./../ibm-gcm.h"
coord dudn = ibm_gradient (point, u, p, n);

    return -(dudn.y*n.x - dudn.x*n.y);
}







void ibm_force (scalar p, vector u, vector mu, coord * Fp, coord * Fmu)
{
    coord Fps = {0}, Fmus = {0};
    if(!is_constant(cm) && !is_constant(fm.x)){    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 1924, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1924 "./../ibm-gcm.h"
{


_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); {     
            
             _stencil_ibm_geometry (point,NULL ,NULL ); 
_stencil_val(cm,0,0,0);             







_stencil_extrapolate_scalar (point, ibm,NULL ,NULL , p);     
            

             
                   


            if (constant(mu.x) != 0.) {      
             

              { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); 
                      _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);             
} 
#line 1948
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); 
                      _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);             
}  

                    
                 _stencil_ibm_gradient (point, u,NULL ,NULL );


                 
                        
                                                     






            }
        }    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:Fps) reduction(+:Fmus)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1924 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1924 "./../ibm-gcm.h"
{


        if (val(ibm,0,0,0) > 0. && val(ibm,0,0,0) < 1.) {
            coord midPoint, n, b;
            double area = ibm_geometry (point, &b, &n);
            area *= val(cm,0,0,0)*pow (Delta, 2 - 1);


            coord cellCenter = {x,y,z};
             {
                midPoint.x = cellCenter.x + b.x*Delta;
            } 
#line 1934
{
                midPoint.y = cellCenter.y + b.y*Delta;
            }

            double boundaryPressure = extrapolate_scalar (point, ibm, midPoint, n, p);
            double Fn = area * boundaryPressure;

            
                Fps.x -= Fn * n.x;                Fps.y -= Fn * n.y;


            if (constant(mu.x) != 0.) {
             double mua = 0., fa = 0.;

              {
                    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
                    fa += val(fm.x,0,0,0) + val(fm.x,1,0,0);
             } 
#line 1948
{
                    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
                    fa += val(fm.y,0,0,0) + val(fm.y,0,1,0);
             }

                mua /= (fa + 1e-30);
                coord velocityGrad = ibm_gradient (point, u, b, n);


                
                    Fmus.x -= area * mua* (velocityGrad.x * (( (n.x)*(n.x)) + 1.) +
                                           velocityGrad.y * -n.x * -n.y);                    
#line 1958
Fmus.y -= area * mua* (velocityGrad.y * (( (n.y)*(n.y)) + 1.) +
                                           velocityGrad.x * -n.y * -n.x);






            }
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1968 "./../ibm-gcm.h"
{mpi_all_reduce_array((double *)&Fmus,MPI_DOUBLE,MPI_SUM,sizeof(Fmus)/sizeof(double));mpi_all_reduce_array((double *)&Fps,MPI_DOUBLE,MPI_SUM,sizeof(Fps)/sizeof(double));}}else if(is_constant(cm) && !is_constant(fm.x)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 1924, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1924 "./../ibm-gcm.h"
{


_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); {     
            
             _stencil_ibm_geometry (point,NULL ,NULL );
;             







_stencil_extrapolate_scalar (point, ibm,NULL ,NULL , p);     
            

             
                   


            if (constant(mu.x) != 0.) {      
             

              { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); 
                      _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);             
} 
#line 1948
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); 
                      _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);             
}  

                    
                 _stencil_ibm_gradient (point, u,NULL ,NULL );


                 
                        
                                                     






            }
        }    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:Fps) reduction(+:Fmus)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1924 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1924 "./../ibm-gcm.h"
{


        if (val(ibm,0,0,0) > 0. && val(ibm,0,0,0) < 1.) {
            coord midPoint, n, b;
            double area = ibm_geometry (point, &b, &n);
            area *= _const_cm*pow (Delta, 2 - 1);


            coord cellCenter = {x,y,z};
             {
                midPoint.x = cellCenter.x + b.x*Delta;
            } 
#line 1934
{
                midPoint.y = cellCenter.y + b.y*Delta;
            }

            double boundaryPressure = extrapolate_scalar (point, ibm, midPoint, n, p);
            double Fn = area * boundaryPressure;

            
                Fps.x -= Fn * n.x;                Fps.y -= Fn * n.y;


            if (constant(mu.x) != 0.) {
             double mua = 0., fa = 0.;

              {
                    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
                    fa += val(fm.x,0,0,0) + val(fm.x,1,0,0);
             } 
#line 1948
{
                    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
                    fa += val(fm.y,0,0,0) + val(fm.y,0,1,0);
             }

                mua /= (fa + 1e-30);
                coord velocityGrad = ibm_gradient (point, u, b, n);


                
                    Fmus.x -= area * mua* (velocityGrad.x * (( (n.x)*(n.x)) + 1.) +
                                           velocityGrad.y * -n.x * -n.y);                    
#line 1958
Fmus.y -= area * mua* (velocityGrad.y * (( (n.y)*(n.y)) + 1.) +
                                           velocityGrad.x * -n.y * -n.x);






            }
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1968 "./../ibm-gcm.h"
{mpi_all_reduce_array((double *)&Fmus,MPI_DOUBLE,MPI_SUM,sizeof(Fmus)/sizeof(double));mpi_all_reduce_array((double *)&Fps,MPI_DOUBLE,MPI_SUM,sizeof(Fps)/sizeof(double));}}else if(!is_constant(cm) && is_constant(fm.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 1924, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1924 "./../ibm-gcm.h"
{


_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); {     
            
             _stencil_ibm_geometry (point,NULL ,NULL ); 
_stencil_val(cm,0,0,0);             







_stencil_extrapolate_scalar (point, ibm,NULL ,NULL , p);     
            

             
                   


            if (constant(mu.x) != 0.) {      
             

              { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);
;;             
} 
#line 1948
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);
;;             
}  

                    
                 _stencil_ibm_gradient (point, u,NULL ,NULL );


                 
                        
                                                     






            }
        }    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:Fps) reduction(+:Fmus)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1924 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1924 "./../ibm-gcm.h"
{


        if (val(ibm,0,0,0) > 0. && val(ibm,0,0,0) < 1.) {
            coord midPoint, n, b;
            double area = ibm_geometry (point, &b, &n);
            area *= val(cm,0,0,0)*pow (Delta, 2 - 1);


            coord cellCenter = {x,y,z};
             {
                midPoint.x = cellCenter.x + b.x*Delta;
            } 
#line 1934
{
                midPoint.y = cellCenter.y + b.y*Delta;
            }

            double boundaryPressure = extrapolate_scalar (point, ibm, midPoint, n, p);
            double Fn = area * boundaryPressure;

            
                Fps.x -= Fn * n.x;                Fps.y -= Fn * n.y;


            if (constant(mu.x) != 0.) {
             double mua = 0., fa = 0.;

              {
                    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
                    fa += _const_fm.x + _const_fm.x;
             } 
#line 1948
{
                    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
                    fa += _const_fm.y + _const_fm.y;
             }

                mua /= (fa + 1e-30);
                coord velocityGrad = ibm_gradient (point, u, b, n);


                
                    Fmus.x -= area * mua* (velocityGrad.x * (( (n.x)*(n.x)) + 1.) +
                                           velocityGrad.y * -n.x * -n.y);                    
#line 1958
Fmus.y -= area * mua* (velocityGrad.y * (( (n.y)*(n.y)) + 1.) +
                                           velocityGrad.x * -n.y * -n.x);






            }
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1968 "./../ibm-gcm.h"
{mpi_all_reduce_array((double *)&Fmus,MPI_DOUBLE,MPI_SUM,sizeof(Fmus)/sizeof(double));mpi_all_reduce_array((double *)&Fps,MPI_DOUBLE,MPI_SUM,sizeof(Fps)/sizeof(double));}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 1924, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1924 "./../ibm-gcm.h"
{


_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); {     
            
             _stencil_ibm_geometry (point,NULL ,NULL );
;             







_stencil_extrapolate_scalar (point, ibm,NULL ,NULL , p);     
            

             
                   


            if (constant(mu.x) != 0.) {      
             

              { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);
;;             
} 
#line 1948
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);
;;             
}  

                    
                 _stencil_ibm_gradient (point, u,NULL ,NULL );


                 
                        
                                                     






            }
        }    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:Fps) reduction(+:Fmus)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1924 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1924 "./../ibm-gcm.h"
{


        if (val(ibm,0,0,0) > 0. && val(ibm,0,0,0) < 1.) {
            coord midPoint, n, b;
            double area = ibm_geometry (point, &b, &n);
            area *= _const_cm*pow (Delta, 2 - 1);


            coord cellCenter = {x,y,z};
             {
                midPoint.x = cellCenter.x + b.x*Delta;
            } 
#line 1934
{
                midPoint.y = cellCenter.y + b.y*Delta;
            }

            double boundaryPressure = extrapolate_scalar (point, ibm, midPoint, n, p);
            double Fn = area * boundaryPressure;

            
                Fps.x -= Fn * n.x;                Fps.y -= Fn * n.y;


            if (constant(mu.x) != 0.) {
             double mua = 0., fa = 0.;

              {
                    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
                    fa += _const_fm.x + _const_fm.x;
             } 
#line 1948
{
                    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
                    fa += _const_fm.y + _const_fm.y;
             }

                mua /= (fa + 1e-30);
                coord velocityGrad = ibm_gradient (point, u, b, n);


                
                    Fmus.x -= area * mua* (velocityGrad.x * (( (n.x)*(n.x)) + 1.) +
                                           velocityGrad.y * -n.x * -n.y);                    
#line 1958
Fmus.y -= area * mua* (velocityGrad.y * (( (n.y)*(n.y)) + 1.) +
                                           velocityGrad.x * -n.y * -n.x);






            }
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1968 "./../ibm-gcm.h"
{mpi_all_reduce_array((double *)&Fmus,MPI_DOUBLE,MPI_SUM,sizeof(Fmus)/sizeof(double));mpi_all_reduce_array((double *)&Fps,MPI_DOUBLE,MPI_SUM,sizeof(Fps)/sizeof(double));}}
    *Fp = Fps;
    *Fmu = Fmus;
}







double skin_friction (vector u, vector mu, scalar cf)
{
    double cftotal = 0;
    if(!is_constant(fm.x)){    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 1982, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1982 "./../ibm-gcm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);{ {    
            
             _stencil_ibm_geometry (point,NULL ,NULL );      
                  


            

             { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); 
                  _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);         
} 
#line 1991
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); 
                  _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);         
}  

                
             _stencil_ibm_gradient (point, u,NULL ,NULL );   
            




             
                       
                                    
            _stencil_val_a(cf,0,0,0); 







_stencil_val(cf,0,0,0);        
}
            
{_stencil_val_a(cf,0,0,0);  }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:cftotal)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1982 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1982 "./../ibm-gcm.h"
{
        if (val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1) {
            coord n, b;
            double area = ibm_geometry (point, &b, &n);
            area *= pow (Delta, 2 - 1);


            double mua = 0., fa = 0.;

             {
                mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
                fa += val(fm.x,0,0,0) + val(fm.x,1,0,0);
         } 
#line 1991
{
                mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
                fa += val(fm.y,0,0,0) + val(fm.y,0,1,0);
         }

            mua /= (fa + 1e-30);
            coord dudn = ibm_gradient (point, u, b, n);
            coord tau = {0,0,0};




            
                tau.x -= mua* (dudn.x * (( (n.x)*(n.x)) + 1.) +
                               dudn.y * -n.x * -n.y);                
#line 2004
tau.y -= mua* (dudn.y * (( (n.y)*(n.y)) + 1.) +
                               dudn.x * -n.y * -n.x);
            val(cf,0,0,0) = sqrt(( (tau.x)*(tau.x)) + ( (tau.y)*(tau.y)));







            cftotal += val(cf,0,0,0);
        }
        else
            val(cf,0,0,0) = 0;
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 2018 "./../ibm-gcm.h"
{mpi_all_reduce_array(&cftotal,MPI_DOUBLE,MPI_SUM,1);}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 1982, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1982 "./../ibm-gcm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);{ {    
            
             _stencil_ibm_geometry (point,NULL ,NULL );      
                  


            

             { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);
;;         
} 
#line 1991
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);
;;         
}  

                
             _stencil_ibm_gradient (point, u,NULL ,NULL );   
            




             
                       
                                    
            _stencil_val_a(cf,0,0,0); 







_stencil_val(cf,0,0,0);        
}
            
{_stencil_val_a(cf,0,0,0);  }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:cftotal)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1982 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1982 "./../ibm-gcm.h"
{
        if (val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1) {
            coord n, b;
            double area = ibm_geometry (point, &b, &n);
            area *= pow (Delta, 2 - 1);


            double mua = 0., fa = 0.;

             {
                mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
                fa += _const_fm.x + _const_fm.x;
         } 
#line 1991
{
                mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
                fa += _const_fm.y + _const_fm.y;
         }

            mua /= (fa + 1e-30);
            coord dudn = ibm_gradient (point, u, b, n);
            coord tau = {0,0,0};




            
                tau.x -= mua* (dudn.x * (( (n.x)*(n.x)) + 1.) +
                               dudn.y * -n.x * -n.y);                
#line 2004
tau.y -= mua* (dudn.y * (( (n.y)*(n.y)) + 1.) +
                               dudn.x * -n.y * -n.x);
            val(cf,0,0,0) = sqrt(( (tau.x)*(tau.x)) + ( (tau.y)*(tau.y)));







            cftotal += val(cf,0,0,0);
        }
        else
            val(cf,0,0,0) = 0;
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 2018 "./../ibm-gcm.h"
{mpi_all_reduce_array(&cftotal,MPI_DOUBLE,MPI_SUM,1);}}
    return cftotal;
}
#line 2032 "./../ibm-gcm.h"
static inline double bilinear_ibm (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 2034 "./../ibm-gcm.h"
if (!coarse(ibm,0,0,0) || !coarse(ibm,child.x,0,0)) {
        return coarse(s,0,0,0);
    }

    if (!coarse(ibm,0,child.y,0) || !coarse(ibm,child.x,child.y,0)) {
        return coarse(s,0,0,0);
    }
#line 2050 "./../ibm-gcm.h"
    return bilinear (point, s);
}
#line 2032 "./../ibm-gcm.h"
static void _stencil_bilinear_ibm (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 2034 "./../ibm-gcm.h"
_stencil_coarse(ibm,0,0,0);_stencil_coarse(ibm,o_stencil,0,0); { 
_stencil_coarse(s,0,0,0);    
}

_stencil_coarse(ibm,0,o_stencil,0);_stencil_coarse(ibm,o_stencil,o_stencil,0); { 
_stencil_coarse(s,0,0,0);    
} 









_stencil_bilinear (point, s);
       

       
#line 2050 "./../ibm-gcm.h"
    return;
}






static void gradients_ibm (scalar * f, vector * g)
{
  if (!(list_len(f) == vectors_len(g))) qassert ("./../ibm-gcm.h", 2060, "list_len(f) == vectors_len(g)");  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 2061, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 2061 "./../ibm-gcm.h"
{
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {

_stencil_val(ibmf.x,0,0,0);_stencil_val(ibmf.x,1,0,0);{
        {_stencil_val_a(v.x,0,0,0);  }

     
{_stencil_val(s,-1,0,0); _stencil_val(s,0,0,0); _stencil_val(s,1,0,0);_stencil_val_a(v.x,0,0,0);   }} 
} 
#line 2065
{

_stencil_val(ibmf.y,0,0,0);_stencil_val(ibmf.y,0,1,0);{
        {_stencil_val_a(v.y,0,0,0);  }

     
{_stencil_val(s,0,-1,0); _stencil_val(s,0,0,0); _stencil_val(s,0,1,0);_stencil_val_a(v.y,0,0,0);   }} 
}}
      else
 { {

_stencil_val(ibmf.x,0,0,0);_stencil_val(ibmf.x,1,0,0);{
        {_stencil_val_a(v.x,0,0,0);  }

     
{_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0);_stencil_val_a(v.x,0,0,0);   }} 
} 
#line 2074
{

_stencil_val(ibmf.y,0,0,0);_stencil_val(ibmf.y,0,1,0);{
        {_stencil_val_a(v.y,0,0,0);  }

     
{_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0);_stencil_val_a(v.y,0,0,0);   }} 
}}
    }}}
  }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 2061 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 2061 "./../ibm-gcm.h"
{
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {

      if (!val(ibmf.x,0,0,0) || !val(ibmf.x,1,0,0))
        val(v.x,0,0,0) = 0.;
      else

     val(v.x,0,0,0) = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0))/Delta;
 } 
#line 2065
{

      if (!val(ibmf.y,0,0,0) || !val(ibmf.y,0,1,0))
        val(v.y,0,0,0) = 0.;
      else

     val(v.y,0,0,0) = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0))/Delta;
 }}
      else
 { {

      if (!val(ibmf.x,0,0,0) || !val(ibmf.x,1,0,0))
        val(v.x,0,0,0) = 0.;
      else

     val(v.x,0,0,0) = (val(s,1,0,0) - val(s,-1,0,0))/(2.*Delta);
 } 
#line 2074
{

      if (!val(ibmf.y,0,0,0) || !val(ibmf.y,0,1,0))
        val(v.y,0,0,0) = 0.;
      else

     val(v.y,0,0,0) = (val(s,0,1,0) - val(s,0,-1,0))/(2.*Delta);
 }}
    }}}
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}

#line 2084 "./../ibm-gcm.h"
}


static inline double vertex_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;

    
#line 2090 "./../ibm-gcm.h"
return (4.*val(s,0,0,0) +
         2.*(val(s,0,1,0) + val(s,0,-1,0) + val(s,1,0,0) + val(s,-1,0,0)) +
         val(s,-1,-1,0) + val(s,1,-1,0) + val(s,1,1,0) + val(s,-1,1,0))/16.;
#line 2102 "./../ibm-gcm.h"
}







int local_to_global (Point point, coord p, double* ax, double* ay, double* az)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 2112 "./../ibm-gcm.h"
*ax = x + p.x * Delta;
    *ay= y + p.y * Delta;
    *az = z + p.z * Delta;

    return 0;
}
#line 2126 "./../ibm-gcm.h"
int copy_coord (coord p, double* ax, double* ay, double* az)
{
    *ax = p.x;
    *ay = p.y;
    *az = p.z;

    return 1;
}



double ibm_flux_x (Point point, scalar s, vector mu, double * val)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 2139 "./../ibm-gcm.h"
*val = 0.;
    if (val(ibm,0,0,0) >= 1. || val(ibm,0,0,0) <= 0.)
        return 0.;


    coord n = facet_normal (point, ibm, ibmf), mp;
    double alpha = line_alpha (val(ibm,0,0,0), n);
    double area = line_length_center(n,alpha,&mp);
    normalize (&n);
    
        n.x *= -1;        n.y *= -1;



    double mpx, mpy, mpz;
    local_to_global(point, mp, &mpx, &mpy, &mpz);


    bool dirichlet = false;
    double bc = _attribute[s.i].boundary[immersed] (point, point, s, &dirichlet);

    double coef = 0.;


    double grad = dirichlet_gradient (point, s, ibm, n, mp, bc, &coef);
    double mua = 0., fa = 0.;
     {
        mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
        fa += val(ibmf.x,0,0,0) + val(ibmf.x,1,0,0);
    } 
#line 2165
{
        mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        fa += val(ibmf.y,0,0,0) + val(ibmf.y,0,1,0);
    }

    *val = - mua/(fa + 1e-30)*grad*area/Delta;
    return - mua/(fa + 1e-30)*coef*area/Delta;
}
#line 2137
double ibm_flux_y (Point point, scalar s, vector mu, double * val)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 2139 "./../ibm-gcm.h"
*val = 0.;
    if (val(ibm,0,0,0) >= 1. || val(ibm,0,0,0) <= 0.)
        return 0.;


    coord n = facet_normal (point, ibm, ibmf), mp;
    double alpha = line_alpha (val(ibm,0,0,0), n);
    double area = line_length_center(n,alpha,&mp);
    normalize (&n);
    
        n.y *= -1;        n.x *= -1;



    double mpx, mpy, mpz;
    local_to_global(point, mp, &mpx, &mpy, &mpz);


    bool dirichlet = false;
    double bc = _attribute[s.i].boundary[immersed] (point, point, s, &dirichlet);

    double coef = 0.;


    double grad = dirichlet_gradient (point, s, ibm, n, mp, bc, &coef);
    double mua = 0., fa = 0.;
     {
        mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        fa += val(ibmf.y,0,0,0) + val(ibmf.y,0,1,0);
    } 
#line 2165
{
        mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
        fa += val(ibmf.x,0,0,0) + val(ibmf.x,1,0,0);
    }

    *val = - mua/(fa + 1e-30)*grad*area/Delta;
    return - mua/(fa + 1e-30)*coef*area/Delta;
}
#line 2185 "./../ibm-gcm.h"

static inline double ibm_face_gradient_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 2188 "./../ibm-gcm.h"
int j = ( (int)((val(ibmf.x,i,1,0) - val(ibmf.x,i,-1,0)) > 0 ? 1 : -1));
  if (!(val(ibm,i,0,0) && val(ibm,i-1,0,0))) qassert ("./../ibm-gcm.h", 2189, "ibm[i] && ibm[i-1]");
  if ((val(ibmf.x,i,j,0) > 0.5 && val(ibmf.y,i,j + (j < 0),0) && val(ibmf.y,i-1,j + (j < 0),0) && val(ibm,i,j,0) && val(ibm,i-1,j,0)))
    return ((1. + val(ibmf.x,i,0,0))*(val(a,i,0,0) - val(a,i-1,0,0)) +
     (1. - val(ibmf.x,i,0,0))*(val(a,i,j,0) - val(a,i-1,j,0)))/(2.*Delta);
  return (val(a,i,0,0) - val(a,i-1,0,0))/Delta;
}
#line 2186
static inline double ibm_face_gradient_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 2188 "./../ibm-gcm.h"
int j = ( (int)((val(ibmf.y,1,i,0) - val(ibmf.y,-1,i,0)) > 0 ? 1 : -1));
  if (!(val(ibm,0,i,0) && val(ibm,0,i-1,0))) qassert ("./../ibm-gcm.h", 2189, "ibm[i] && ibm[i-1]");
  if ((val(ibmf.y,j,i,0) > 0.5 && val(ibmf.x,j + (j < 0),i,0) && val(ibmf.x,j + (j < 0),i-1,0) && val(ibm,j,i,0) && val(ibm,j,i-1,0)))
    return ((1. + val(ibmf.y,0,i,0))*(val(a,0,i,0) - val(a,0,i-1,0)) +
     (1. - val(ibmf.y,0,i,0))*(val(a,j,i,0) - val(a,j,i-1,0)))/(2.*Delta);
  return (val(a,0,i,0) - val(a,0,i-1,0))/Delta;
}


static inline double ibm_face_value_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 2199 "./../ibm-gcm.h"
int j = ( (int)((val(ibmf.x,i,1,0) - val(ibmf.x,i,-1,0)) > 0 ? 1 : -1));
  return (val(ibmf.x,i,j,0) > 0.5 && val(ibmf.y,i,j + (j < 0),0) && val(ibmf.y,i-1,j + (j < 0),0) && val(ibm,i,j,0) && val(ibm,i-1,j,0)) ?
    ((1. + val(ibmf.x,i,0,0))*((val(a,i,0,0)*(1.5 + val(ibm,i,0,0)) + val(a,i-1,0,0)*(1.5 + val(ibm,i-1,0,0)))/ (val(ibm,i,0,0) + val(ibm,i-1,0,0) + 3.)) + (1. - val(ibmf.x,i,0,0))*((val(a,i,j,0)*(1.5 + val(ibm,i,j,0)) + val(a,i-1,j,0)*(1.5 + val(ibm,i-1,j,0)))/ (val(ibm,i,j,0) + val(ibm,i-1,j,0) + 3.)))/2. :
    ((val(a,i,0,0)*(1.5 + val(ibm,i,0,0)) + val(a,i-1,0,0)*(1.5 + val(ibm,i-1,0,0)))/ (val(ibm,i,0,0) + val(ibm,i-1,0,0) + 3.));
}
#line 2197
static inline double ibm_face_value_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 2199 "./../ibm-gcm.h"
int j = ( (int)((val(ibmf.y,1,i,0) - val(ibmf.y,-1,i,0)) > 0 ? 1 : -1));
  return (val(ibmf.y,j,i,0) > 0.5 && val(ibmf.x,j + (j < 0),i,0) && val(ibmf.x,j + (j < 0),i-1,0) && val(ibm,j,i,0) && val(ibm,j,i-1,0)) ?
    ((1. + val(ibmf.y,0,i,0))*((val(a,0,i,0)*(1.5 + val(ibm,0,i,0)) + val(a,0,i-1,0)*(1.5 + val(ibm,0,i-1,0)))/ (val(ibm,0,i,0) + val(ibm,0,i-1,0) + 3.)) + (1. - val(ibmf.y,0,i,0))*((val(a,j,i,0)*(1.5 + val(ibm,j,i,0)) + val(a,j,i-1,0)*(1.5 + val(ibm,j,i-1,0)))/ (val(ibm,j,i,0) + val(ibm,j,i-1,0) + 3.)))/2. :
    ((val(a,0,i,0)*(1.5 + val(ibm,0,i,0)) + val(a,0,i-1,0)*(1.5 + val(ibm,0,i-1,0)))/ (val(ibm,0,i,0) + val(ibm,0,i-1,0) + 3.));
}
#line 2197
static void _stencil_ibm_face_value_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;           
   
#line 2199 "./../ibm-gcm.h"
_stencil_val(ibmf.x,i,-1,0);_stencil_val(ibmf.x,i,1,0);
_stencil_val(ibmf.x,i,o_stencil,0); _stencil_val(ibmf.y,i,o_stencil,0    ); _stencil_val(ibmf.y,i-1,o_stencil,0    ); _stencil_val(ibm,i,o_stencil,0); _stencil_val(ibm,i-1,o_stencil,0); 
_stencil_val(ibmf.x,i,0,0);_stencil_val(a,i,0,0); _stencil_val(ibm,i,0,0); _stencil_val(a,i-1,0,0); _stencil_val(ibm,i-1,0,0);_stencil_val(ibm,i,0,0); _stencil_val(ibm,i-1,0,0); _stencil_val(ibmf.x,i,0,0);_stencil_val(a,i,o_stencil,0); _stencil_val(ibm,i,o_stencil,0); _stencil_val(a,i-1,o_stencil,0); _stencil_val(ibm,i-1,o_stencil,0);_stencil_val(ibm,i,o_stencil,0); _stencil_val(ibm,i-1,o_stencil,0);
_stencil_val(a,i,0,0); _stencil_val(ibm,i,0,0); _stencil_val(a,i-1,0,0); _stencil_val(ibm,i-1,0,0);_stencil_val(ibm,i,0,0); _stencil_val(ibm,i-1,0,0);  
#line 2200
return                  
                    
    ;
}
#line 2197
static void _stencil_ibm_face_value_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;           
   
#line 2199 "./../ibm-gcm.h"
_stencil_val(ibmf.y,-1,i,0);_stencil_val(ibmf.y,1,i,0);
_stencil_val(ibmf.y,o_stencil,i,0); _stencil_val(ibmf.x,o_stencil,i,0    ); _stencil_val(ibmf.x,o_stencil,i-1,0    ); _stencil_val(ibm,o_stencil,i,0); _stencil_val(ibm,o_stencil,i-1,0); 
_stencil_val(ibmf.y,0,i,0);_stencil_val(a,0,i,0); _stencil_val(ibm,0,i,0); _stencil_val(a,0,i-1,0); _stencil_val(ibm,0,i-1,0);_stencil_val(ibm,0,i,0); _stencil_val(ibm,0,i-1,0); _stencil_val(ibmf.y,0,i,0);_stencil_val(a,o_stencil,i,0); _stencil_val(ibm,o_stencil,i,0); _stencil_val(a,o_stencil,i-1,0); _stencil_val(ibm,o_stencil,i-1,0);_stencil_val(ibm,o_stencil,i,0); _stencil_val(ibm,o_stencil,i-1,0);
_stencil_val(a,0,i,0); _stencil_val(ibm,0,i,0); _stencil_val(a,0,i-1,0); _stencil_val(ibm,0,i-1,0);_stencil_val(ibm,0,i,0); _stencil_val(ibm,0,i-1,0);  
#line 2200
return                  
                    
    ;
}
#line 2323 "./../ibm-gcm.h"
#line 1 "../ibm-tree.h"
#line 1 "./../ibm-tree.h"
#line 17 "./../ibm-tree.h"
static void ibm_fraction_refine (Point point, scalar ibm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 19 "./../ibm-tree.h"
double cc = val(ibm,0,0,0);





  if (cc <= 0. || cc >= 1.) {
  
    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;      
#line 27 "./../ibm-tree.h"
val(ibm,0,0,0) = cc;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 28 "./../ibm-tree.h"
}
  else {






    coord n = facet_normal (point, ibm, ibmf);
    double alpha = line_alpha (cc, n);
  

    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 39 "./../ibm-tree.h"
{
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
     nc.x = child.x*n.x;     nc.y = child.y*n.y;
      val(ibm,0,0,0) = rectangle_fraction (nc, alpha, a, b);
    }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 46 "./../ibm-tree.h"
}
}








static void ibm_face_fraction_refine_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 58 "./../ibm-tree.h"
vector ibmf = _attribute[s.i].v;




  if (val(ibm,0,0,0) <= 0. || val(ibm,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
     fine(ibmf.x,1,j,k) = val(ibm,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0) && neighbor(2*i-1,0,0).neighbors &&
      (is_local(cell) || is_local(neighbor(2*i-1,0,0))))
     for (int j = 0; j <= 1; j++)
          for (int k = 0; k <= 1; k++)
            fine(ibmf.x,2*i,j,k) = val(ibmf.x,i,0,0);
  }
  else {






    coord n = facet_normal (point, ibm, ibmf);
    double alpha = line_alpha (val(ibm,0,0,0), n);
#line 102 "./../ibm-tree.h"
    if (2.*fabs(alpha) < fabs(n.y)) {
      double yc = alpha/n.y;
      int i = yc > 0.;
      fine(ibmf.x,1,1 - i,0) = n.y < 0. ? 1. - i : i;
      fine(ibmf.x,1,i,0) = n.y < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(ibmf.x,1,0,0) = fine(ibmf.x,1,1,0) = alpha > 0.;
#line 134 "./../ibm-tree.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(2*i-1,0,0).neighbors && (is_local(cell) || is_local(neighbor(2*i-1,0,0)))) {
     if (!(!is_leaf (neighbor(2*i-1,0,0)) && neighbor(2*i-1,0,0).neighbors && neighbor(2*i-1,0,0).pid >= 0)) {
       if (val(ibmf.x,i,0,0) <= 0. || val(ibmf.x,i,0,0) >= 1.)
         for (int j = 0; j <= 1; j++)
           for (int k = 0; k <= 1; k++)
          fine(ibmf.x,2*i,j,k) = val(ibmf.x,i,0,0);
       else {






         double a = val(ibmf.y,0,1,0) <= 0. || val(ibmf.y,2*i-1,1,0) <= 0. ||
                    val(ibmf.y,0,0,0) >= 1. || val(ibmf.y,2*i-1,0,0) >= 1.;
         if ((2.*a - 1)*(val(ibmf.x,i,0,0) - 0.5) > 0.) {
           fine(ibmf.x,2*i,0,0) = a;
           fine(ibmf.x,2*i,1,0) = 2.*val(ibmf.x,i,0,0) - a;
         }
         else {
           fine(ibmf.x,2*i,0,0) = 2.*val(ibmf.x,i,0,0) + a - 1.;
           fine(ibmf.x,2*i,1,0) = 1. - a;
         }
#line 175 "./../ibm-tree.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(ibmf.x,2*i,j,k) && !fine(ibm,i,j,k))
       fine(ibmf.x,2*i,j,k) = 0.;
      }
  }

}
#line 56
static void ibm_face_fraction_refine_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 58 "./../ibm-tree.h"
vector ibmf = _attribute[s.i].v;




  if (val(ibm,0,0,0) <= 0. || val(ibm,0,0,0) >= 1.) {





    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
     fine(ibmf.y,j,1,k) = val(ibm,0,0,0);
    for (int i = 0; i <= 1; i++)
      if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0) && neighbor(0,2*i-1,0).neighbors &&
      (is_local(cell) || is_local(neighbor(0,2*i-1,0))))
     for (int j = 0; j <= 1; j++)
          for (int k = 0; k <= 1; k++)
            fine(ibmf.y,j,2*i,k) = val(ibmf.y,0,i,0);
  }
  else {






    coord n = facet_normal (point, ibm, ibmf);
    double alpha = line_alpha (val(ibm,0,0,0), n);
#line 102 "./../ibm-tree.h"
    if (2.*fabs(alpha) < fabs(n.x)) {
      double yc = alpha/n.x;
      int i = yc > 0.;
      fine(ibmf.y,1 - i,1,0) = n.x < 0. ? 1. - i : i;
      fine(ibmf.y,i,1,0) = n.x < 0. ? i - 2.*yc : 1. - i + 2.*yc;
    }
    else
      fine(ibmf.y,0,1,0) = fine(ibmf.y,1,1,0) = alpha > 0.;
#line 134 "./../ibm-tree.h"
    for (int i = 0; i <= 1; i++)
      if (neighbor(0,2*i-1,0).neighbors && (is_local(cell) || is_local(neighbor(0,2*i-1,0)))) {
     if (!(!is_leaf (neighbor(0,2*i-1,0)) && neighbor(0,2*i-1,0).neighbors && neighbor(0,2*i-1,0).pid >= 0)) {
       if (val(ibmf.y,0,i,0) <= 0. || val(ibmf.y,0,i,0) >= 1.)
         for (int j = 0; j <= 1; j++)
           for (int k = 0; k <= 1; k++)
          fine(ibmf.y,j,2*i,k) = val(ibmf.y,0,i,0);
       else {






         double a = val(ibmf.x,1,0,0) <= 0. || val(ibmf.x,1,2*i-1,0) <= 0. ||
                    val(ibmf.x,0,0,0) >= 1. || val(ibmf.x,0,2*i-1,0) >= 1.;
         if ((2.*a - 1)*(val(ibmf.y,0,i,0) - 0.5) > 0.) {
           fine(ibmf.y,0,2*i,0) = a;
           fine(ibmf.y,1,2*i,0) = 2.*val(ibmf.y,0,i,0) - a;
         }
         else {
           fine(ibmf.y,0,2*i,0) = 2.*val(ibmf.y,0,i,0) + a - 1.;
           fine(ibmf.y,1,2*i,0) = 1. - a;
         }
#line 175 "./../ibm-tree.h"
   }
 }




 for (int j = 0; j <= 1; j++)



     if (fine(ibmf.y,j,2*i,k) && !fine(ibm,j,i,k))
       fine(ibmf.y,j,2*i,k) = 0.;
      }
  }

}
#line 208 "./../ibm-tree.h"




static inline void restriction_ibm_linear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 215 "./../ibm-tree.h"
if (!val(ibm,0,0,0)) {
    val(s,0,0,0) = 0.;
    return;
  }






  double val = 0., nv = 0.;
  for (int i = 0; i <= 1; i++)



      if (fine(ibm,0,i,j) && fine(ibm,1,!i,!j))
     val += (fine(s,0,i,j) + fine(s,1,!i,!j))/2., nv++;
  if (nv > 0.) {
    val(s,0,0,0) = val/nv;
    return;
  }





  coord p = {0.,0.,0.};
  

  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 243 "./../ibm-tree.h"
{
    if (val(ibm,0,0,0))
      p.x += x, p.y += y, p.z += z, val += val(s,0,0,0), nv++;
   }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 247 "./../ibm-tree.h"
if (!(nv > 0.)) qassert ("./../ibm-tree.h", 247, "nv > 0.");
  val(s,0,0,0) = val/nv;






  if (_attribute[s.i].ibm_gradient && _attribute[s.i].boundary[0] != _attribute[s.i].boundary_homogeneous[0]) {
    coord o = {x,y,z}, g;
    _attribute[s.i].ibm_gradient (point, s, &g);
    
      val(s,0,0,0) += (o.x - p.x/nv)*g.x;      val(s,0,0,0) += (o.y - p.y/nv)*g.y;
  }
}
#line 272 "./../ibm-tree.h"
static inline void refine_ibm_linear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 274 "./../ibm-tree.h"
{
    if (!val(ibm,0,0,0))
      val(s,0,0,0) = 0.;
    else {
      if (!(coarse(ibm,0,0,0))) qassert ("./../ibm-tree.h", 278, "coarse(ibm)");
      int i = (child.x + 1)/2, j = (child.y + 1)/2;

      if (coarse(ibmf.x,i,0,0) && coarse(ibmf.y,0,j,0) &&
   (coarse(ibm,0,0,0) == 1. || coarse(ibm,child.x,0,0) == 1. ||
    coarse(ibm,0,child.y,0) == 1. || coarse(ibm,child.x,child.y,0) == 1.)) {
 if (!(coarse(ibm,child.x,0,0) && coarse(ibm,0,child.y,0))) qassert ("./../ibm-tree.h", 284, "coarse(ibm,child.x) && coarse(ibm,0,child.y)");
 if (coarse(ibmf.x,i,child.y,0) && coarse(ibmf.y,child.x,j,0)) {

   if (!(coarse(ibm,child.x,child.y,0))) qassert ("./../ibm-tree.h", 287, "coarse(ibm,child.x,child.y)");
   val(s,0,0,0) = (9.*coarse(s,0,0,0) +
   3.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0)) +
   coarse(s,child.x,child.y,0))/16.;
 }
 else

   val(s,0,0,0) = (2.*coarse(s,0,0,0) + coarse(s,child.x,0,0) + coarse(s,0,child.y,0))/4.;
      }
      else if (coarse(ibm,child.x,child.y,0) &&
        ((coarse(ibmf.x,i,0,0) && coarse(ibmf.y,child.x,j,0)) ||
  (coarse(ibmf.y,0,j,0) && coarse(ibmf.x,i,child.y,0)))) {

 val(s,0,0,0) = (3.*coarse(s,0,0,0) + coarse(s,child.x,child.y,0))/4.;
      }
#line 350 "./../ibm-tree.h"
      else {

 val(s,0,0,0) = coarse(s,0,0,0);
  {
   if (coarse(ibmf.x,(child.x + 1)/2,0,0) && coarse(ibm,child.x,0,0))
     val(s,0,0,0) += (coarse(s,child.x,0,0) - coarse(s,0,0,0))/4.;
   else if (coarse(ibmf.x,(- child.x + 1)/2,0,0) && coarse(ibm,- child.x,0,0))
     val(s,0,0,0) -= (coarse(s,- child.x,0,0) - coarse(s,0,0,0))/4.;
 } 
#line 353
{
   if (coarse(ibmf.y,0,(child.y + 1)/2,0) && coarse(ibm,0,child.y,0))
     val(s,0,0,0) += (coarse(s,0,child.y,0) - coarse(s,0,0,0))/4.;
   else if (coarse(ibmf.y,0,(- child.y + 1)/2,0) && coarse(ibm,0,- child.y,0))
     val(s,0,0,0) -= (coarse(s,0,- child.y,0) - coarse(s,0,0,0))/4.;
 }
      }
    }
  }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 362 "./../ibm-tree.h"
}
#line 373 "./../ibm-tree.h"

void refine_ibm_face_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 376 "./../ibm-tree.h"
vector v = _attribute[s.i].v;
  for (int i = 0; i <= 1; i++)
    if (neighbor(2*i - 1,0,0).neighbors &&
 (is_local(cell) || is_local(neighbor(2*i - 1,0,0)))) {
      double g1 = val(ibmf.x,i,0,0) >= 1. && val(ibmf.x,i,+1,0) && val(ibmf.x,i,-1,0) ?
 (val(v.x,i,+1,0)/val(ibmf.x,i,+1,0) - val(v.x,i,-1,0)/val(ibmf.x,i,-1,0))/8. : 0.;
      double g2 = val(ibmf.x,i,0,0) >= 1. && val(ibmf.x,i,0,+1) && val(ibmf.x,i,0,-1) ?
 (val(v.x,i,0,+1)/val(ibmf.x,i,0,+1) - val(v.x,i,0,-1)/val(ibmf.x,i,0,-1))/8. : 0.;
      for (int j = 0; j <= 1; j++)
 for (int k = 0; k <= 1; k++)
   fine(v.x,2*i,j,k) = val(ibmf.x,i,0,0) ?
     fine(ibmf.x,2*i,j,k)*(val(v.x,i,0,0)/val(ibmf.x,i,0,0) +
    (2*j - 1)*g1 + (2*k - 1)*g2) : 0.;
    }
  if (is_local(cell)) {
    double g1 = (val(ibmf.x,0,+1,0) + val(ibmf.x,1,+1,0)) && (val(ibmf.x,0,-1,0) + val(ibmf.x,1,-1,0)) ?
      ((val(v.x,0,+1,0) + val(v.x,1,+1,0))/(val(ibmf.x,0,+1,0) + val(ibmf.x,1,+1,0)) -
       (val(v.x,0,-1,0) + val(v.x,1,-1,0))/(val(ibmf.x,0,-1,0) + val(ibmf.x,1,-1,0)))/8. : 0.;
    double g2 = (val(ibmf.x,1,0,+1) + val(ibmf.x,0,0,+1)) && (val(ibmf.x,1,0,-1) + val(ibmf.x,0,0,-1)) ?
      ((val(v.x,0,0,+1) + val(v.x,1,0,+1))/(val(ibmf.x,1,0,+1) + val(ibmf.x,0,0,+1)) -
       (val(v.x,0,0,-1) + val(v.x,1,0,-1))/(val(ibmf.x,1,0,-1) + val(ibmf.x,0,0,-1)))/8. : 0.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(v.x,1,j,k) = val(ibmf.x,0,0,0) + val(ibmf.x,1,0,0) ?
   fine(ibmf.x,1,j,k)*((val(v.x,0,0,0) + val(v.x,1,0,0))/(val(ibmf.x,0,0,0) + val(ibmf.x,1,0,0)) +
       (2*j - 1)*g1 + (2*k - 1)*g2) : 0.;
  }
}
#line 374
void refine_ibm_face_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 376 "./../ibm-tree.h"
vector v = _attribute[s.i].v;
  for (int i = 0; i <= 1; i++)
    if (neighbor(0,2*i - 1,0).neighbors &&
 (is_local(cell) || is_local(neighbor(0,2*i - 1,0)))) {
      double g1 = val(ibmf.y,0,i,0) >= 1. && val(ibmf.y,+1,i,0) && val(ibmf.y,-1,i,0) ?
 (val(v.y,+1,i,0)/val(ibmf.y,+1,i,0) - val(v.y,-1,i,0)/val(ibmf.y,-1,i,0))/8. : 0.;
      double g2 = val(ibmf.y,0,i,0) >= 1. && val(ibmf.y,0,i,+1) && val(ibmf.y,0,i,-1) ?
 (val(v.y,0,i,+1)/val(ibmf.y,0,i,+1) - val(v.y,0,i,-1)/val(ibmf.y,0,i,-1))/8. : 0.;
      for (int j = 0; j <= 1; j++)
 for (int k = 0; k <= 1; k++)
   fine(v.y,j,2*i,k) = val(ibmf.y,0,i,0) ?
     fine(ibmf.y,j,2*i,k)*(val(v.y,0,i,0)/val(ibmf.y,0,i,0) +
    (2*j - 1)*g1 + (2*k - 1)*g2) : 0.;
    }
  if (is_local(cell)) {
    double g1 = (val(ibmf.y,+1,0,0) + val(ibmf.y,+1,1,0)) && (val(ibmf.y,-1,0,0) + val(ibmf.y,-1,1,0)) ?
      ((val(v.y,+1,0,0) + val(v.y,+1,1,0))/(val(ibmf.y,+1,0,0) + val(ibmf.y,+1,1,0)) -
       (val(v.y,-1,0,0) + val(v.y,-1,1,0))/(val(ibmf.y,-1,0,0) + val(ibmf.y,-1,1,0)))/8. : 0.;
    double g2 = (val(ibmf.y,0,1,+1) + val(ibmf.y,0,0,+1)) && (val(ibmf.y,0,1,-1) + val(ibmf.y,0,0,-1)) ?
      ((val(v.y,0,0,+1) + val(v.y,0,1,+1))/(val(ibmf.y,0,1,+1) + val(ibmf.y,0,0,+1)) -
       (val(v.y,0,0,-1) + val(v.y,0,1,-1))/(val(ibmf.y,0,1,-1) + val(ibmf.y,0,0,-1)))/8. : 0.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 fine(v.y,j,1,k) = val(ibmf.y,0,0,0) + val(ibmf.y,0,1,0) ?
   fine(ibmf.y,j,1,k)*((val(v.y,0,0,0) + val(v.y,0,1,0))/(val(ibmf.y,0,0,0) + val(ibmf.y,0,1,0)) +
       (2*j - 1)*g1 + (2*k - 1)*g2) : 0.;
  }
}


static void refine_metric_injection_x (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 408 "./../ibm-tree.h"
vector v = _attribute[s.i].v;
    double val = (val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7)? 1.: val(ibm,0,0,0);    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
        
#line 411 "./../ibm-tree.h"
val(v.x,0,0,0) = val;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }

#line 412 "./../ibm-tree.h"
}
#line 406
static void refine_metric_injection_y (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 408 "./../ibm-tree.h"
vector v = _attribute[s.i].v;
    double val = (val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7)? 1.: val(ibm,0,0,0);    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
        
#line 411 "./../ibm-tree.h"
val(v.y,0,0,0) = val;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }

#line 412 "./../ibm-tree.h"
}


static inline void face_max_metric (Point point, vector v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
   
#line 417 "./../ibm-tree.h"
{

      val(v.x,0,0,0) = ( (fine(v.x,0,0,0)) > (fine(v.x,0,1,0)) ? (fine(v.x,0,0,0)) : (fine(v.x,0,1,0)));
      val(v.x,1,0,0) = ( (fine(v.x,2,0,0)) > (fine(v.x,2,1,0)) ? (fine(v.x,2,0,0)) : (fine(v.x,2,1,0)));






  } 
#line 417
{

      val(v.y,0,0,0) = ( (fine(v.y,0,0,0)) > (fine(v.y,1,0,0)) ? (fine(v.y,0,0,0)) : (fine(v.y,1,0,0)));
      val(v.y,0,1,0) = ( (fine(v.y,0,2,0)) > (fine(v.y,1,2,0)) ? (fine(v.y,0,2,0)) : (fine(v.y,1,2,0)));






  }
}


static inline void restriction_face_metric (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 433 "./../ibm-tree.h"
face_max_metric (point, _attribute[s.i].v);

}


static inline void restriction_cell_metric (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;




   
#line 444 "./../ibm-tree.h"
double val = val(s,0,0,0);   
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
     
#line 446 "./../ibm-tree.h"
val(s,0,0,0) = val;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }

#line 447 "./../ibm-tree.h"
}


static void fraction_refine_metric (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 452 "./../ibm-tree.h"
double cc = val(ibm,0,0,0);





  if (cc <= 0. || cc >= 1.) {    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
      
#line 460 "./../ibm-tree.h"
val(s,0,0,0) = cc;      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 461 "./../ibm-tree.h"
}
  else {






    coord n = facet_normal (point, ibm, ibmf);
    double alpha = line_alpha (cc, n);    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 472 "./../ibm-tree.h"
{
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      
     nc.x = child.x*n.x;     nc.y = child.y*n.y;
      val(s,0,0,0) = rectangle_fraction (nc, alpha, a, b) > 0.5;
    }      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
  
#line 479 "./../ibm-tree.h"
}
}
#line 2326 "./../ibm-gcm.h"
static int metric_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}
#line 2324 "./../ibm-gcm.h"


      static int metric(const int i,const double t,Event *_ev){tracing("metric","./../ibm-gcm.h",2326);
{
    if (is_constant (fm.x)) {
        
            if (!(constant (fm.x) == 1.)) qassert ("./../ibm-gcm.h", 2330, "constant (fm.x) == 1.");            if (!(constant (fm.y) == 1.)) qassert ("./../ibm-gcm.h", 2330, "constant (fm.x) == 1.");
        fm = ibmFaces;
    }  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 2333, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 2333 "./../ibm-gcm.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 2333 "./../ibm-gcm.h"
{
        _stencil_val_a(ibmFaces.x,0,0,0);  
        _stencil_val_a(ibmf.x,0,0,0);  
    } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 2333 "./../ibm-gcm.h"
{
        _stencil_val_a(ibmFaces.y,0,0,0);  
        _stencil_val_a(ibmf.y,0,0,0);  
    }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 2333 "./../ibm-gcm.h"
{  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 2333 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 2333 "./../ibm-gcm.h"
{
        val(ibmFaces.x,0,0,0) = 1.;
        val(ibmf.x,0,0,0) = 1;
    }}  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 2333 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 2333 "./../ibm-gcm.h"
{
        val(ibmFaces.y,0,0,0) = 1.;
        val(ibmf.y,0,0,0) = 1;
    }}  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 2336 "./../ibm-gcm.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
    
#line 2337 "./../ibm-gcm.h"
if (is_constant (cm)) {
        if (!(constant (cm) == 1.)) qassert ("./../ibm-gcm.h", 2338, "constant (cm) == 1.");
        cm = ibmCells;
    }    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm.h", .line = 2341, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 2341 "./../ibm-gcm.h"
{
        _stencil_val_a(ibmCells,0,0,0);  
        _stencil_val_a(ibm,0,0,0);  
        _stencil_val_a(ibm0,0,0,0);  
    }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 2341 "./../ibm-gcm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 2341 "./../ibm-gcm.h"
{
        val(ibmCells,0,0,0) = 1.;
        val(ibm,0,0,0) = 1.;
        val(ibm0,0,0,0) = 1.;
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}






    
#line 2352 "./../ibm-gcm.h"
_attribute[ibmCells.i].refine = fraction_refine_metric;
    _attribute[ibmCells.i].prolongation = fraction_refine_metric;




    _attribute[ibm0.i].refine = _attribute[ibm.i].refine = ibm_fraction_refine;
    _attribute[ibm0.i].prolongation = _attribute[ibm.i].prolongation = fraction_refine;

     {
        _attribute[ibmFaces.x.i].prolongation = refine_metric_injection_x;
        _attribute[ibmf.x.i].prolongation = ibm_face_fraction_refine_x;
        _attribute[ibmFaces.x.i].restriction = restriction_face_metric;
    } 
#line 2361
{
        _attribute[ibmFaces.y.i].prolongation = refine_metric_injection_y;
        _attribute[ibmf.y.i].prolongation = ibm_face_fraction_refine_y;
        _attribute[ibmFaces.y.i].restriction = restriction_face_metric;
    }
#line 2385 "./../ibm-gcm.h"
    restriction (((scalar[]){ibm, ibmf.x, ibmf.y, ibmFaces.x, ibmFaces.y, ibmCells,{-1}}));

    boundary_internal ((scalar *)all, "./../ibm-gcm.h", 2387);
}{end_tracing("metric","./../ibm-gcm.h",2388);return 0;}end_tracing("metric","./../ibm-gcm.h",2388);}
#line 4 "sessile-ibm-axi-osc.c"
#line 1 "../my-axi.h"
#line 1 "./../my-axi.h"
#line 20 "./../my-axi.h"
static void refine_cm_axi (Point point, scalar cm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 45 "./../my-axi.h"
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 46 "./../my-axi.h"
val(cm,0,0,0) = y*(val(ibm,0,0,0) > 0);
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 48 "./../my-axi.h"
}

static void refine_face_x_axi (Point point, scalar fm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 86 "./../my-axi.h"
  if (!(!is_leaf (neighbor(-1,0,0)) && neighbor(-1,0,0).neighbors && neighbor(-1,0,0).pid >= 0)) {
    fine(fm,0,0,0) = (y - Delta/4.)*fine(ibmFaces.x,0,0,0);
    fine(fm,0,1,0) = (y + Delta/4.)*fine(ibmFaces.x,0,1,0);
  }
  if (!(!is_leaf (neighbor(1,0,0)) && neighbor(1,0,0).neighbors && neighbor(1,0,0).pid >= 0) && neighbor(1,0,0).neighbors) {
    fine(fm,2,0,0) = (y - Delta/4.)*fine(ibmFaces.x,2,0,0);
    fine(fm,2,1,0) = (y + Delta/4.)*fine(ibmFaces.x,2,1,0);
  }
  fine(fm,1,0,0) = (y - Delta/4.)*fine(ibmFaces.x,1,0,0);
  fine(fm,1,1,0) = (y + Delta/4.)*fine(ibmFaces.x,1,1,0);

}

static void refine_face_y_axi (Point point, scalar fm)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 119 "./../my-axi.h"
  if (!(!is_leaf (neighbor(0,-1,0)) && neighbor(0,-1,0).neighbors && neighbor(0,-1,0).pid >= 0)) {
    fine(fm,0,0,0) = (( (y - Delta/2.) > 1e-20 ? (y - Delta/2.) : 1e-20))*fine(ibmFaces.y,0,0,0) ;
    fine(fm,1,0,0) = (( (y - Delta/2.) > 1e-20 ? (y - Delta/2.) : 1e-20))*fine(ibmFaces.y,1,0,0);
  }
  if (!(!is_leaf (neighbor(0,1,0)) && neighbor(0,1,0).neighbors && neighbor(0,1,0).pid >= 0) && neighbor(0,1,0).neighbors) {
    fine(fm,0,2,0) = (y + Delta/2.)*fine(ibmFaces.y,0,2,0);
    fine(fm,1,2,0) = (y + Delta/2.)*fine(ibmFaces.y,1,2,0);
  }
  fine(fm,0,1,0) = y*fine(ibmFaces.y,0,1,0);
  fine(fm,1,1,0) = y*fine(ibmFaces.y,1,1,0);

}
#line 177 "./../my-axi.h"
double axi_factor (Point point, coord p) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 178 "./../my-axi.h"
return y;
}






static double _boundary0(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 186 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 186 "./../my-axi.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, (y*val(ibm,0,0,0)) : 2.*(y*val(ibm,0,0,0)) - val(_s,0,0,0)));}}}static double _boundary0_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 186 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 186 "./../my-axi.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
static double _boundary1(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 187 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 187 "./../my-axi.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, (y*val(ibm,0,0,0)) : 2.*(y*val(ibm,0,0,0)) - val(_s,0,0,0)));}}}static double _boundary1_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 187 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 187 "./../my-axi.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
#line 181
void cm_update (scalar cm, scalar ibmCells)
{
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-axi.h", .line = 183, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 183 "./../my-axi.h"
{
_stencil_val(ibm,0,0,0);    _stencil_val_a(cm,0,0,0);    
  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 183 "./../my-axi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 183 "./../my-axi.h"
{
    val(cm,0,0,0) = y*(val(ibm,0,0,0) > 0);
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 186 "./../my-axi.h"
_attribute[cm.i].dirty=1,_attribute[cm.i].boundary[top]=_boundary0,_attribute[cm.i].boundary_homogeneous[top]=_boundary0_homogeneous;
_attribute[cm.i].dirty=1,_attribute[cm.i].boundary[bottom]=_boundary1,_attribute[cm.i].boundary_homogeneous[bottom]=_boundary1_homogeneous;
}









static double _boundary2(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 198 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 198 "./../my-axi.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, (y*val(ibmFaces.x,0,0,0)) : 2.*(y*val(ibmFaces.x,0,0,0)) - val(_s,0,0,0)));}}}static double _boundary2_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 198 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 198 "./../my-axi.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
static double _boundary3(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 199 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 199 "./../my-axi.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, (y*val(ibmFaces.x,0,0,0)) : 2.*(y*val(ibmFaces.x,0,0,0)) - val(_s,0,0,0)));}}}static double _boundary3_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 199 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 199 "./../my-axi.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
#line 190
void fm_update (vector fm, vector ibmFaces)
{
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-axi.h", .line = 192, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 192 "./../my-axi.h"
{
_stencil_val(ibmFaces.x,0,0,0);    _stencil_val_a(fm.x,0,0,0);  
  } 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 698
{
  if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 192 "./../my-axi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 192 "./../my-axi.h"
{
    val(fm.x,0,0,0) = y*val(ibmFaces.x,0,0,0);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-axi.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1);    
#line 196 "./../my-axi.h"
{_stencil_val(ibmFaces.y,0,0,0);_stencil_val_a(fm.y,0,0,0);         } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 706
{
  if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 196 "./../my-axi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 196 "./../my-axi.h"
val(fm.y,0,0,0) = ( y > 1e-20 ? y : 1e-20)*val(ibmFaces.y,0,0,0);}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 198 "./../my-axi.h"
_attribute[fm.y.i].dirty=1,_attribute[fm.y.i].boundary[top]=_boundary2,_attribute[fm.y.i].boundary_homogeneous[top]=_boundary2_homogeneous;
_attribute[fm.y.i].dirty=1,_attribute[fm.y.i].boundary[bottom]=_boundary3,_attribute[fm.y.i].boundary_homogeneous[bottom]=_boundary3_homogeneous;
}
#line 237
static double _boundary4(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 237 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 237 "./../my-axi.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, y : 2.*y - val(_s,0,0,0)));}}}static double _boundary4_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 237 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 237 "./../my-axi.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
static double _boundary5(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 238 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 238 "./../my-axi.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, y : 2.*y - val(_s,0,0,0)));}}}static double _boundary5_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 238 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 238 "./../my-axi.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
#line 256
static double _boundary6(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 256 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 256 "./../my-axi.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, y : 2.*y - val(_s,0,0,0)));}}}static double _boundary6_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 256 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 256 "./../my-axi.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
static double _boundary7(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 257 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 257 "./../my-axi.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, y : 2.*y - val(_s,0,0,0)));}}}static double _boundary7_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 257 "./../my-axi.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 257 "./../my-axi.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
#line 203
static int metric_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int metric_0(const int i,const double t,Event *_ev){tracing("metric_0","./../my-axi.h",203); {







  if (is_constant(cm)) {
    scalar * l = list_copy (all);
    cm = new_scalar("cm");
    pfree (all,__func__,__FILE__,__LINE__);
    all = list_concat (((scalar[]){cm,{-1}}), l);
    pfree (l,__func__,__FILE__,__LINE__);
  }
#line 226 "./../my-axi.h"
  metric_ibm_factor = axi_factor;







  scalar cmv = cm;
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-axi.h", .line = 235, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 236 "./../my-axi.h"
{_stencil_val_a(cmv,0,0,0);  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 236 "./../my-axi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 236 "./../my-axi.h"
val(cmv,0,0,0) = y;}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 237 "./../my-axi.h"
_attribute[cm.i].dirty=1,_attribute[cm.i].boundary[top]=_boundary4,_attribute[cm.i].boundary_homogeneous[top]=_boundary4_homogeneous;
_attribute[cm.i].dirty=1,_attribute[cm.i].boundary[bottom]=_boundary5,_attribute[cm.i].boundary_homogeneous[bottom]=_boundary5_homogeneous;







  if (is_constant(fm.x)) {
    scalar * l = list_copy (all);
    fm = new_face_vector("fm");
    pfree (all,__func__,__FILE__,__LINE__);
    all = list_concat ((scalar *)((vector[]){fm,{{-1},{-1}}}), l);
    pfree (l,__func__,__FILE__,__LINE__);
  }
  vector fmv = fm;
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-axi.h", .line = 254, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 254 "./../my-axi.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 255 "./../my-axi.h"
{_stencil_val_a(fmv.x,0,0,0);         } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 255 "./../my-axi.h"
{_stencil_val_a(fmv.y,0,0,0);         }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 254 "./../my-axi.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 255 "./../my-axi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 255 "./../my-axi.h"
val(fmv.x,0,0,0) = ( y > (1./1e30f) ? y : (1./1e30f));}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 255 "./../my-axi.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 255 "./../my-axi.h"
val(fmv.y,0,0,0) = ( y > (1./1e30f) ? y : (1./1e30f));}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 255 "./../my-axi.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 256 "./../my-axi.h"
_attribute[fm.y.i].dirty=1,_attribute[fm.y.i].boundary[top]=_boundary6,_attribute[fm.y.i].boundary_homogeneous[top]=_boundary6_homogeneous;
_attribute[fm.y.i].dirty=1,_attribute[fm.y.i].boundary[bottom]=_boundary7,_attribute[fm.y.i].boundary_homogeneous[bottom]=_boundary7_homogeneous;





  _attribute[cm.i].refine = _attribute[cm.i].prolongation = refine_cm_axi;
  _attribute[fm.x.i].prolongation = refine_face_x_axi;
  _attribute[fm.y.i].prolongation = refine_face_y_axi;

}{end_tracing("metric_0","./../my-axi.h",267);return 0;}end_tracing("metric_0","./../my-axi.h",267);}
#line 5 "sessile-ibm-axi-osc.c"
#line 1 "../my-centered.h"
#line 1 "./../my-centered.h"
#line 28 "./../my-centered.h"
#line 1 "./run.h"
#line 1 "/home/spencer/basilisk/src/run.h"
#line 9 "/home/spencer/basilisk/src/run.h"
double dt = 1.;

#line 1 "./utils.h"
#line 1 "/home/spencer/basilisk/src/utils.h"







double DT = 1e30f, CFL = 0.5;




struct {

  long nc;

  long tnc;

  double t, tp;

  double speed;

  double ispeed;

  timer gt;
} perf = {0};





void update_perf() {
  perf.nc += grid->n;
  perf.tnc += grid->tn;
  perf.t = timer_elapsed (perf.gt);
  perf.speed = perf.tnc/perf.t;
  perf.ispeed = grid->tn/(perf.t - perf.tp);
  perf.tp = perf.t;
}






typedef struct {
  double cpu;
  double real;
  double speed;
  double min;
  double avg;
  double max;
  size_t tnc;
  long mem;
} timing;






timing timer_timing (timer t, int i, size_t tnc, double * mpi)
{
  timing s;



  clock_t end = clock();
  s.cpu = ((double) (end - t.c))/CLOCKS_PER_SEC;
  s.real = timer_elapsed (t);
  if (tnc == 0) {
    double n = 0; 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:n)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 73 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 73 "/home/spencer/basilisk/src/utils.h"
n++;}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 73 "/home/spencer/basilisk/src/utils.h"
{mpi_all_reduce_array(&n,MPI_DOUBLE,MPI_SUM,1);}
    s.tnc = n;
    tnc = n*i;
  }
  else
    s.tnc = tnc;





  s.mem = 0;
#line 99 "/home/spencer/basilisk/src/utils.h"
  s.min = s.max = s.avg = 0.;

  s.speed = s.real > 0. ? tnc/s.real : -1.;
  return s;
}




void timer_print (timer t, int i, size_t tnc)
{



  timing s = timer_timing (t, i, tnc, NULL);
  fprintf (fout,
    "\n# " "Quadtree"
    ", %d steps, %g CPU, %.4g real, %.3g points.step/s, %d var\n",
    i, s.cpu, s.real, s.speed, (int) (datasize/sizeof(real)));
#line 127 "/home/spencer/basilisk/src/utils.h"
  fflush (fout);
}







typedef struct {
  double avg, rms, max, volume;
} norm;

norm normf (scalar f)
{
  double avg = 0., rms = 0., max = 0., volume = 0.;
  if(!is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 143, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 145 "/home/spencer/basilisk/src/utils.h"
{_stencil_val(f,0,0,0);_stencil_val(cm,0,0,0); {   
      _stencil_val(f,0,0,0);   
         
_stencil_val(cm,0,0,0); 
        _stencil_val(cm,0,0,0); 
        _stencil_val(cm,0,0,0);    
}        }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:max) reduction(+:avg)   reduction(+:rms) reduction(+:volume)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 145 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 145 "/home/spencer/basilisk/src/utils.h"
if (val(f,0,0,0) != 1e30f && (( Delta*Delta)*val(cm,0,0,0)) > 0.) {
      double v = fabs(val(f,0,0,0));
      if (v > max) max = v;
      volume += (( Delta*Delta)*val(cm,0,0,0));
      avg += (( Delta*Delta)*val(cm,0,0,0))*v;
      rms += (( Delta*Delta)*val(cm,0,0,0))*( v*v);
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 151 "/home/spencer/basilisk/src/utils.h"
{mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&rms,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&avg,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 143, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 145 "/home/spencer/basilisk/src/utils.h"
{_stencil_val(f,0,0,0);; {   
      _stencil_val(f,0,0,0);

;
;
;    
}        }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:max) reduction(+:avg)   reduction(+:rms) reduction(+:volume)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 145 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 145 "/home/spencer/basilisk/src/utils.h"
if (val(f,0,0,0) != 1e30f && (( Delta*Delta)*_const_cm) > 0.) {
      double v = fabs(val(f,0,0,0));
      if (v > max) max = v;
      volume += (( Delta*Delta)*_const_cm);
      avg += (( Delta*Delta)*_const_cm)*v;
      rms += (( Delta*Delta)*_const_cm)*( v*v);
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 151 "/home/spencer/basilisk/src/utils.h"
{mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&rms,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&avg,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);}}
  norm n;
  n.avg = volume ? avg/volume : 0.;
  n.rms = volume ? sqrt(rms/volume) : 0.;
  n.max = max;
  n.volume = volume;
  return n;
}





typedef struct {
  double min, max, sum, stddev, volume;
} stats;

stats statsf (scalar f)
{
  double min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
  if(!is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 171, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 173 "/home/spencer/basilisk/src/utils.h"
{_stencil_val(cm,0,0,0); _stencil_val(f,0,0,0); {
_stencil_val(cm,0,0,0); 
        _stencil_val(cm,0,0,0);_stencil_val(f,0,0,0); 
        _stencil_val(cm,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0); 
         _stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }
_stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }    
}       }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:sum) reduction(+:sum2) reduction(+:volume)   reduction(max:max) reduction(min:min)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 173 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 173 "/home/spencer/basilisk/src/utils.h"
if ((( Delta*Delta)*val(cm,0,0,0)) > 0. && val(f,0,0,0) != 1e30f) {
      volume += (( Delta*Delta)*val(cm,0,0,0));
      sum += (( Delta*Delta)*val(cm,0,0,0))*val(f,0,0,0);
      sum2 += (( Delta*Delta)*val(cm,0,0,0))*( (val(f,0,0,0))*(val(f,0,0,0)));
      if (val(f,0,0,0) > max) max = val(f,0,0,0);
      if (val(f,0,0,0) < min) min = val(f,0,0,0);
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 179 "/home/spencer/basilisk/src/utils.h"
{mpi_all_reduce_array(&min,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&sum2,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&sum,MPI_DOUBLE,MPI_SUM,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 171, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 173 "/home/spencer/basilisk/src/utils.h"
{; _stencil_val(f,0,0,0); {
;
;_stencil_val(f,0,0,0);
;_stencil_val(f,0,0,0);_stencil_val(f,0,0,0); 
         _stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }
_stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }    
}       }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:sum) reduction(+:sum2) reduction(+:volume)   reduction(max:max) reduction(min:min)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 173 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 173 "/home/spencer/basilisk/src/utils.h"
if ((( Delta*Delta)*_const_cm) > 0. && val(f,0,0,0) != 1e30f) {
      volume += (( Delta*Delta)*_const_cm);
      sum += (( Delta*Delta)*_const_cm)*val(f,0,0,0);
      sum2 += (( Delta*Delta)*_const_cm)*( (val(f,0,0,0))*(val(f,0,0,0)));
      if (val(f,0,0,0) > max) max = val(f,0,0,0);
      if (val(f,0,0,0) < min) min = val(f,0,0,0);
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 179 "/home/spencer/basilisk/src/utils.h"
{mpi_all_reduce_array(&min,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&sum2,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&sum,MPI_DOUBLE,MPI_SUM,1);}}
  stats s;
  s.min = min, s.max = max, s.sum = sum, s.volume = volume;
  if (volume > 0.)
    sum2 -= sum*sum/volume;
  s.stddev = sum2 > 0. ? sqrt(sum2/volume) : 0.;
  return s;
}
#line 195 "/home/spencer/basilisk/src/utils.h"
static double generic_limiter (double r, double beta)
{
  double v1 = ( r < beta ? r : beta), v2 = ( (beta*r) < 1. ? (beta*r) : 1.);
  v1 = ( 0. > v1 ? 0. : v1);
  return ( v1 > v2 ? v1 : v2);
}

double minmod (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.)*(s1 - s0);
}

double superbee (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 2.)*(s1 - s0);
}

double sweby (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.5)*(s1 - s0);
}
#line 221 "/home/spencer/basilisk/src/utils.h"
double theta = 1.3;

double minmod2 (double s0, double s1, double s2)
{
  if (s0 < s1 && s1 < s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 < d1) d1 = d2;
    return ( d1 < d3 ? d1 : d3);
  }
  if (s0 > s1 && s1 > s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 > d1) d1 = d2;
    return ( d1 > d3 ? d1 : d3);
  }
  return 0.;
}
#line 245 "/home/spencer/basilisk/src/utils.h"
void gradients (scalar * f, vector * g)
{
  if (!(list_len(f) == vectors_len(g))) qassert ("/home/spencer/basilisk/src/utils.h", 247, "list_len(f) == vectors_len(g)");
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 248, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 248 "/home/spencer/basilisk/src/utils.h"
{
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {





_stencil_val(s,-1,0,0); _stencil_val(s,0,0,0); _stencil_val(s,1,0,0);     _stencil_val_a(v.x,0,0,0);   
 } 
#line 252
{





_stencil_val(s,0,-1,0); _stencil_val(s,0,0,0); _stencil_val(s,0,1,0);     _stencil_val_a(v.y,0,0,0);   
 }}
      else
 { {





_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0);     _stencil_val_a(v.x,0,0,0);   
 } 
#line 261
{





_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0);     _stencil_val_a(v.y,0,0,0);   
 }}
    }}}
  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 248 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 248 "/home/spencer/basilisk/src/utils.h"
{
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {





     val(v.x,0,0,0) = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0))/Delta;
 } 
#line 252
{





     val(v.y,0,0,0) = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0))/Delta;
 }}
      else
 { {





     val(v.x,0,0,0) = (val(s,1,0,0) - val(s,-1,0,0))/(2.*Delta);
 } 
#line 261
{





     val(v.y,0,0,0) = (val(s,0,1,0) - val(s,0,-1,0))/(2.*Delta);
 }}
    }}}
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 271 "/home/spencer/basilisk/src/utils.h"
}
#line 288 "/home/spencer/basilisk/src/utils.h"
void vorticity (const vector u, scalar omega)
{
  if(!is_constant(fm.x) && !is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 290, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 291 "/home/spencer/basilisk/src/utils.h"
{_stencil_val(fm.x,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,0,0,0);
        _stencil_val(fm.x,1,0,0);_stencil_val(u.y,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,-1,0,0);
_stencil_val(fm.y,0,1,0); _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,0,0);
        _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,-1,0); _stencil_val(fm.y,0,1,0);_stencil_val(u.x,0,1,0);_stencil_val(cm,0,0,0);
#line 291
_stencil_val_a(omega,0,0,0);      
             

}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 291 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 291 "/home/spencer/basilisk/src/utils.h"
val(omega,0,0,0) = ((val(fm.x,1,0,0) - val(fm.x,0,0,0))*val(u.y,0,0,0) +
        val(fm.x,1,0,0)*val(u.y,1,0,0) - val(fm.x,0,0,0)*val(u.y,-1,0,0) -
        (val(fm.y,0,1,0) - val(fm.y,0,0,0))*val(u.x,0,0,0) +
        val(fm.y,0,0,0)*val(u.x,0,-1,0) - val(fm.y,0,1,0)*val(u.x,0,1,0))/(2.*(val(cm,0,0,0) + 1e-30)*Delta);}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 294 "/home/spencer/basilisk/src/utils.h"
}else if(is_constant(fm.x) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 290, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 291 "/home/spencer/basilisk/src/utils.h"
{;;_stencil_val(u.y,0,0,0);
;_stencil_val(u.y,1,0,0);;_stencil_val(u.y,-1,0,0);
;;_stencil_val(u.x,0,0,0);
;_stencil_val(u.x,0,-1,0);;_stencil_val(u.x,0,1,0);_stencil_val(cm,0,0,0);
#line 291
_stencil_val_a(omega,0,0,0);      
             

}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 291 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 291 "/home/spencer/basilisk/src/utils.h"
val(omega,0,0,0) = ((_const_fm.x - _const_fm.x)*val(u.y,0,0,0) +
        _const_fm.x*val(u.y,1,0,0) - _const_fm.x*val(u.y,-1,0,0) -
        (_const_fm.y - _const_fm.y)*val(u.x,0,0,0) +
        _const_fm.y*val(u.x,0,-1,0) - _const_fm.y*val(u.x,0,1,0))/(2.*(val(cm,0,0,0) + 1e-30)*Delta);}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 294 "/home/spencer/basilisk/src/utils.h"
}else if(!is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 290, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 291 "/home/spencer/basilisk/src/utils.h"
{_stencil_val(fm.x,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,0,0,0);
        _stencil_val(fm.x,1,0,0);_stencil_val(u.y,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,-1,0,0);
_stencil_val(fm.y,0,1,0); _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,0,0);
        _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,-1,0); _stencil_val(fm.y,0,1,0);_stencil_val(u.x,0,1,0);;
#line 291
_stencil_val_a(omega,0,0,0);      
             

}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 291 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 291 "/home/spencer/basilisk/src/utils.h"
val(omega,0,0,0) = ((val(fm.x,1,0,0) - val(fm.x,0,0,0))*val(u.y,0,0,0) +
        val(fm.x,1,0,0)*val(u.y,1,0,0) - val(fm.x,0,0,0)*val(u.y,-1,0,0) -
        (val(fm.y,0,1,0) - val(fm.y,0,0,0))*val(u.x,0,0,0) +
        val(fm.y,0,0,0)*val(u.x,0,-1,0) - val(fm.y,0,1,0)*val(u.x,0,1,0))/(2.*(_const_cm + 1e-30)*Delta);}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 294 "/home/spencer/basilisk/src/utils.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 290, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 291 "/home/spencer/basilisk/src/utils.h"
{;;_stencil_val(u.y,0,0,0);
;_stencil_val(u.y,1,0,0);;_stencil_val(u.y,-1,0,0);
;;_stencil_val(u.x,0,0,0);
;_stencil_val(u.x,0,-1,0);;_stencil_val(u.x,0,1,0);;
#line 291
_stencil_val_a(omega,0,0,0);      
             

}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 291 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 291 "/home/spencer/basilisk/src/utils.h"
val(omega,0,0,0) = ((_const_fm.x - _const_fm.x)*val(u.y,0,0,0) +
        _const_fm.x*val(u.y,1,0,0) - _const_fm.x*val(u.y,-1,0,0) -
        (_const_fm.y - _const_fm.y)*val(u.x,0,0,0) +
        _const_fm.y*val(u.x,0,-1,0) - _const_fm.y*val(u.x,0,1,0))/(2.*(_const_cm + 1e-30)*Delta);}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 294 "/home/spencer/basilisk/src/utils.h"
}
}





double change (scalar s, scalar sn)
{
  double max = 0.;
  if(!is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 304, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 304 "/home/spencer/basilisk/src/utils.h"
{
_stencil_val(cm,0,0,0); {     
       _stencil_val(sn,0,0,0);_stencil_val(s,0,0,0);   
       
  
    } 
_stencil_val(s,0,0,0);    _stencil_val_a(sn,0,0,0); 
  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:max)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 304 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 304 "/home/spencer/basilisk/src/utils.h"
{
    if ((( Delta*Delta)*val(cm,0,0,0)) > 0.) {
      double ds = fabs (val(s,0,0,0) - val(sn,0,0,0));
      if (ds > max)
 max = ds;
    }
    val(sn,0,0,0) = val(s,0,0,0);
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 311 "/home/spencer/basilisk/src/utils.h"
{mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/utils.h", .line = 304, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 304 "/home/spencer/basilisk/src/utils.h"
{
; {     
       _stencil_val(sn,0,0,0);_stencil_val(s,0,0,0);   
       
  
    } 
_stencil_val(s,0,0,0);    _stencil_val_a(sn,0,0,0); 
  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:max)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 304 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 304 "/home/spencer/basilisk/src/utils.h"
{
    if ((( Delta*Delta)*_const_cm) > 0.) {
      double ds = fabs (val(s,0,0,0) - val(sn,0,0,0));
      if (ds > max)
 max = ds;
    }
    val(sn,0,0,0) = val(s,0,0,0);
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 311 "/home/spencer/basilisk/src/utils.h"
{mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);}}
  return max;
}





scalar lookup_field (const char * name)
{
  if (name)
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!strcmp (_attribute[s.i].name, name))
 return s;}}
  return (scalar){-1};
}

vector lookup_vector (const char * name)
{
  if (name) {
    char component[strlen(name) + 3];
    strcpy (component, name);
    strcat (component, ".x");
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!strcmp (_attribute[s.i].name, component))
 return _attribute[s.i].v;}}
  }
  return (vector){{-1}};
}







void macro_foreach_segment (coord S[2], coord p[2], Reduce reductions)
{
  double norm = sqrt(( (S[1].x - S[0].x)*(S[1].x - S[0].x)) + ( (S[1].y - S[0].y)*(S[1].y - S[0].y)));
  if (norm > 0.) {
    coord t = {(S[1].x - S[0].x)/norm + 1e-6, (S[1].y - S[0].y)/norm - 1.5e-6};
    double alpha = S[0].x*t.y - S[0].y*t.x; 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;      
#line 354 "/home/spencer/basilisk/src/utils.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 354 "/home/spencer/basilisk/src/utils.h"
if (fabs(t.y*x - t.x*y - alpha) < 0.708*Delta_x) {
 coord _o = {x,y}, p[2];
 int _n = 0;
 
   if (t.x)
     for (int _i = -1; _i <= 1 && _n < 2; _i += 2) {
       p[_n].x = _o.x + _i*Delta_x/2.;
       double a = (p[_n].x - S[0].x)/t.x;
       p[_n].y = S[0].y + a*t.y;
       if (fabs(p[_n].y - _o.y) <= Delta_x/2.) {
  a = ( a < 0. ? 0. : a > norm ? norm : a);
  p[_n].x = S[0].x + a*t.x, p[_n].y = S[0].y + a*t.y;
  if (fabs(p[_n].x - _o.x) <= Delta_x/2. &&
      fabs(p[_n].y - _o.y) <= Delta_x/2.)
    _n++;
       }
     }   
#line 358
if (t.y)
     for (int _i = -1; _i <= 1 && _n < 2; _i += 2) {
       p[_n].y = _o.y + _i*Delta_y/2.;
       double a = (p[_n].y - S[0].y)/t.y;
       p[_n].x = S[0].x + a*t.x;
       if (fabs(p[_n].x - _o.x) <= Delta_y/2.) {
  a = ( a < 0. ? 0. : a > norm ? norm : a);
  p[_n].y = S[0].y + a*t.y, p[_n].x = S[0].x + a*t.x;
  if (fabs(p[_n].y - _o.y) <= Delta_y/2. &&
      fabs(p[_n].x - _o.x) <= Delta_y/2.)
    _n++;
       }
     }
 if (_n == 2)
   ;
      }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 374 "/home/spencer/basilisk/src/utils.h"
}
}




void fields_stats (scalar * list)
{
  fprintf (ferr, "# t = %g, fields = {", t);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    fprintf (ferr, " %s", _attribute[s.i].name);}}
  fputs (" }\n", ferr);
  fprintf (ferr, "# %12s: %12s %12s %12s %12s\n",
    "name", "min", "avg", "stddev", "max");
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    stats ss = statsf (s);
    fprintf (ferr, "# %12s: %12g %12g %12g %12g\n",
      _attribute[s.i].name, ss.min, ss.sum/ss.volume, ss.stddev, ss.max);
  }}}
}

#line 1 "./output.h"
#line 1 "/home/spencer/basilisk/src/output.h"
#line 37 "/home/spencer/basilisk/src/output.h"
     
void output_field (scalar * list,
     FILE * fp,
     int n,
     bool linear,
     coord box[2])
{tracing("output_field","/home/spencer/basilisk/src/output.h",38);
  n++;
  int len = list_len (list);
  double Delta = 0.999999*(box[1].x - box[0].x)/(n - 1);
  int ny = (box[1].y - box[0].y)/Delta + 1;
  double ** field = (double **) matrix_new (n, ny, len*sizeof(double)), * v = field[0];
  for (int i = 0; i < n*ny*len; i++, v++)
    *v = 1e30f;
  coord box1[2] = {{box[0].x - Delta/2., box[0].y - Delta/2.},
     {box[0].x + (n - 0.5)*Delta, box[0].y + (ny - 0.5)*Delta}};
  coord cn = {n, ny}, p;
  
  




  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/output.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 60 "/home/spencer/basilisk/src/output.h"
{                     
    
    
    
    
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      { _stencil_interpolate_linear (point, s, NULL, NULL, NULL); _stencil_val(s,0,0,0);      }}}
  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 25 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{
  {
    if (cn.x < 1) cn.x = 1;
    if (cn.y < 1) cn.y = 1;
    if (cn.z < 1) cn.z = 1;

    for (int _i = 0; _i < (int) cn.x; _i++) {
      p.x = box1[0].x + (box1[1].x - box1[0].x)/cn.x*(_i + 0.5);
      for (int _j = 0; _j < (int) cn.y; _j++) {
 p.y = box1[0].y + (box1[1].y - box1[0].y)/cn.y*(_j + 0.5);
 for (int _k = 0; _k < (int) cn.z; _k++) {
   p.z = box1[0].z + (box1[1].z - box1[0].z)/cn.z*(_k + 0.5);
   Point point = locate (p.x, p.y, p.z);
   if (point.level >= 0) {
     int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);

  
#line 60 "/home/spencer/basilisk/src/output.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 60 "/home/spencer/basilisk/src/output.h"
{
    double ** alias = field;
    int i = (p.x - box1[0].x)/(box1[1].x - box1[0].x)*cn.x;
    int j = (p.y - box1[0].y)/(box1[1].y - box1[0].y)*cn.y;
    int k = 0;
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      alias[i][len*j + k++] = linear ? interpolate_linear (point, s, p.x, p.y, p.z) : val(s,0,0,0);}}
  }}   
#line 41 "/home/spencer/basilisk/src/grid/cartesian-common.h"
}
 }
      }
    }
  }
}

  
#line 69 "/home/spencer/basilisk/src/output.h"
if (pid() == 0) {
    fprintf (fp, "# 1:x 2:y");
    int i = 3;
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      fprintf (fp, " %d:%s", i++, _attribute[s.i].name);}}
    fputc('\n', fp);
    for (int i = 0; i < n; i++) {
      double x = Delta*i + box[0].x;
      for (int j = 0; j < ny; j++) {
 double y = Delta*j + box[0].y;

 fprintf (fp, "%g %g", x, y);
 int k = 0;
 {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   fprintf (fp, " %g", field[i][len*j + k++]);}}
 fputc ('\n', fp);
      }
      fputc ('\n', fp);
    }
    fflush (fp);
  }

  matrix_free (field);
end_tracing("output_field","/home/spencer/basilisk/src/output.h",92);}
#line 125 "/home/spencer/basilisk/src/output.h"
     
void output_matrix (scalar f,
      FILE * fp,
      int n,
      bool linear,
      const char * file,
      coord box[2])
{tracing("output_matrix","/home/spencer/basilisk/src/output.h",126);
  coord cn = {n}, p;
  double delta = (box[1].x - box[0].x)/n;
  cn.y = (int)((box[1].y - box[0].y)/delta);

  double ** ppm = (double **) matrix_new (cn.x, cn.y, sizeof(double));
  double * ppm0 = &ppm[0][0];
  unsigned int len = cn.x*cn.y;
  for (int i = 0; i < len; i++)
    ppm0[i] = - 1e30f;
  
  




  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/output.h", .line = 146, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 148 "/home/spencer/basilisk/src/output.h"
{                  
    
    
     
_stencil_interpolate_linear (point, f, NULL, NULL, NULL); _stencil_val(f,0,0,0);  
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 25 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{
  {
    if (cn.x < 1) cn.x = 1;
    if (cn.y < 1) cn.y = 1;
    if (cn.z < 1) cn.z = 1;

    for (int _i = 0; _i < (int) cn.x; _i++) {
      p.x = box[0].x + (box[1].x - box[0].x)/cn.x*(_i + 0.5);
      for (int _j = 0; _j < (int) cn.y; _j++) {
 p.y = box[0].y + (box[1].y - box[0].y)/cn.y*(_j + 0.5);
 for (int _k = 0; _k < (int) cn.z; _k++) {
   p.z = box[0].z + (box[1].z - box[0].z)/cn.z*(_k + 0.5);
   Point point = locate (p.x, p.y, p.z);
   if (point.level >= 0) {
     int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);

  
#line 148 "/home/spencer/basilisk/src/output.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 148 "/home/spencer/basilisk/src/output.h"
{
    int i = (p.x - box[0].x)/(box[1].x - box[0].x)*cn.x;
    int j = (p.y - box[0].y)/(box[1].y - box[0].y)*cn.y;
    double ** alias = ppm;
    alias[i][j] = linear ? interpolate_linear (point, f, p.x, p.y, p.z) : val(f,0,0,0);
  }}   
#line 41 "/home/spencer/basilisk/src/grid/cartesian-common.h"
}
 }
      }
    }
  }
}

  
#line 155 "/home/spencer/basilisk/src/output.h"
if (pid() == 0) {
    if (file) {
      fp = fopen (file, "wb");
      if (!fp) {
 perror (file);
 exit (1);
      }
    }
    float fn = cn.y;
    fwrite (&fn, sizeof(float), 1, fp);
    coord delta = {(box[1].x - box[0].x)/cn.x, (box[1].y - box[0].y)/cn.y};
    for (int j = 0; j < cn.y; j++) {
      float yp = box[0].y + delta.y*(j + 0.5);
      fwrite (&yp, sizeof(float), 1, fp);
    }
    for (int i = 0; i < cn.x; i++) {
      float xp = box[0].x + delta.x*(i + 0.5);
      fwrite (&xp, sizeof(float), 1, fp);
      for (int j = 0; j < cn.y; j++) {
 float z = ppm[i][j];
 fwrite (&z, sizeof(float), 1, fp);
      }
    }
    if (file)
      fclose (fp);
    else
      fflush (fp);
  }

  matrix_free (ppm);
end_tracing("output_matrix","/home/spencer/basilisk/src/output.h",185);}
#line 194 "/home/spencer/basilisk/src/output.h"
typedef void (* Colormap) (double cmap[127][3]);

void jet (double cmap[127][3])
{
  for (int i = 0; i < 127; i++) {
    cmap[i][0] =
      i <= 46 ? 0. :
      i >= 111 ? -0.03125*(i - 111) + 1. :
      i >= 78 ? 1. :
      0.03125*(i - 46);
    cmap[i][1] =
      i <= 14 || i >= 111 ? 0. :
      i >= 79 ? -0.03125*(i - 111) :
      i <= 46 ? 0.03125*(i - 14) :
      1.;
    cmap[i][2] =
      i >= 79 ? 0. :
      i >= 47 ? -0.03125*(i - 79) :
      i <= 14 ? 0.03125*(i - 14) + 1.:
      1.;
  }
}

void cool_warm (double cmap[127][3])
{






  static double basemap[33][3] = {
    {0.2298057, 0.298717966, 0.753683153},
    {0.26623388, 0.353094838, 0.801466763},
    {0.30386891, 0.406535296, 0.84495867},
    {0.342804478, 0.458757618, 0.883725899},
    {0.38301334, 0.50941904, 0.917387822},
    {0.424369608, 0.558148092, 0.945619588},
    {0.46666708, 0.604562568, 0.968154911},
    {0.509635204, 0.648280772, 0.98478814},
    {0.552953156, 0.688929332, 0.995375608},
    {0.596262162, 0.726149107, 0.999836203},
    {0.639176211, 0.759599947, 0.998151185},
    {0.681291281, 0.788964712, 0.990363227},
    {0.722193294, 0.813952739, 0.976574709},
    {0.761464949, 0.834302879, 0.956945269},
    {0.798691636, 0.849786142, 0.931688648},
    {0.833466556, 0.860207984, 0.901068838},
    {0.865395197, 0.86541021, 0.865395561},
    {0.897787179, 0.848937047, 0.820880546},
    {0.924127593, 0.827384882, 0.774508472},
    {0.944468518, 0.800927443, 0.726736146},
    {0.958852946, 0.769767752, 0.678007945},
    {0.96732803, 0.734132809, 0.628751763},
    {0.969954137, 0.694266682, 0.579375448},
    {0.966811177, 0.650421156, 0.530263762},
    {0.958003065, 0.602842431, 0.481775914},
    {0.943660866, 0.551750968, 0.434243684},
    {0.923944917, 0.49730856, 0.387970225},
    {0.89904617, 0.439559467, 0.343229596},
    {0.869186849, 0.378313092, 0.300267182},
    {0.834620542, 0.312874446, 0.259301199},
    {0.795631745, 0.24128379, 0.220525627},
    {0.752534934, 0.157246067, 0.184115123},
    {0.705673158, 0.01555616, 0.150232812}
  };

  for (int i = 0; i < 127; i++) {
    double x = i*(32 - 1e-10)/(127 - 1);
    int j = x; x -= j;
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (1. - x)*basemap[j][k] + x*basemap[j+1][k];
  }
}

void gray (double cmap[127][3])
{
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = i/(127 - 1.);
}

void randomap (double cmap[127][3])
{
  srand(0);
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (noise() + 1.)/2.;
}

void blue_white_red (double cmap[127][3])
{
  for (int i = 0; i < (127 + 1)/2; i++) {
    cmap[i][0] = i/((127 - 1)/2.);
    cmap[i][1] = i/((127 - 1)/2.);
    cmap[i][2] = 1.;
  }
  for (int i = 0; i < (127 - 1)/2; i++) {
    cmap[i + (127 + 1)/2][0] = 1.;
    cmap[i + (127 + 1)/2][1] = cmap[(127 - 3)/2 - i][1];
    cmap[i + (127 + 1)/2][2] = cmap[(127 - 3)/2 - i][1];
  }
}





typedef struct {
  unsigned char r, g, b;
} Color;

Color colormap_color (double cmap[127][3],
        double val, double min, double max)
{
  Color c;
  if (val == 1e30f) {
    c.r = c.g = c.b = 0;
    return c;
  }
  int i;
  double coef;
  if (max != min)
    val = (val - min)/(max - min);
  else
    val = 0.;
  if (val <= 0.) i = 0, coef = 0.;
  else if (val >= 1.) i = 127 - 2, coef = 1.;
  else {
    i = val*(127 - 1);
    coef = val*(127 - 1) - i;
  }
  if (!(i >= 0 && i < 127 - 1)) qassert ("/home/spencer/basilisk/src/output.h", 326, "i >= 0 && i < NCMAP - 1");
  unsigned char * c1 = (unsigned char *) &c;
  for (int j = 0; j < 3; j++)
    c1[j] = 255*(cmap[i][j]*(1. - coef) + cmap[i + 1][j]*coef);
  return c;
}
#line 345 "/home/spencer/basilisk/src/output.h"
static const char * extension (const char * file, const char * ext) {
  int len = strlen(file);
  return len > 4 && !strcmp (file + len - 4, ext) ? file + len - 4 : NULL;
}

static const char * is_animation (const char * file) {
  const char * ext;
  if ((ext = extension (file, ".mp4")) ||
      (ext = extension (file, ".ogv")) ||
      (ext = extension (file, ".gif")))
    return ext;
  return NULL;
}

static struct {
  FILE ** fp;
  char ** names;
  int n;
} open_image_data = {NULL, NULL, 0};

static void open_image_cleanup()
{
  for (int i = 0; i < open_image_data.n; i++) {
    qpclose (open_image_data.fp[i]);
    pfree (open_image_data.names[i],__func__,__FILE__,__LINE__);
  }
  pfree (open_image_data.fp,__func__,__FILE__,__LINE__);
  pfree (open_image_data.names,__func__,__FILE__,__LINE__);
  open_image_data.fp = NULL;
  open_image_data.names = NULL;
  open_image_data.n = 0;
}

static FILE * open_image_lookup (const char * file)
{
  for (int i = 0; i < open_image_data.n; i++)
    if (!strcmp (file, open_image_data.names[i]))
      return open_image_data.fp[i];
  return NULL;
}

static bool which (const char * command)
{
  char * s = getenv ("PATH");
  if (!s)
    return false;
  char path[strlen(s) + 1];
  strcpy (path, s);
  s = strtok (path, ":");
  while (s) {
    char f[strlen(s) + strlen(command) + 2];
    strcpy (f, s);
    strcat (f, "/");
    strcat (f, command);
    FILE * fp = fopen (f, "r");
    if (fp) {
      fclose (fp);
      return true;
    }
    s = strtok (NULL, ":");
  }
  return false;
}

static FILE * ppm_fallback (const char * file, const char * mode)
{
  char filename[strlen(file) + 5];
  strcpy (filename, file);
  strcat (filename, ".ppm");
  FILE * fp = fopen (filename, mode);
  if (!fp) {
    perror (file);



    exit (1);
  }
  return fp;
}

FILE * open_image (const char * file, const char * options)
{
#if __EMSCRIPTEN__
  return ppm_fallback (file, "w");
#else
  if (!(pid() == 0)) qassert ("/home/spencer/basilisk/src/output.h", 430, "pid() == 0");
  const char * ext;
  if ((ext = is_animation (file))) {
    FILE * fp = open_image_lookup (file);
    if (fp)
      return fp;

    int len = strlen ("ppm2???    ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    strcpy (command, "ppm2"); strcat (command, ext + 1);

    static int has_ffmpeg = -1;
    if (has_ffmpeg < 0) {
      if (which (command) && (which ("ffmpeg") || which ("avconv")))
 has_ffmpeg = true;
      else {
 fprintf (ferr,
   "src/output.h:%d: warning: cannot find '%s' or 'ffmpeg'/'avconv'\n"
   "src/output.h:%d: warning: falling back to raw PPM outputs\n",
   450, command, 450);
 has_ffmpeg = false;
      }
    }
    if (!has_ffmpeg)
      return ppm_fallback (file, "a");

    static bool added = false;
    if (!added) {
      free_solver_func_add (open_image_cleanup);
      added = true;
    }
    open_image_data.n++;
    open_image_data.names = (char * *) prealloc (open_image_data.names, (open_image_data.n)*sizeof(char *),__func__,__FILE__,__LINE__);
    open_image_data.names[open_image_data.n - 1] = pstrdup (file,__func__,__FILE__,__LINE__);

    if (options) {
      strcat (command, " ");
      strcat (command, options);
    }
    strcat (command, !strcmp (ext, ".mp4") ? " " : " > ");
    strcat (command, file);
    open_image_data.fp = (FILE * *) prealloc (open_image_data.fp, (open_image_data.n)*sizeof(FILE *),__func__,__FILE__,__LINE__);
    return open_image_data.fp[open_image_data.n - 1] = qpopen (command, "w");
  }
  else {
    static int has_convert = -1;
    if (has_convert < 0) {
      if (which ("convert"))
 has_convert = true;
      else {
 fprintf (ferr,
   "src/output.h:%d: warning: cannot find 'convert'\n"
   "src/output.h:%d: warning: falling back to raw PPM outputs\n",
   484, 484);
 has_convert = false;
      }
    }
    if (!has_convert)
      return ppm_fallback (file, "w");

    int len = strlen ("convert ppm:-   ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    strcpy (command, "convert ppm:- ");
    if (options) {
      strcat (command, options);
      strcat (command, " ");
    }
    strcat (command, file);
    return qpopen (command, "w");
  }
#endif
}

void close_image (const char * file, FILE * fp)
{
  if (!(pid() == 0)) qassert ("/home/spencer/basilisk/src/output.h", 507, "pid() == 0");
  if (is_animation (file)) {
    if (!open_image_lookup (file))
      fclose (fp);
  }
#if !__EMSCRIPTEN__
  else if (which ("convert"))
    qpclose (fp);
#endif
  else
    fclose (fp);
}
#line 593 "/home/spencer/basilisk/src/output.h"
     
void output_ppm (scalar f,
   FILE * fp,
   int n,
   char * file,
   double min, double max, double spread,
   double z,
   bool linear,
   coord box[2],
   scalar mask,
   Colormap map,
   char * opt,
   int fps,
   FILE * checksum)
{tracing("output_ppm","/home/spencer/basilisk/src/output.h",594);

  if (!min && !max) {
    stats s = statsf (f);
    if (spread < 0.)
      min = s.min, max = s.max;
    else {
      double avg = s.sum/s.volume;
      min = avg - spread*s.stddev; max = avg + spread*s.stddev;
    }
  }
  box[0].z = z, box[1].z = z;

  coord cn = {n}, p;
  double delta = (box[1].x - box[0].x)/n;
  cn.y = (int)((box[1].y - box[0].y)/delta);
  if (((int)cn.y) % 2) cn.y++;

  Color ** ppm = (Color **) matrix_new (cn.y, cn.x, sizeof(Color));
  unsigned char * ppm0 = &ppm[0][0].r;
  int len = 3*cn.x*cn.y;
  memset (ppm0, 0, len*sizeof (unsigned char));
  double cmap[127][3];
  (* map) (cmap);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/output.h", .line = 635, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);

  
#line 637 "/home/spencer/basilisk/src/output.h"
{ 
    
    if (mask.i >= 0) {
      if (linear) {  
  _stencil_interpolate_linear (point, mask, NULL, NULL, NULL);
{ 
    
   
{ _stencil_interpolate_linear (point, f, NULL, NULL, NULL); }}      
}
      else {
_stencil_val(mask,0,0,0);{
     
   
{ _stencil_val(f,0,0,0); }}      
}
    }
    else if (linear)
      { _stencil_interpolate_linear (point, f, NULL, NULL, NULL); }
    else
      { _stencil_val(f,0,0,0); }                  
    
    
         
         
  }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 25 "/home/spencer/basilisk/src/grid/cartesian-common.h"
{
  {
    if (cn.x < 1) cn.x = 1;
    if (cn.y < 1) cn.y = 1;
    if (cn.z < 1) cn.z = 1;

    for (int _i = 0; _i < (int) cn.x; _i++) {
      p.x = box[0].x + (box[1].x - box[0].x)/cn.x*(_i + 0.5);
      for (int _j = 0; _j < (int) cn.y; _j++) {
 p.y = box[0].y + (box[1].y - box[0].y)/cn.y*(_j + 0.5);
 for (int _k = 0; _k < (int) cn.z; _k++) {
   p.z = box[0].z + (box[1].z - box[0].z)/cn.z*(_k + 0.5);
   Point point = locate (p.x, p.y, p.z);
   if (point.level >= 0) {
     int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);

  
#line 637 "/home/spencer/basilisk/src/output.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 637 "/home/spencer/basilisk/src/output.h"
{
    double v;
    if (mask.i >= 0) {
      if (linear) {
 double m = interpolate_linear (point, mask, p.x, p.y, p.z);
 if (m < 0.)
   v = 1e30f;
 else
   v = interpolate_linear (point, f, p.x, p.y, p.z);
      }
      else {
 if (val(mask,0,0,0) < 0.)
   v = 1e30f;
 else
   v = val(f,0,0,0);
      }
    }
    else if (linear)
      v = interpolate_linear (point, f, p.x, p.y, p.z);
    else
      v = val(f,0,0,0);
    int i = (p.x - box[0].x)/(box[1].x - box[0].x)*cn.x;
    int j = (p.y - box[0].y)/(box[1].y - box[0].y)*cn.y;
    Color ** alias = ppm;
    alias[(int)cn.y - 1 - j][i] = colormap_color (cmap, v, min, max);
  }}   
#line 41 "/home/spencer/basilisk/src/grid/cartesian-common.h"
}
 }
      }
    }
  }
}

  
#line 664 "/home/spencer/basilisk/src/output.h"
if (pid() == 0) {
    if (file)
      fp = open_image (file, opt);

    fprintf (fp, "P6\n%g %g 255\n", cn.x, cn.y);
    fwrite (ppm0, sizeof(unsigned char), 3*cn.x*cn.y, fp);

    if (file)
      close_image (file, fp);
    else
      fflush (fp);

    if (checksum) {
      Adler32Hash hash;
      a32_hash_init (&hash);
      a32_hash_add (&hash, ppm0, sizeof(unsigned char)*3*cn.x*cn.y);
      fputs ("# ", checksum);
      if (file)
 fprintf (checksum, "%s: ", file);
      fprintf (checksum, "checksum: %08lx\n", (unsigned long) a32_hash (&hash));
    }
  }

  matrix_free (ppm);
end_tracing("output_ppm","/home/spencer/basilisk/src/output.h",688);}
#line 720 "/home/spencer/basilisk/src/output.h"
     
void output_grd (scalar f,
   FILE * fp,
   double Delta,
   bool linear,
   coord box[2],
   scalar mask)
{tracing("output_grd","/home/spencer/basilisk/src/output.h",721);
  int nx = (box[1].x - box[0].x)/Delta;
  int ny = (box[1].y - box[0].y)/Delta;


  fprintf (fp, "ncols          %d\n", nx);
  fprintf (fp, "nrows          %d\n", ny);
  fprintf (fp, "xllcorner      %g\n", box[0].x);
  fprintf (fp, "yllcorner      %g\n", box[0].y);
  fprintf (fp, "cellsize       %g\n", Delta);
  fprintf (fp, "nodata_value   -9999\n");


  for (int j = ny-1; j >= 0; j--) {
    double yp = Delta*j + box[0].y + Delta/2.;
    for (int i = 0; i < nx; i++) {
      double xp = Delta*i + box[0].x + Delta/2., v;
      if (mask.i >= 0) {
 double m = interpolate (mask, xp, yp
#line 910 "/home/spencer/basilisk/src/grid/cartesian-common.h"
, 0.
#line 745 "/home/spencer/basilisk/src/output.h"
, linear);
 if (m < 0.)
   v = 1e30f;
 else
   v = interpolate (f, xp, yp
#line 910 "/home/spencer/basilisk/src/grid/cartesian-common.h"
, 0.
#line 749 "/home/spencer/basilisk/src/output.h"
, linear);
      }
      else
 v = interpolate (f, xp, yp
#line 910 "/home/spencer/basilisk/src/grid/cartesian-common.h"
, 0.
#line 752 "/home/spencer/basilisk/src/output.h"
, linear);
      if (v == 1e30f)
 fprintf (fp, "-9999 ");
      else
 fprintf (fp, "%f ", v);
    }
    fprintf (fp, "\n");
  }

  fflush (fp);
end_tracing("output_grd","/home/spencer/basilisk/src/output.h",762);}
#line 789 "/home/spencer/basilisk/src/output.h"
static char * replace (const char * input, int target, int with,
         bool translate)
{
  if (translate) {
    if (!strcmp (input, "u.x"))
      return pstrdup ("U",__func__,__FILE__,__LINE__);
    if (!strcmp (input, "u.y"))
      return pstrdup ("V",__func__,__FILE__,__LINE__);
    if (!strcmp (input, "u.z"))
      return pstrdup ("W",__func__,__FILE__,__LINE__);
  }
  char * name = pstrdup (input,__func__,__FILE__,__LINE__), * i = name;
  while (*i != '\0') {
    if (*i == target)
      *i = with;
    i++;
  }
  return name;
}

     
void output_gfs (FILE * fp,
   scalar * list,
   char * file,
   bool translate)
{tracing("output_gfs","/home/spencer/basilisk/src/output.h",810);
  char * fname = file;
#line 831 "/home/spencer/basilisk/src/output.h"
  bool opened = false;
  if (fp == NULL) {
    if (fname == NULL)
      fp = fout;
    else if (!(fp = fopen (fname, "w"))) {
      perror (fname);
      exit (1);
    }
    else
      opened = true;
  }

  scalar * slist = list ? list : list_copy (all);

  restriction (slist);
  fprintf (fp,
    "1 0 GfsSimulation GfsBox GfsGEdge { binary = 1"
    " x = %g y = %g ",
    0.5 + X0/L0, 0.5 + Y0/L0);




  if (slist != NULL && slist[0].i != -1) {
    scalar s = slist[0];
    char * name = replace (_attribute[s.i].name, '.', '_', translate);
    fprintf (fp, "variables = %s", name);
    pfree (name,__func__,__FILE__,__LINE__);
    for (int i = 1; i < list_len(slist); i++) {
      scalar s = slist[i];
      if (_attribute[s.i].name) {
 char * name = replace (_attribute[s.i].name, '.', '_', translate);
 fprintf (fp, ",%s", name);
 pfree (name,__func__,__FILE__,__LINE__);
      }
    }
    fprintf (fp, " ");
  }
  fprintf (fp, "} {\n");
  fprintf (fp, "  Time { t = %g }\n", t);
  if (L0 != 1.)
    fprintf (fp, "  PhysicalParams { L = %g }\n", L0);
  fprintf (fp, "  VariableTracerVOF f\n");
  fprintf (fp, "}\nGfsBox { x = 0 y = 0 z = 0 } {\n");
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 892 "/home/spencer/basilisk/src/output.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 892 "/home/spencer/basilisk/src/output.h"
{



    {






      unsigned flags =
 level == 0 ? 0 :



      child.x == -1 && child.y == -1 ? 0 :
 child.x == -1 && child.y == 1 ? 1 :
 child.x == 1 && child.y == -1 ? 2 :
 3;
#line 922 "/home/spencer/basilisk/src/output.h"
      if (is_leaf(cell))
 flags |= (1 << 4);
      fwrite (&flags, sizeof (unsigned), 1, fp);
      double a = -1;
      fwrite (&a, sizeof (double), 1, fp);
      {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 if (_attribute[s.i].name) {
   if (_attribute[s.i].v.x.i >= 0) {




     if (_attribute[s.i].v.x.i == s.i) {
       s = _attribute[s.i].v.y;
       a = is_local(cell) && val(s,0,0,0) != 1e30f ? val(s,0,0,0) : (double) DBL_MAX;
     }
     else if (_attribute[s.i].v.y.i == s.i) {
       s = _attribute[s.i].v.x;
       a = is_local(cell) && val(s,0,0,0) != 1e30f ? - val(s,0,0,0) : (double) DBL_MAX;
     }





   }
   else
     a = is_local(cell) && val(s,0,0,0) != 1e30f ? val(s,0,0,0) : (double) DBL_MAX;
   fwrite (&a, sizeof (double), 1, fp);
 }}}
    }
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
#line 965 "/home/spencer/basilisk/src/output.h"
    fputs ("}\n", fp);
  fflush (fp);

  if (!list)
    pfree (slist,__func__,__FILE__,__LINE__);
  if (opened)
    fclose (fp);
#line 990 "/home/spencer/basilisk/src/output.h"
end_tracing("output_gfs","/home/spencer/basilisk/src/output.h",990);}
#line 1017 "/home/spencer/basilisk/src/output.h"
struct DumpHeader {
  double t;
  long len;
  int i, depth, npe, version;
  coord n;
};

static const int dump_version =

  170901;

static scalar * dump_list (scalar * lista, bool zero)
{
  scalar * list = is_constant(cm) ? NULL : list_concat (((scalar[]){cm,{-1}}), NULL);




  scalar * listb = list_copy (lista);

  {scalar*_i=(scalar*)( listb);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!_attribute[s.i].face && !_attribute[s.i].nodump && s.i != cm.i) {
      if (zero)
 list = list_add (list, s);
      else {
 stats ss = statsf (s);
 if (ss.min != 0. || ss.max != 0.)
   list = list_add (list, s);
      }
    }}}
  pfree (listb,__func__,__FILE__,__LINE__);
  return list;
}

static void dump_header (FILE * fp, struct DumpHeader * header, scalar * list)
{
  if (fwrite (header, sizeof(struct DumpHeader), 1, fp) < 1) {
    perror ("dump(): error while writing header");
    exit (1);
  }
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    unsigned len = strlen(_attribute[s.i].name);
    if (fwrite (&len, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing len");
      exit (1);
    }
    if (fwrite (_attribute[s.i].name, sizeof(char), len, fp) < len) {
      perror ("dump(): error while writing s.name");
      exit (1);
    }
  }}}
  double o[4] = {X0,Y0,Z0,L0};
  if (fwrite (o, sizeof(double), 4, fp) < 4) {
    perror ("dump(): error while writing coordinates");
    exit (1);
  }
}


     
void dump (const char * file,
    scalar * list,
    FILE * fp,
    bool unbuffered,
    bool zero)
{tracing("dump","/home/spencer/basilisk/src/output.h",1077);
  char * name = NULL;
  if (!fp) {
    name = (char *) pmalloc (strlen(file) + 2,__func__,__FILE__,__LINE__);
    strcpy (name, file);
    if (!unbuffered)
      strcat (name, "~");
    if ((fp = fopen (name, "w")) == NULL) {
      perror (name);
      exit (1);
    }
  }
  if (!(fp)) qassert ("/home/spencer/basilisk/src/output.h", 1094, "fp");

  scalar * dlist = dump_list (list, zero);
  scalar  size=new_scalar("size");
  scalar * slist = list_concat (((scalar[]){size,{-1}}), dlist); pfree (dlist,__func__,__FILE__,__LINE__);
  struct DumpHeader header = { t, list_len(slist), iter, depth(), npe(),
          dump_version };
  int npe = 1;
   {
    header.n.x = Dimensions.x;
    npe *= header.n.x;
  } 
#line 1102
{
    header.n.y = Dimensions.y;
    npe *= header.n.y;
  }
  header.npe = npe;
  dump_header (fp, &header, slist);

  subtree_size (size, false);
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1115 "/home/spencer/basilisk/src/output.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1115 "/home/spencer/basilisk/src/output.h"
{
    unsigned flags = is_leaf(cell) ? leaf : 0;
    if (fwrite (&flags, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing flags");
      exit (1);
    }
    {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      double val = val(s,0,0,0);
      if (fwrite (&val, sizeof(double), 1, fp) < 1) {
 perror ("dump(): error while writing scalars");
 exit (1);
      }
    }}}
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}

  
#line 1132 "/home/spencer/basilisk/src/output.h"
pfree (slist,__func__,__FILE__,__LINE__);
  if (file) {
    fclose (fp);
    if (!unbuffered)
      rename (name, file);
    pfree (name,__func__,__FILE__,__LINE__);
  }delete((scalar*)((scalar[]){size,{-1}}));
end_tracing("dump","/home/spencer/basilisk/src/output.h",1139);}
#line 1219 "/home/spencer/basilisk/src/output.h"
     
bool restore (const char * file,
       scalar * list,
       FILE * fp)
{tracing("restore","/home/spencer/basilisk/src/output.h",1220);
  if (!fp && (fp = fopen (file, "r")) == NULL)
    {end_tracing("restore","/home/spencer/basilisk/src/output.h",1225);return false;}
  if (!(fp)) qassert ("/home/spencer/basilisk/src/output.h", 1226, "fp");

  struct DumpHeader header = {0};
  if (fread (&header, sizeof(header), 1, fp) < 1) {
    fprintf (ferr, "restore(): error: expecting header\n");
    exit (1);
  }


  init_grid (1);
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1236 "/home/spencer/basilisk/src/output.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1236 "/home/spencer/basilisk/src/output.h"
{
    cell.pid = pid();
    cell.flags |= active;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}
  
#line 1240 "/home/spencer/basilisk/src/output.h"
((Tree *)grid)->dirty = true;
#line 1259 "/home/spencer/basilisk/src/output.h"
  bool restore_all = (list == all);
  scalar * slist = dump_list (list ? list : all, true);
  if (header.version == 161020) {
    if (header.len - 1 != list_len (slist)) {
      fprintf (ferr,
        "restore(): error: the list lengths don't match: "
        "%ld (file) != %d (code)\n",
        header.len - 1, list_len (slist));
      exit (1);
    }
  }
  else {
    if (header.version != dump_version) {
      fprintf (ferr,
        "restore(): error: file version mismatch: "
        "%d (file) != %d (code)\n",
        header.version, dump_version);
      exit (1);
    }

    scalar * input = NULL;
    for (int i = 0; i < header.len; i++) {
      unsigned len;
      if (fread (&len, sizeof(unsigned), 1, fp) < 1) {
 fprintf (ferr, "restore(): error: expecting len\n");
 exit (1);
      }
      char name[len + 1];
      if (fread (name, sizeof(char), len, fp) < 1) {
 fprintf (ferr, "restore(): error: expecting s.name\n");
 exit (1);
      }
      name[len] = '\0';

      if (i > 0) {
 bool found = false;
 {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   if (!strcmp (_attribute[s.i].name, name)) {
     input = list_append (input, s);
     found = true; break;
   }}}
 if (!found) {
   if (restore_all) {
     scalar s = new_scalar("s");
     pfree (_attribute[s.i].name,__func__,__FILE__,__LINE__);
     _attribute[s.i].name = pstrdup (name,__func__,__FILE__,__LINE__);
     input = list_append (input, s);
   }
   else
     input = list_append (input, (scalar){INT_MAX});
 }
      }
    }
    pfree (slist,__func__,__FILE__,__LINE__);
    slist = input;

    double o[4];
    if (fread (o, sizeof(double), 4, fp) < 4) {
      fprintf (ferr, "restore(): error: expecting coordinates\n");
      exit (1);
    }
    origin (o[0], o[1], o[2]);
    size (o[3]);
  }
#line 1334 "/home/spencer/basilisk/src/output.h"
  scalar * listm = is_constant(cm) ? NULL : (scalar *)((vector[]){fm,{{-1},{-1}}});
#line 126 "/home/spencer/basilisk/src/grid/foreach_cell.h"
{
  {



    Point root = {2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};



    struct { int l, i, j, stage; } stack[20];




    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1338 "/home/spencer/basilisk/src/output.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1338 "/home/spencer/basilisk/src/output.h"
{
    unsigned flags;
    if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
      fprintf (ferr, "restore(): error: expecting 'flags'\n");
      exit (1);
    }

    fseek (fp, sizeof(double), SEEK_CUR);
    {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      double val;
      if (fread (&val, sizeof(double), 1, fp) != 1) {
 fprintf (ferr, "restore(): error: expecting a scalar\n");
 exit (1);
      }
      if (s.i != INT_MAX)
 val(s,0,0,0) = isfinite(val) ? val : 1e30f;
    }}}
    if (!(flags & leaf) && is_leaf(cell))
      refine_cell (point, listm, 0, NULL);
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/spencer/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; };
 }
 break;
      }



      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break;
#line 120 "/home/spencer/basilisk/src/grid/foreach_cell.h"
      }
    }
  }
}
  
#line 137
}
}





  
#line 1365 "/home/spencer/basilisk/src/output.h"
{scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = true;}}


  scalar * other = NULL;
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!list_lookup (slist, s) && !list_lookup (listm, s))
      other = list_append (other, s);}}
  reset (other, 0.);
  pfree (other,__func__,__FILE__,__LINE__);

  pfree (slist,__func__,__FILE__,__LINE__);
  if (file)
    fclose (fp);


  while (iter < header.i && events (false))
    iter = inext;
  events (false);
  while (t < header.t && events (false))
    t = tnext;
  t = header.t;
  events (false);

  {end_tracing("restore","/home/spencer/basilisk/src/output.h",1389);return true;}
end_tracing("restore","/home/spencer/basilisk/src/output.h",1390);}
#line 396 "/home/spencer/basilisk/src/utils.h"
#line 12 "/home/spencer/basilisk/src/run.h"

     
void run (void)
{tracing("run","/home/spencer/basilisk/src/run.h",14);
  iter = 0, t = 0., dt = 1.;
  init_grid (N);

  perf.nc = perf.tnc = 0;
  perf.gt = timer_start();
  while (events (true)) {





    update_perf();
    iter = inext, t = tnext;
  }




  timer_print (perf.gt, iter, perf.tnc);

  free_grid();
end_tracing("run","/home/spencer/basilisk/src/run.h",37);}




static int defaults_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int defaults(const int i,const double t,Event *_ev){tracing("defaults","/home/spencer/basilisk/src/run.h",42); {
  display ("box();"
#line 494 "/home/spencer/basilisk/src/common.h"
, false
#line 43 "/home/spencer/basilisk/src/run.h"
);
}{end_tracing("defaults","/home/spencer/basilisk/src/run.h",44);return 0;}end_tracing("defaults","/home/spencer/basilisk/src/run.h",44);}





static int cleanup_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = TEND_EVENT)!=0;*ip=i;*tp=t;return ret;}      static int cleanup(const int i,const double t,Event *_ev){tracing("cleanup","/home/spencer/basilisk/src/run.h",50); {
  display ("", true);
}{end_tracing("cleanup","/home/spencer/basilisk/src/run.h",52);return 0;}end_tracing("cleanup","/home/spencer/basilisk/src/run.h",52);}
#line 29 "./../my-centered.h"
#line 1 "./timestep.h"
#line 1 "/home/spencer/basilisk/src/timestep.h"

double timestep (const vector u, double dtmax)
{
  static double previous = 0.;
  if (t == 0.) previous = 0.;
  dtmax /= CFL;
if(!is_constant(fm.x)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/timestep.h", .line = 7, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 7 "/home/spencer/basilisk/src/timestep.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 8 "/home/spencer/basilisk/src/timestep.h"
{_stencil_val(u.x,0,0,0); {   
      _stencil_val(u.x,0,0,0);
_stencil_val(fm.x,0,0,0); 
_stencil_val(fm.x,0,0,0);    

}   } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 8 "/home/spencer/basilisk/src/timestep.h"
{_stencil_val(u.y,0,0,0); {   
      _stencil_val(u.y,0,0,0);
_stencil_val(fm.y,0,0,0); 
_stencil_val(fm.y,0,0,0);    

}   }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(min:dtmax)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 7 "/home/spencer/basilisk/src/timestep.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 8 "/home/spencer/basilisk/src/timestep.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 8 "/home/spencer/basilisk/src/timestep.h"
if (val(u.x,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.x,0,0,0));
      if (!(val(fm.x,0,0,0))) qassert ("/home/spencer/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= val(fm.x,0,0,0);
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 8 "/home/spencer/basilisk/src/timestep.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 8 "/home/spencer/basilisk/src/timestep.h"
if (val(u.y,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.y,0,0,0));
      if (!(val(fm.y,0,0,0))) qassert ("/home/spencer/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= val(fm.y,0,0,0);
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 13 "/home/spencer/basilisk/src/timestep.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 13 "/home/spencer/basilisk/src/timestep.h"
{mpi_all_reduce_array(&dtmax,MPI_DOUBLE,MPI_MIN,1);}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/timestep.h", .line = 7, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 7 "/home/spencer/basilisk/src/timestep.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 8 "/home/spencer/basilisk/src/timestep.h"
{_stencil_val(u.x,0,0,0); {   
      _stencil_val(u.x,0,0,0);
;
;    

}   } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 8 "/home/spencer/basilisk/src/timestep.h"
{_stencil_val(u.y,0,0,0); {   
      _stencil_val(u.y,0,0,0);
;
;    

}   }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(min:dtmax)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 7 "/home/spencer/basilisk/src/timestep.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 8 "/home/spencer/basilisk/src/timestep.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 8 "/home/spencer/basilisk/src/timestep.h"
if (val(u.x,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.x,0,0,0));
      if (!(_const_fm.x)) qassert ("/home/spencer/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= _const_fm.x;
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 8 "/home/spencer/basilisk/src/timestep.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 8 "/home/spencer/basilisk/src/timestep.h"
if (val(u.y,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.y,0,0,0));
      if (!(_const_fm.y)) qassert ("/home/spencer/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= _const_fm.y;
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 13 "/home/spencer/basilisk/src/timestep.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 13 "/home/spencer/basilisk/src/timestep.h"
{mpi_all_reduce_array(&dtmax,MPI_DOUBLE,MPI_MIN,1);}}
  dtmax *= CFL;
  if (dtmax > previous)
    dtmax = (previous + 0.1*dtmax)/1.1;
  previous = dtmax;
  return dtmax;
}
#line 30 "./../my-centered.h"
#line 1 "../my-bcg.h"
#line 1 "./../my-bcg.h"
#line 11 "./../my-bcg.h"
void tracer_fluxes (scalar f,
      vector uf,
      vector flux,
      double dt,
              scalar src)
{





  vector  g=new_vector("g");





  gradients_ibm (((scalar[]){f,{-1}}),((vector[]) {g,{{-1},{-1}}}));







if(!is_constant(fm.x) && !is_constant(src)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-bcg.h", .line = 36, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 36 "./../my-bcg.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 36 "./../my-bcg.h"
{              
#line 45 "./../my-bcg.h"
    _stencil_val(fm.x,0,0,0);_stencil_val(uf.x,0,0,0); _stencil_val(ibmFaces.x,0,0,0);              




    
    _stencil_val(g.x,o_stencil,0,0); _stencil_val(src,-1,0,0);_stencil_val(src,0,0,0);_stencil_val(f, o_stencil,0,0);





_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {     
       _stencil_val(fm.y,o_stencil,1,0);_stencil_val(fm.y,o_stencil,0,0); _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }








_stencil_val(uf.x,0,0,0);





      
#line 70 "./../my-bcg.h"
    _stencil_val_a(flux.x,0,0,0);  
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 36 "./../my-bcg.h"
{              
#line 45 "./../my-bcg.h"
    _stencil_val(fm.y,0,0,0);_stencil_val(uf.y,0,0,0); _stencil_val(ibmFaces.y,0,0,0);              




    
    _stencil_val(g.y,0,o_stencil,0); _stencil_val(src,0,-1,0);_stencil_val(src,0,0,0);_stencil_val(f,0, o_stencil,0);





_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {     
       _stencil_val(fm.x,1,o_stencil,0);_stencil_val(fm.x,0,o_stencil,0); _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }








_stencil_val(uf.y,0,0,0);





      
#line 70 "./../my-bcg.h"
    _stencil_val_a(flux.y,0,0,0);  
  }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 36 "./../my-bcg.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 36 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 36 "./../my-bcg.h"
{
#line 45 "./../my-bcg.h"
    double un = val(ibmFaces.x,0,0,0)*dt*val(uf.x,0,0,0)/(val(fm.x,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));




    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (val(src,0,0,0) + val(src,-1,0,0))*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(val(fm.y,i,0,0) + val(fm.y,i,1,0));
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 70 "./../my-bcg.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 36 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 36 "./../my-bcg.h"
{
#line 45 "./../my-bcg.h"
    double un = val(ibmFaces.y,0,0,0)*dt*val(uf.y,0,0,0)/(val(fm.y,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));




    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (val(src,0,0,0) + val(src,0,-1,0))*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(val(fm.x,0,i,0) + val(fm.x,1,i,0));
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 70 "./../my-bcg.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 71 "./../my-bcg.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 71 "./../my-bcg.h"
}else if(is_constant(fm.x) && !is_constant(src)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-bcg.h", .line = 36, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 36 "./../my-bcg.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 36 "./../my-bcg.h"
{








;_stencil_val(uf.x,0,0,0); _stencil_val(ibmFaces.x,0,0,0);              




    
    _stencil_val(g.x,o_stencil,0,0); _stencil_val(src,-1,0,0);_stencil_val(src,0,0,0);_stencil_val(f, o_stencil,0,0);





;; {
;; _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }








_stencil_val(uf.x,0,0,0);





      
#line 70 "./../my-bcg.h"
    _stencil_val_a(flux.x,0,0,0);  
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 36 "./../my-bcg.h"
{








;_stencil_val(uf.y,0,0,0); _stencil_val(ibmFaces.y,0,0,0);              




    
    _stencil_val(g.y,0,o_stencil,0); _stencil_val(src,0,-1,0);_stencil_val(src,0,0,0);_stencil_val(f,0, o_stencil,0);





;; {
;; _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }








_stencil_val(uf.y,0,0,0);





      
#line 70 "./../my-bcg.h"
    _stencil_val_a(flux.y,0,0,0);  
  }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 36 "./../my-bcg.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 36 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 36 "./../my-bcg.h"
{
#line 45 "./../my-bcg.h"
    double un = val(ibmFaces.x,0,0,0)*dt*val(uf.x,0,0,0)/(_const_fm.x*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));




    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (val(src,0,0,0) + val(src,-1,0,0))*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 70 "./../my-bcg.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 36 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 36 "./../my-bcg.h"
{
#line 45 "./../my-bcg.h"
    double un = val(ibmFaces.y,0,0,0)*dt*val(uf.y,0,0,0)/(_const_fm.y*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));




    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (val(src,0,0,0) + val(src,0,-1,0))*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 70 "./../my-bcg.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 71 "./../my-bcg.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 71 "./../my-bcg.h"
}else if(!is_constant(fm.x) && is_constant(src)){double _const_src=_constant[src.i-_NVARMAX];NOT_UNUSED(_const_src);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-bcg.h", .line = 36, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 36 "./../my-bcg.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 36 "./../my-bcg.h"
{              
#line 45 "./../my-bcg.h"
    _stencil_val(fm.x,0,0,0);_stencil_val(uf.x,0,0,0); _stencil_val(ibmFaces.x,0,0,0);              




    
    _stencil_val(g.x,o_stencil,0,0);;;_stencil_val(f, o_stencil,0,0);





_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {     
       _stencil_val(fm.y,o_stencil,1,0);_stencil_val(fm.y,o_stencil,0,0); _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }








_stencil_val(uf.x,0,0,0);





      
#line 70 "./../my-bcg.h"
    _stencil_val_a(flux.x,0,0,0);  
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 36 "./../my-bcg.h"
{              
#line 45 "./../my-bcg.h"
    _stencil_val(fm.y,0,0,0);_stencil_val(uf.y,0,0,0); _stencil_val(ibmFaces.y,0,0,0);              




    
    _stencil_val(g.y,0,o_stencil,0);;;_stencil_val(f,0, o_stencil,0);





_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {     
       _stencil_val(fm.x,1,o_stencil,0);_stencil_val(fm.x,0,o_stencil,0); _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }








_stencil_val(uf.y,0,0,0);





      
#line 70 "./../my-bcg.h"
    _stencil_val_a(flux.y,0,0,0);  
  }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 36 "./../my-bcg.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 36 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 36 "./../my-bcg.h"
{
#line 45 "./../my-bcg.h"
    double un = val(ibmFaces.x,0,0,0)*dt*val(uf.x,0,0,0)/(val(fm.x,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));




    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(val(fm.y,i,0,0) + val(fm.y,i,1,0));
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 70 "./../my-bcg.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 36 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 36 "./../my-bcg.h"
{
#line 45 "./../my-bcg.h"
    double un = val(ibmFaces.y,0,0,0)*dt*val(uf.y,0,0,0)/(val(fm.y,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));




    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(val(fm.x,0,i,0) + val(fm.x,1,i,0));
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 70 "./../my-bcg.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 71 "./../my-bcg.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 71 "./../my-bcg.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_src=_constant[src.i-_NVARMAX];NOT_UNUSED(_const_src);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-bcg.h", .line = 36, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 36 "./../my-bcg.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 36 "./../my-bcg.h"
{








;_stencil_val(uf.x,0,0,0); _stencil_val(ibmFaces.x,0,0,0);              




    
    _stencil_val(g.x,o_stencil,0,0);;;_stencil_val(f, o_stencil,0,0);





;; {
;; _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }








_stencil_val(uf.x,0,0,0);





      
#line 70 "./../my-bcg.h"
    _stencil_val_a(flux.x,0,0,0);  
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 36 "./../my-bcg.h"
{








;_stencil_val(uf.y,0,0,0); _stencil_val(ibmFaces.y,0,0,0);              




    
    _stencil_val(g.y,0,o_stencil,0);;;_stencil_val(f,0, o_stencil,0);





;; {
;; _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }








_stencil_val(uf.y,0,0,0);





      
#line 70 "./../my-bcg.h"
    _stencil_val_a(flux.y,0,0,0);  
  }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 36 "./../my-bcg.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 36 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 36 "./../my-bcg.h"
{
#line 45 "./../my-bcg.h"
    double un = val(ibmFaces.x,0,0,0)*dt*val(uf.x,0,0,0)/(_const_fm.x*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));




    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 70 "./../my-bcg.h"
    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 36 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 36 "./../my-bcg.h"
{
#line 45 "./../my-bcg.h"
    double un = val(ibmFaces.y,0,0,0)*dt*val(uf.y,0,0,0)/(_const_fm.y*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));




    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }
#line 70 "./../my-bcg.h"
    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 71 "./../my-bcg.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 71 "./../my-bcg.h"
}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}






void advection (scalar * tracers, vector u, double dt,
  scalar * src)
{




  scalar * psrc = src;
  if (!src)
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      const scalar zero = new_const_scalar("zero",12, 0.);
      src = list_append (src, zero);
    }}}
  if (!(list_len (tracers) == list_len (src))) qassert ("./../my-bcg.h", 92, "list_len (tracers) == list_len (src)");

  scalar f, source;
  {scalar*_i0=src;scalar*_i1= tracers;if(_i0)for(source=*_i0,f=*_i1;_i0->i>= 0;source=*++_i0,f=*++_i1){ {
    vector  flux=new_face_vector("flux");
    tracer_fluxes (f, u, flux, dt, source);

    if(!is_constant(cm)){
  

    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-bcg.h", .line = 99, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 100 "./../my-bcg.h"
{ { 

_stencil_val(ibmCells,0,0,0);_stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);_stencil_val(cm,0,0,0);        _stencil_val_r(f,0,0,0);

_stencil_val(f,0,0,0);
           { _stencil_val(f,0,0,0);    }      



} 
#line 100
{ 

_stencil_val(ibmCells,0,0,0);_stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);_stencil_val(cm,0,0,0);        _stencil_val_r(f,0,0,0);

_stencil_val(f,0,0,0);
           { _stencil_val(f,0,0,0);    }      



}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;      
#line 100 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-bcg.h"
{ {

        val(f,0,0,0) += val(ibmCells,0,0,0)*dt*(val(flux.x,0,0,0) - val(flux.x,1,0,0))/(Delta*val(cm,0,0,0)+1e-30);

        if (fabs(val(f,0,0,0)) > 1e100)
           fprintf(ferr, "WARNING in bcg.h: f[] = %g in (%g, %g) exceeds %g\n", val(f,0,0,0), x, y, 1e100);



      } 
#line 100
{

        val(f,0,0,0) += val(ibmCells,0,0,0)*dt*(val(flux.y,0,0,0) - val(flux.y,0,1,0))/(Delta*val(cm,0,0,0)+1e-30);

        if (fabs(val(f,0,0,0)) > 1e100)
           fprintf(ferr, "WARNING in bcg.h: f[] = %g in (%g, %g) exceeds %g\n", val(f,0,0,0), x, y, 1e100);



      }}}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 109 "./../my-bcg.h"
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-bcg.h", .line = 99, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 100 "./../my-bcg.h"
{ { 

_stencil_val(ibmCells,0,0,0);_stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);;        _stencil_val_r(f,0,0,0);

_stencil_val(f,0,0,0);
           { _stencil_val(f,0,0,0);    }      



} 
#line 100
{ 

_stencil_val(ibmCells,0,0,0);_stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);;        _stencil_val_r(f,0,0,0);

_stencil_val(f,0,0,0);
           { _stencil_val(f,0,0,0);    }      



}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;      
#line 100 "./../my-bcg.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-bcg.h"
{ {

        val(f,0,0,0) += val(ibmCells,0,0,0)*dt*(val(flux.x,0,0,0) - val(flux.x,1,0,0))/(Delta*_const_cm+1e-30);

        if (fabs(val(f,0,0,0)) > 1e100)
           fprintf(ferr, "WARNING in bcg.h: f[] = %g in (%g, %g) exceeds %g\n", val(f,0,0,0), x, y, 1e100);



      } 
#line 100
{

        val(f,0,0,0) += val(ibmCells,0,0,0)*dt*(val(flux.y,0,0,0) - val(flux.y,0,1,0))/(Delta*_const_cm+1e-30);

        if (fabs(val(f,0,0,0)) > 1e100)
           fprintf(ferr, "WARNING in bcg.h: f[] = %g in (%g, %g) exceeds %g\n", val(f,0,0,0), x, y, 1e100);



      }}}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 109 "./../my-bcg.h"
}delete((scalar*)((vector[]){flux,{{-1},{-1}}}));



  }}}

  if (!psrc)
    pfree (src,__func__,__FILE__,__LINE__);
}
#line 31 "./../my-centered.h"





#line 1 "../my-viscosity-gcm-old.h"
#line 1 "./../my-viscosity-gcm-old.h"
#line 1 "../my-poisson.h"
#line 1 "./../my-poisson.h"
#line 32 "./../my-poisson.h"
void mg_cycle (scalar * a, scalar * res, scalar * da,
        void (* relax) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{




  restriction (res);





  minlevel = ( minlevel < maxlevel ? minlevel : maxlevel);
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
      {
  
  
      
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);     
#line 56 "./../my-poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      
         {_stencil_val_a(s,0,0,0);  }}}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell))     
#line 56 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      
         val(s,0,0,0) = 0.;}}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 58 "./../my-poisson.h"
}





    else {
      boundary_level (da, l - 1);
  
      
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);     
#line 67 "./../my-poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      
         { _stencil_bilinear_ibm(point, s);_stencil_val_a(s,0,0,0); }}}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;     
#line 67 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 67 "./../my-poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      
         val(s,0,0,0) = bilinear_ibm(point, s);}}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}    
#line 70 "./../my-poisson.h"
}





    for (int i = 0; i < nrelax; i++) {
      boundary_level (da, l);
      relax (da, res, l, data);
    }
  }
  




  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 85, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 85 "./../my-poisson.h"
{
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
     { _stencil_val(ds,0,0,0);_stencil_val_r(s,0,0,0); }}}
  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 85 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 85 "./../my-poisson.h"
{
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
     val(s,0,0,0) += val(ds,0,0,0);}}
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 91 "./../my-poisson.h"
}
#line 103 "./../my-poisson.h"
int NITERMAX = 100, NITERMIN = 1;
double TOLERANCE = 1e-3;




typedef struct {
  int i;
  double resb, resa;
  double sum;
  int nrelax;
  int minlevel;
} mgstats;
#line 126 "./../my-poisson.h"
mgstats mg_solve (scalar * a, scalar * b,
            double (* residual) (scalar * a, scalar * b, scalar * res,
                                 void * data),
            void (* relax) (scalar * da, scalar * res, int depth,
                                 void * data),
            void * data,
            int nrelax,
            scalar * res,
            int minlevel,
            double tolerance)
{





  scalar * da = list_clone (a), * pres = res;
  if (!res)
    res = list_clone (b);






  for (int b = 0; b < nboundary; b++)
    {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];}}




  mgstats s = {0};
  double sum = 0.;
  scalar rhs = b[0];
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 161, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 162 "./../my-poisson.h"
{ _stencil_val(rhs,0,0,0); }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:sum)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 162 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 162 "./../my-poisson.h"
sum += val(rhs,0,0,0);}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 162 "./../my-poisson.h"
{mpi_all_reduce_array(&sum,MPI_DOUBLE,MPI_SUM,1);}
  s.sum = sum;
  s.nrelax = nrelax > 0 ? nrelax : 4;




  double resb;
  resb = s.resb = s.resa = (* residual) (a, b, res, data);
  

      
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);     
#line 173 "./../my-poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      
         { _stencil_bilinear_ibm(point, s);_stencil_val_a(s,0,0,0); }}}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (minlevel <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[minlevel];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = minlevel;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;     
#line 173 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 173 "./../my-poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      
         val(s,0,0,0) = bilinear_ibm(point, s);}}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}  
#line 182 "./../my-poisson.h"
for (s.i = 0;
       s.i < NITERMAX && (s.i < NITERMIN || s.resa > tolerance);
       s.i++) {
    mg_cycle (a, res, da, relax, data,
       s.nrelax,
       minlevel,
       grid->maxdepth);
    s.resa = (* residual) (a, b, res, data);
#line 198 "./../my-poisson.h"
    if (s.resa > tolerance) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
 s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
 s.nrelax--;
    }






    resb = s.resa;
  }
  s.minlevel = minlevel;




  if (s.resa > tolerance) {
    scalar v = a[0];
    fprintf (ferr,
      "WARNING: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d tolerance: %g\n", _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax, tolerance), fflush (ferr);
  }




  if (!pres)
    delete (res), pfree (res,__func__,__FILE__,__LINE__);
  delete (da), pfree (da,__func__,__FILE__,__LINE__);

  return s;
}
#line 256 "./../my-poisson.h"
struct Poisson {
  scalar a, b;
          vector alpha;
          scalar lambda;
  double tolerance;
  int nrelax, minlevel;
  scalar * res;



};





static void relax (scalar * al, scalar * bl, int l, void * data)
{
  scalar a = al[0], b = bl[0];
  struct Poisson * p = (struct Poisson *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;
#line 294 "./../my-poisson.h"
  scalar c = a;







  if(!is_constant(lambda) && !is_constant(alpha.x)){
  
  







  
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 302 "./../my-poisson.h"
{         
     _stencil_val(lambda,0,0,0);_stencil_val(b,0,0,0);
     { 
_stencil_val(alpha.x,1,0,0);_stencil_val(a,1,0,0); _stencil_val(alpha.x,0,0,0);_stencil_val(a,-1,0,0);
         _stencil_val(alpha.x,1,0,0); _stencil_val(alpha.x,0,0,0);    
} 
#line 304
{ 
_stencil_val(alpha.y,0,1,0);_stencil_val(a,0,1,0); _stencil_val(alpha.y,0,0,0);_stencil_val(a,0,-1,0);
         _stencil_val(alpha.y,0,1,0); _stencil_val(alpha.y,0,0,0);    
}
#line 318
{
      {_stencil_val_a(c,0,0,0); _stencil_val_a(b,0,0,0);    }

        
{_stencil_val_a(c,0,0,0);  }}
#line 318 "./../my-poisson.h"
     
    
  


}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 302 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 302 "./../my-poisson.h"
{
    double n = - ( Delta*Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*( Delta*Delta);
     {
      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
    } 
#line 304
{
      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
    }
#line 318 "./../my-poisson.h"
    if (!d)
      val(c,0,0,0) = 0., val(b,0,0,0) = 0.;
    else

        val(c,0,0,0) = n/d;
  }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 323 "./../my-poisson.h"
}else if(is_constant(lambda) && !is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);
  
  







  
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 302 "./../my-poisson.h"
{
;_stencil_val(b,0,0,0);
     { 
_stencil_val(alpha.x,1,0,0);_stencil_val(a,1,0,0); _stencil_val(alpha.x,0,0,0);_stencil_val(a,-1,0,0);
         _stencil_val(alpha.x,1,0,0); _stencil_val(alpha.x,0,0,0);    
} 
#line 304
{ 
_stencil_val(alpha.y,0,1,0);_stencil_val(a,0,1,0); _stencil_val(alpha.y,0,0,0);_stencil_val(a,0,-1,0);
         _stencil_val(alpha.y,0,1,0); _stencil_val(alpha.y,0,0,0);    
}
#line 318
{
      {_stencil_val_a(c,0,0,0); _stencil_val_a(b,0,0,0);    }

        
{_stencil_val_a(c,0,0,0);  }}
#line 318 "./../my-poisson.h"
     
    
  


}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 302 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 302 "./../my-poisson.h"
{
    double n = - ( Delta*Delta)*val(b,0,0,0), d = - _const_lambda*( Delta*Delta);
     {
      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
    } 
#line 304
{
      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
    }
#line 318 "./../my-poisson.h"
    if (!d)
      val(c,0,0,0) = 0., val(b,0,0,0) = 0.;
    else

        val(c,0,0,0) = n/d;
  }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 323 "./../my-poisson.h"
}else if(!is_constant(lambda) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  







  
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 302 "./../my-poisson.h"
{         
     _stencil_val(lambda,0,0,0);_stencil_val(b,0,0,0);
     {
;_stencil_val(a,1,0,0);;_stencil_val(a,-1,0,0);
;;    
} 
#line 304
{
;_stencil_val(a,0,1,0);;_stencil_val(a,0,-1,0);
;;    
}
#line 318
{
      {_stencil_val_a(c,0,0,0); _stencil_val_a(b,0,0,0);    }

        
{_stencil_val_a(c,0,0,0);  }}
#line 318 "./../my-poisson.h"
     
    
  


}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 302 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 302 "./../my-poisson.h"
{
    double n = - ( Delta*Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*( Delta*Delta);
     {
      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
      d += _const_alpha.x + _const_alpha.x;
    } 
#line 304
{
      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
      d += _const_alpha.y + _const_alpha.y;
    }
#line 318 "./../my-poisson.h"
    if (!d)
      val(c,0,0,0) = 0., val(b,0,0,0) = 0.;
    else

        val(c,0,0,0) = n/d;
  }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 323 "./../my-poisson.h"
}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  







  
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 302 "./../my-poisson.h"
{
;_stencil_val(b,0,0,0);
     {
;_stencil_val(a,1,0,0);;_stencil_val(a,-1,0,0);
;;    
} 
#line 304
{
;_stencil_val(a,0,1,0);;_stencil_val(a,0,-1,0);
;;    
}
#line 318
{
      {_stencil_val_a(c,0,0,0); _stencil_val_a(b,0,0,0);    }

        
{_stencil_val_a(c,0,0,0);  }}
#line 318 "./../my-poisson.h"
     
    
  


}
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 302 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 302 "./../my-poisson.h"
{
    double n = - ( Delta*Delta)*val(b,0,0,0), d = - _const_lambda*( Delta*Delta);
     {
      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
      d += _const_alpha.x + _const_alpha.x;
    } 
#line 304
{
      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
      d += _const_alpha.y + _const_alpha.y;
    }
#line 318 "./../my-poisson.h"
    if (!d)
      val(c,0,0,0) = 0., val(b,0,0,0) = 0.;
    else

        val(c,0,0,0) = n/d;
  }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 323 "./../my-poisson.h"
}
#line 341 "./../my-poisson.h"
}






static double residual (scalar * al, scalar * bl, scalar * resl, void * data)
{
  scalar a = al[0], b = bl[0], res = resl[0];
  struct Poisson * p = (struct Poisson *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;
  double maxres = 0.;


  vector  g=new_face_vector("g");
if(!is_constant(alpha.x)){  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 358, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 358 "./../my-poisson.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 358 "./../my-poisson.h"
{ 
_stencil_val(alpha.x,0,0,0);_stencil_val(a,0,0,0); _stencil_val(a,0 -1,0,0);    _stencil_val_a(g.x,0,0,0);    
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 358 "./../my-poisson.h"
{ 
_stencil_val(alpha.y,0,0,0);_stencil_val(a,0,0,0); _stencil_val(a,0,0 -1,0);    _stencil_val_a(g.y,0,0,0);    
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 358 "./../my-poisson.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 358 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 358 "./../my-poisson.h"
{
    val(g.x,0,0,0) = val(alpha.x,0,0,0) * ((val(a,0,0,0) - val(a,0 -1,0,0))/Delta);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 358 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 358 "./../my-poisson.h"
{
    val(g.y,0,0,0) = val(alpha.y,0,0,0) * ((val(a,0,0,0) - val(a,0,0 -1,0))/Delta);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 360 "./../my-poisson.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 360 "./../my-poisson.h"
}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 358, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 358 "./../my-poisson.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 358 "./../my-poisson.h"
{
;_stencil_val(a,0,0,0); _stencil_val(a,0 -1,0,0);    _stencil_val_a(g.x,0,0,0);    
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 358 "./../my-poisson.h"
{
;_stencil_val(a,0,0,0); _stencil_val(a,0,0 -1,0);    _stencil_val_a(g.y,0,0,0);    
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 358 "./../my-poisson.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 358 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 358 "./../my-poisson.h"
{
    val(g.x,0,0,0) = _const_alpha.x * ((val(a,0,0,0) - val(a,0 -1,0,0))/Delta);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 358 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 358 "./../my-poisson.h"
{
    val(g.y,0,0,0) = _const_alpha.y * ((val(a,0,0,0) - val(a,0,0 -1,0))/Delta);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 360 "./../my-poisson.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 360 "./../my-poisson.h"
}
  if(!is_constant(lambda)){  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 361, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 361 "./../my-poisson.h"
{ 
_stencil_val(b,0,0,0); _stencil_val(lambda,0,0,0);_stencil_val(a,0,0,0);    _stencil_val_a(res,0,0,0);  
    
      {_stencil_val(g.x,1,0,0); _stencil_val(g.x,0,0,0);_stencil_val_r(res,0,0,0);   }      {_stencil_val(g.y,0,1,0); _stencil_val(g.y,0,0,0);_stencil_val_r(res,0,0,0);   }






_stencil_val(res,0,0,0);
      {_stencil_val(res,0,0,0);   }  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 361 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 361 "./../my-poisson.h"
{
    val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
    
      val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;      val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;






    if (fabs (val(res,0,0,0)) > maxres)
      maxres = fabs (val(res,0,0,0));
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 373 "./../my-poisson.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 361, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 361 "./../my-poisson.h"
{ 
_stencil_val(b,0,0,0);;_stencil_val(a,0,0,0);    _stencil_val_a(res,0,0,0);  
    
      {_stencil_val(g.x,1,0,0); _stencil_val(g.x,0,0,0);_stencil_val_r(res,0,0,0);   }      {_stencil_val(g.y,0,1,0); _stencil_val(g.y,0,0,0);_stencil_val_r(res,0,0,0);   }






_stencil_val(res,0,0,0);
      {_stencil_val(res,0,0,0);   }  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 361 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 361 "./../my-poisson.h"
{
    val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
    
      val(res,0,0,0) -= (val(g.x,1,0,0) - val(g.x,0,0,0))/Delta;      val(res,0,0,0) -= (val(g.y,0,1,0) - val(g.y,0,0,0))/Delta;






    if (fabs (val(res,0,0,0)) > maxres)
      maxres = fabs (val(res,0,0,0));
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 373 "./../my-poisson.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}
#line 391 "./../my-poisson.h"
  {delete((scalar*)((vector[]){g,{{-1},{-1}}}));return maxres;}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
}
#line 403 "./../my-poisson.h"
mgstats poisson (scalar a, scalar b,
           vector alpha,
           scalar lambda,
   double tolerance,
   int nrelax,
   int minlevel,
   scalar * res,
   double (* flux) (Point, scalar, vector, double *))
{






  if (alpha.x.i < 0)
    alpha = new_const_vector("alpha",0,(double[]) {1.,1.,1.});
  if (lambda.i < 0)
    lambda = new_const_scalar("lambda",2, 0.);




  restriction (((scalar[]){alpha.x,alpha.y,lambda,{-1}}));





  double defaultol = TOLERANCE;
  if (tolerance)
    TOLERANCE = tolerance;

  struct Poisson p = {a, b, alpha, lambda, tolerance, nrelax, minlevel, res };






  mgstats s = mg_solve ((
#line 126
scalar *
#line 443
)((scalar[]){a,{-1}}),( 
#line 126
scalar *
#line 443
)((scalar[]) {b,{-1}}), residual, relax, &p
,   nrelax, res, ( 1 > minlevel ? 1 : minlevel)
#line 134
, 
TOLERANCE
#line 444
);




  if (tolerance)
    TOLERANCE = defaultol;

  return s;
}
#line 472 "./../my-poisson.h"
scalar  divg={9},  divg1={10};


     
mgstats project (vector uf, scalar p,
           vector alpha,
   double dt,
   int nrelax)
{tracing("project","./../my-poisson.h",476);






  trash(((scalar[]){divg, divg1,{-1}}));  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 489, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 489 "./../my-poisson.h"
{
    _stencil_val_a(divg,0,0,0);

_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); {    
      
       _stencil_ibm_geometry (point,NULL ,NULL );

      if (local_bc_coordinates) {     

        
        default_stencil ( point,((scalar[]){ u.x,{-1}}) );
        _stencil_val_r(divg,0,0,0);    
      }
      else {
         {     
            
            default_stencil ( point,((scalar[]){ u.x,{-1}}) );
            _stencil_val_r(divg,0,0,0);      
        } 
#line 503
{     
            
            default_stencil ( point,((scalar[]){ u.y,{-1}}) );
            _stencil_val_r(divg,0,0,0);      
        }
      }
    }     
{ 
_stencil_val(ibmf.x,1,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(ibmf.x,0,0,0);_stencil_val(uf.x,0,0,0);      _stencil_val_r(divg,0,0,0);  
    } 
#line 510
{ 
_stencil_val(ibmf.y,0,1,0);_stencil_val(uf.y,0,1,0); _stencil_val(ibmf.y,0,0,0);_stencil_val(uf.y,0,0,0);      _stencil_val_r(divg,0,0,0);  
    }




    _stencil_val_r(divg,0,0,0);  
  }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 489 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 489 "./../my-poisson.h"
{
    val(divg,0,0,0) = 0.;

    if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7)) {
      coord midPoint, n;
      double area = ibm_geometry (point, &midPoint, &n);

      if (local_bc_coordinates) {

        bool dirichlet = false;
        double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, &dirichlet);
        val(divg,0,0,0) -= vb * area;
      }
      else {
         {
            bool dirichlet = false;
            double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, &dirichlet);
            val(divg,0,0,0) -= vb * n.x * area;
        } 
#line 503
{
            bool dirichlet = false;
            double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, &dirichlet);
            val(divg,0,0,0) -= vb * n.y * area;
        }
      }
    }
     {
      val(divg,0,0,0) += val(ibmf.x,1,0,0)*val(uf.x,1,0,0) - val(ibmf.x,0,0,0)*val(uf.x,0,0,0);
    } 
#line 510
{
      val(divg,0,0,0) += val(ibmf.y,0,1,0)*val(uf.y,0,1,0) - val(ibmf.y,0,0,0)*val(uf.y,0,0,0);
    }




    val(divg,0,0,0) /= dt*Delta;
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 520 "./../my-poisson.h"
vector  alpha2=new_face_vector("alpha2");
if(!is_constant(alpha.x) && !is_constant(fm.x)){  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 521, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 521 "./../my-poisson.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 521 "./../my-poisson.h"
{ 
_stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0);    _stencil_val_a(alpha2.x,0,0,0); 
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 521 "./../my-poisson.h"
{ 
_stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0);    _stencil_val_a(alpha2.y,0,0,0); 
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 521 "./../my-poisson.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 521 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 521 "./../my-poisson.h"
{
    val(alpha2.x,0,0,0) = val(alpha.x,0,0,0)*val(fm.x,0,0,0);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 521 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 521 "./../my-poisson.h"
{
    val(alpha2.y,0,0,0) = val(alpha.y,0,0,0)*val(fm.y,0,0,0);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 523 "./../my-poisson.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 523 "./../my-poisson.h"
}else if(is_constant(alpha.x) && !is_constant(fm.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 521, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 521 "./../my-poisson.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 521 "./../my-poisson.h"
{
;_stencil_val(fm.x,0,0,0);    _stencil_val_a(alpha2.x,0,0,0); 
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 521 "./../my-poisson.h"
{
;_stencil_val(fm.y,0,0,0);    _stencil_val_a(alpha2.y,0,0,0); 
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 521 "./../my-poisson.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 521 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 521 "./../my-poisson.h"
{
    val(alpha2.x,0,0,0) = _const_alpha.x*val(fm.x,0,0,0);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 521 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 521 "./../my-poisson.h"
{
    val(alpha2.y,0,0,0) = _const_alpha.y*val(fm.y,0,0,0);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 523 "./../my-poisson.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 523 "./../my-poisson.h"
}else if(!is_constant(alpha.x) && is_constant(fm.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 521, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 521 "./../my-poisson.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 521 "./../my-poisson.h"
{ 
_stencil_val(alpha.x,0,0,0);;    _stencil_val_a(alpha2.x,0,0,0); 
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 521 "./../my-poisson.h"
{ 
_stencil_val(alpha.y,0,0,0);;    _stencil_val_a(alpha2.y,0,0,0); 
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 521 "./../my-poisson.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 521 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 521 "./../my-poisson.h"
{
    val(alpha2.x,0,0,0) = val(alpha.x,0,0,0)*_const_fm.x;
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 521 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 521 "./../my-poisson.h"
{
    val(alpha2.y,0,0,0) = val(alpha.y,0,0,0)*_const_fm.y;
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 523 "./../my-poisson.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 523 "./../my-poisson.h"
}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 521, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 521 "./../my-poisson.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 521 "./../my-poisson.h"
{
;;    _stencil_val_a(alpha2.x,0,0,0); 
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 521 "./../my-poisson.h"
{
;;    _stencil_val_a(alpha2.y,0,0,0); 
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 521 "./../my-poisson.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 521 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 521 "./../my-poisson.h"
{
    val(alpha2.x,0,0,0) = _const_alpha.x*_const_fm.x;
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 521 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 521 "./../my-poisson.h"
{
    val(alpha2.y,0,0,0) = _const_alpha.y*_const_fm.y;
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 523 "./../my-poisson.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 523 "./../my-poisson.h"
}
#line 534 "./../my-poisson.h"
  mgstats mgp = poisson (p, divg, alpha2
#line 404
,
( scalar) {-1}
#line 535
, TOLERANCE/( dt*dt), nrelax
#line 407
, 
0, 
NULL, 
NULL
#line 535
);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 540, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 540 "./../my-poisson.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 540 "./../my-poisson.h"
{    

    _stencil_val(ibmf.x,0,0,0); _stencil_val(alpha2.x,0,0,0);_stencil_val(ibmf.x,0,0,0);

_stencil_val(p,0,0,0); _stencil_val(p,0 -1,0,0);    _stencil_val_r(uf.x,0,0,0);   





  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 540 "./../my-poisson.h"
{    

    _stencil_val(ibmf.y,0,0,0); _stencil_val(alpha2.y,0,0,0);_stencil_val(ibmf.y,0,0,0);

_stencil_val(p,0,0,0); _stencil_val(p,0,0 -1,0);    _stencil_val_r(uf.y,0,0,0);   





  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 540 "./../my-poisson.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 540 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 540 "./../my-poisson.h"
{

    double metric = !val(ibmf.x,0,0,0)? 0: val(alpha2.x,0,0,0)/val(ibmf.x,0,0,0);

    val(uf.x,0,0,0) -= dt*metric*((val(p,0,0,0) - val(p,0 -1,0,0))/Delta);





  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 540 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 540 "./../my-poisson.h"
{

    double metric = !val(ibmf.y,0,0,0)? 0: val(alpha2.y,0,0,0)/val(ibmf.y,0,0,0);

    val(uf.y,0,0,0) -= dt*metric*((val(p,0,0,0) - val(p,0,0 -1,0))/Delta);





  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 550 "./../my-poisson.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-poisson.h", .line = 553, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 553 "./../my-poisson.h"
{
    _stencil_val_a(divg1,0,0,0);

_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); {    
      
       _stencil_ibm_geometry (point,NULL ,NULL );
       {     
          
          default_stencil ( point,((scalar[]){ u.x,{-1}}) );
          _stencil_val_r(divg1,0,0,0);      

      } 
#line 559
{     
          
          default_stencil ( point,((scalar[]){ u.y,{-1}}) );
          _stencil_val_r(divg1,0,0,0);      

      }
    }      


{ _stencil_val(ibmf.x,1,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(ibmf.x,0,0,0);_stencil_val(uf.x,0,0,0);_stencil_val_r(divg1,0,0,0);  }      { _stencil_val(ibmf.y,0,1,0);_stencil_val(uf.y,0,1,0); _stencil_val(ibmf.y,0,0,0);_stencil_val(uf.y,0,0,0);_stencil_val_r(divg1,0,0,0);  }
    _stencil_val_r(divg1,0,0,0);  
  }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 553 "./../my-poisson.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 553 "./../my-poisson.h"
{
    val(divg1,0,0,0) = 0;

    if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7)) {
      coord midPoint, n;
      double area = ibm_geometry (point, &midPoint, &n);
       {
          bool dirichlet = false;
          double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, &dirichlet);
          val(divg1,0,0,0) -= vb * n.x * area;

      } 
#line 559
{
          bool dirichlet = false;
          double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, &dirichlet);
          val(divg1,0,0,0) -= vb * n.y * area;

      }
    }

    
      val(divg1,0,0,0) += val(ibmf.x,1,0,0)*val(uf.x,1,0,0) - val(ibmf.x,0,0,0)*val(uf.x,0,0,0);      val(divg1,0,0,0) += val(ibmf.y,0,1,0)*val(uf.y,0,1,0) - val(ibmf.y,0,0,0)*val(uf.y,0,0,0);
    val(divg1,0,0,0) /= Delta;
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 573 "./../my-poisson.h"
{delete((scalar*)((vector[]){alpha2,{{-1},{-1}}}));{end_tracing("project","./../my-poisson.h",573);return mgp;}}delete((scalar*)((vector[]){alpha2,{{-1},{-1}}}));
end_tracing("project","./../my-poisson.h",574);}
#line 2 "./../my-viscosity-gcm-old.h"

struct Viscosity {
  vector mu;
  scalar rho;
  double dt;
};
#line 16 "./../my-viscosity-gcm-old.h"
static void relax_diffusion (scalar * a, scalar * b, int l, void * data)
{
    struct Viscosity * p = (struct Viscosity *) data;
            vector mu = p->mu;
            scalar rho = p->rho;
    double dt = p->dt;
    vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0])));

    if(!is_constant(mu.x) && !is_constant(rho) && !is_constant(fm.x) && !is_constant(cm)){
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }              { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }
              

         {
            scalar s = u.x;   
            
            
                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);              avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(is_constant(mu.x) && !is_constant(rho) && !is_constant(fm.x) && !is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              {;;  }              {;;  }
              

         {
            scalar s = u.x;   
            
            
                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);;;;;_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);;;;;_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += _const_mu.x + _const_mu.x;              avgmu += _const_mu.y + _const_mu.y;
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(!is_constant(mu.x) && is_constant(rho) && !is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }              { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }
              

         {
            scalar s = u.x;   
            
            
                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
;_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
;_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);              avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(is_constant(mu.x) && is_constant(rho) && !is_constant(fm.x) && !is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              {;;  }              {;;  }
              

         {
            scalar s = u.x;   
            
            
                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
;;;;;_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
;;;;;_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += _const_mu.x + _const_mu.x;              avgmu += _const_mu.y + _const_mu.y;
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(!is_constant(mu.x) && !is_constant(rho) && is_constant(fm.x) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }              { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }
              

         {
            scalar s = u.x;   
            
            
                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);;;;;_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);;;;;_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);              avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(is_constant(mu.x) && !is_constant(rho) && is_constant(fm.x) && !is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              {;;  }              {;;  }
              

         {
            scalar s = u.x;   
            
            
                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);;;;;;;;;_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);;;;;;;;;_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += _const_mu.x + _const_mu.x;              avgmu += _const_mu.y + _const_mu.y;
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(!is_constant(mu.x) && is_constant(rho) && is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }              { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }
              

         {
            scalar s = u.x;   
            
            
                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
;_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);;;;;_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
;_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);;;;;_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);              avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(is_constant(mu.x) && is_constant(rho) && is_constant(fm.x) && !is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              {;;  }              {;;  }
              

         {
            scalar s = u.x;   
            
            
                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
;;;;;;;;;_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
;;;;;;;;;_stencil_val(cm,0,0,0);            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += _const_mu.x + _const_mu.x;              avgmu += _const_mu.y + _const_mu.y;
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(!is_constant(mu.x) && !is_constant(rho) && !is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }              { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }
              

         {
            scalar s = u.x;   
            
            
                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);;            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);;            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);              avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(_const_cm + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(_const_cm + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(is_constant(mu.x) && !is_constant(rho) && !is_constant(fm.x) && is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              {;;  }              {;;  }
              

         {
            scalar s = u.x;   
            
            
                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);;;;;_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);;            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);;;;;_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);;            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += _const_mu.x + _const_mu.x;              avgmu += _const_mu.y + _const_mu.y;
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(_const_cm + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(_const_cm + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(!is_constant(mu.x) && is_constant(rho) && !is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }              { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }
              

         {
            scalar s = u.x;   
            
            
                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
;_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);;            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
;_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);;            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);              avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(_const_cm + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(_const_cm + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(is_constant(mu.x) && is_constant(rho) && !is_constant(fm.x) && is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              {;;  }              {;;  }
              

         {
            scalar s = u.x;   
            
            
                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
;;;;;_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);;            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
;;;;;_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);;            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += _const_mu.x + _const_mu.x;              avgmu += _const_mu.y + _const_mu.y;
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(_const_cm + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(_const_cm + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(!is_constant(mu.x) && !is_constant(rho) && is_constant(fm.x) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }              { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }
              

         {
            scalar s = u.x;   
            
            
                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);;;;;;            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);;;;;;            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);              avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(_const_cm + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(_const_cm + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(is_constant(mu.x) && !is_constant(rho) && is_constant(fm.x) && is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              {;;  }              {;;  }
              

         {
            scalar s = u.x;   
            
            
                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);;;;;;;;;;            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);;;;;;;;;;            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += _const_mu.x + _const_mu.x;              avgmu += _const_mu.y + _const_mu.y;
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(_const_cm + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(_const_cm + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else if(!is_constant(mu.x) && is_constant(rho) && is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }              { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }
              

         {
            scalar s = u.x;   
            
            
                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
;_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);;;;;;            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }                { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
;_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);;;;;;            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);              avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(_const_cm + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);                a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(_const_cm + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}else {_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  

    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 24 "./../my-viscosity-gcm-old.h"
{   
        
        
              {;;  }              {;;  }
              

         {
            scalar s = u.x;   
            
            
                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.x,0,0,0);
;;;;;;;;;;            
#line 35
_stencil_val_a(u.x,0,0,0);                       
                               
        } 
#line 30
{
            scalar s = u.y;   
            
            
                {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }                {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } 
_stencil_val(ibmCells,0,0,0); _stencil_val(r.y,0,0,0);
;;;;;;;;;;            
#line 35
_stencil_val_a(u.y,0,0,0);                       
                               
        }
    }
  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 746 "/home/spencer/basilisk/src/grid/tree.h"
{
  for (int _l1 = l; _l1 >= 0; _l1--) 
#line 22 "/home/spencer/basilisk/src/grid/config.h"
{ 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (_l1 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[_l1];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = _l1;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;
      
#line 749
if (_l1 == l || is_leaf (cell)) 
#line 24 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "./../my-viscosity-gcm-old.h"
{
        double avgmu = 0.;
        
              avgmu += _const_mu.x + _const_mu.x;              avgmu += _const_mu.y + _const_mu.y;
        avgmu = dt * avgmu + 1e-30;

         {
            scalar s = u.x;
            double a = 0.;
            
                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
            val(u.x,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.x,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(_const_cm + 1e-30)}).x) + avgmu);
        } 
#line 30
{
            scalar s = u.y;
            double a = 0.;
            
                a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);                a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
            val(u.y,0,0,0) = val(ibmCells,0,0,0)*(dt*a + val(r.y,0,0,0)*( Delta*Delta)) /
                               (( Delta*Delta) * (_const_rho + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(_const_cm + 1e-30)}).y) + avgmu);
        }
    }}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 22 "/home/spencer/basilisk/src/grid/config.h"
}

#line 751 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 38 "./../my-viscosity-gcm-old.h"
}
}

static double residual_diffusion (scalar * a, scalar * b, scalar * resl,
                                  void * data)
{
    struct Viscosity * p = (struct Viscosity *) data;
            vector mu = p->mu;
            scalar rho = p->rho;
    double dt = p->dt;
    vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0]))), res = (*((vector *)&(resl[0])));
    double maxres = 0.;

     {
        scalar s = u.x;
        vector  g=new_face_vector("g");

if(!is_constant(mu.x)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 55, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 55 "./../my-viscosity-gcm-old.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);            
#line 56 "./../my-viscosity-gcm-old.h"
{ _stencil_val(mu.x,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);_stencil_val_a(g.x,0,0,0);    } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);            
#line 56 "./../my-viscosity-gcm-old.h"
{ _stencil_val(mu.y,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);_stencil_val_a(g.y,0,0,0);    }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 55 "./../my-viscosity-gcm-old.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);            
#line 56 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-viscosity-gcm-old.h"
val(g.x,0,0,0) = val(mu.x,0,0,0) * ((val(s,0,0,0) - val(s,0 -1,0,0))/Delta);}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);            
#line 56 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-viscosity-gcm-old.h"
val(g.y,0,0,0) = val(mu.y,0,0,0) * ((val(s,0,0,0) - val(s,0,0 -1,0))/Delta);}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 56 "./../my-viscosity-gcm-old.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 56 "./../my-viscosity-gcm-old.h"
}else {_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 55, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 55 "./../my-viscosity-gcm-old.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);            
#line 56 "./../my-viscosity-gcm-old.h"
{;_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);_stencil_val_a(g.x,0,0,0);    } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);            
#line 56 "./../my-viscosity-gcm-old.h"
{;_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);_stencil_val_a(g.y,0,0,0);    }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 55 "./../my-viscosity-gcm-old.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);            
#line 56 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-viscosity-gcm-old.h"
val(g.x,0,0,0) = _const_mu.x * ((val(s,0,0,0) - val(s,0 -1,0,0))/Delta);}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);            
#line 56 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-viscosity-gcm-old.h"
val(g.y,0,0,0) = _const_mu.y * ((val(s,0,0,0) - val(s,0,0 -1,0))/Delta);}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 56 "./../my-viscosity-gcm-old.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 56 "./../my-viscosity-gcm-old.h"
}

        if(!is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);;_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);;;;;_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);;;;;;_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);;;;;_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);;_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);;;;;_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);;;;;;;;;_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);;;;;;;;;;_stencil_val(cm,0,0,0);_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(val(cm,0,0,0) + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);;_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(_const_cm + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && !is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);;_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);;_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(_const_cm + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);;;;;_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);;_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(_const_cm + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && is_constant(mu.x) && !is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);;;;;;_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);;_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(val(fm.x,0,0,0) + val(fm.x,1,0,0) + val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30)/(_const_cm + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);;;;;;_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(_const_cm + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && !is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);;_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);;;;;;_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0, dt*(val(mu.x,0,0,0) + val(mu.x,1,0,0) + val(mu.y,0,0,0) + val(mu.y,0,1,0)) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(_const_cm + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && is_constant(mu.x) && is_constant(fm.x) && is_constant(cm)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);;;;;;;;;;_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(_const_cm + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else {double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  }                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  } 
_stencil_val(r.x,0,0,0);;;;;;;;;;;_stencil_val(u.x,0,0,0);            _stencil_val_a(res.x,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.x,0,0,0);  }
_stencil_val(res.x,0,0,0);
                {_stencil_val(res.x,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.x,0,0,0) - val(g.x,1,0,0);                a += val(g.y,0,0,0) - val(g.y,0,1,0);
            val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0, dt*(_const_mu.x + _const_mu.x + _const_mu.y + _const_mu.y) /(_const_fm.x + _const_fm.x + _const_fm.y + _const_fm.y + 1e-30)/(_const_cm + 1e-30)}).x)*val(u.x,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.x,0,0,0) = 0;
            if (fabs (val(res.x,0,0,0)) > maxres)
                maxres = fabs (val(res.x,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
    } 
#line 51
{
        scalar s = u.y;
        vector  g=new_face_vector("g");

if(!is_constant(mu.y)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 55, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 55 "./../my-viscosity-gcm-old.h"
{ 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);            
#line 56 "./../my-viscosity-gcm-old.h"
{ _stencil_val(mu.y,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);_stencil_val_a(g.y,0,0,0);    } 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);            
#line 56 "./../my-viscosity-gcm-old.h"
{ _stencil_val(mu.x,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);_stencil_val_a(g.x,0,0,0);    }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 55 "./../my-viscosity-gcm-old.h"
{
  
#line 707 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);            
#line 56 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-viscosity-gcm-old.h"
val(g.y,0,0,0) = val(mu.y,0,0,0) * ((val(s,0,0,0) - val(s,0,0 -1,0))/Delta);}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}  
#line 699
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);            
#line 56 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-viscosity-gcm-old.h"
val(g.x,0,0,0) = val(mu.x,0,0,0) * ((val(s,0,0,0) - val(s,0 -1,0,0))/Delta);}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 56 "./../my-viscosity-gcm-old.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 56 "./../my-viscosity-gcm-old.h"
}else {_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 55, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 55 "./../my-viscosity-gcm-old.h"
{ 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);            
#line 56 "./../my-viscosity-gcm-old.h"
{;_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);_stencil_val_a(g.y,0,0,0);    } 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);            
#line 56 "./../my-viscosity-gcm-old.h"
{;_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);_stencil_val_a(g.x,0,0,0);    }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 55 "./../my-viscosity-gcm-old.h"
{
  
#line 707 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);            
#line 56 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-viscosity-gcm-old.h"
val(g.y,0,0,0) = _const_mu.y * ((val(s,0,0,0) - val(s,0,0 -1,0))/Delta);}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}  
#line 699
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);            
#line 56 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 56 "./../my-viscosity-gcm-old.h"
val(g.x,0,0,0) = _const_mu.x * ((val(s,0,0,0) - val(s,0 -1,0,0))/Delta);}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 56 "./../my-viscosity-gcm-old.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 56 "./../my-viscosity-gcm-old.h"
}

        if(!is_constant(rho) && !is_constant(mu.y) && !is_constant(fm.y) && !is_constant(cm)){
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && !is_constant(mu.y) && !is_constant(fm.y) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);;_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && is_constant(mu.y) && !is_constant(fm.y) && !is_constant(cm)){_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);;;;;_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && is_constant(mu.y) && !is_constant(fm.y) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);;;;;;_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && !is_constant(mu.y) && is_constant(fm.y) && !is_constant(cm)){_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);;;;;_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && !is_constant(mu.y) && is_constant(fm.y) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);;_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);;;;;_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && is_constant(mu.y) && is_constant(fm.y) && !is_constant(cm)){_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);;;;;;;;;_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && is_constant(mu.y) && is_constant(fm.y) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);;;;;;;;;;_stencil_val(cm,0,0,0);_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(val(cm,0,0,0) + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && !is_constant(mu.y) && !is_constant(fm.y) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);;_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(_const_cm + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && !is_constant(mu.y) && !is_constant(fm.y) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);;_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);;_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(_const_cm + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && is_constant(mu.y) && !is_constant(fm.y) && is_constant(cm)){_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);;;;;_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);;_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(_const_cm + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && is_constant(mu.y) && !is_constant(fm.y) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);;;;;;_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);;_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(val(fm.y,0,0,0) + val(fm.y,0,1,0) + val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30)/(_const_cm + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && !is_constant(mu.y) && is_constant(fm.y) && is_constant(cm)){_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);;;;;;_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(_const_cm + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(rho) && !is_constant(mu.y) && is_constant(fm.y) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);;_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);;;;;;_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0, dt*(val(mu.y,0,0,0) + val(mu.y,0,1,0) + val(mu.x,0,0,0) + val(mu.x,1,0,0)) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(_const_cm + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(rho) && is_constant(mu.y) && is_constant(fm.y) && is_constant(cm)){_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);;;;;;;;;;_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(_const_cm + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else {double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_mu={_constant[mu.y.i-_NVARMAX],_constant[mu.x.i-_NVARMAX]};NOT_UNUSED(_const_mu);_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 58, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 58 "./../my-viscosity-gcm-old.h"
{   
            
            
                { _stencil_val(g.y,0,0,0); _stencil_val(g.y,0,1,0);  }                { _stencil_val(g.x,0,0,0); _stencil_val(g.x,1,0,0);  } 
_stencil_val(r.y,0,0,0);;;;;;;;;;;_stencil_val(u.y,0,0,0);            _stencil_val_a(res.y,0,0,0);
_stencil_val(ibm,0,0,0);
                {_stencil_val_a(res.y,0,0,0);  }
_stencil_val(res.y,0,0,0);
                {_stencil_val(res.y,0,0,0);   }        
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 58 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 58 "./../my-viscosity-gcm-old.h"
{
            double a = 0.;
            
                a += val(g.y,0,0,0) - val(g.y,0,1,0);                a += val(g.x,0,0,0) - val(g.x,1,0,0);
            val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0, dt*(_const_mu.y + _const_mu.y + _const_mu.x + _const_mu.x) /(_const_fm.y + _const_fm.y + _const_fm.x + _const_fm.x + 1e-30)/(_const_cm + 1e-30)}).y)*val(u.y,0,0,0) - dt*a/Delta;
            if (val(ibm,0,0,0) <= 0.5)
                val(res.y,0,0,0) = 0;
            if (fabs (val(res.y,0,0,0)) > maxres)
                maxres = fabs (val(res.y,0,0,0));
        }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 67 "./../my-viscosity-gcm-old.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}delete((scalar*)((vector[]){g,{{-1},{-1}}}));
    }
#line 85 "./../my-viscosity-gcm-old.h"
    return maxres;
}



double TOLERANCE_MU = 0.;

     
mgstats viscosity (vector u, vector mu, scalar rho, double dt,
                   int nrelax, scalar * res)
{tracing("viscosity","./../my-viscosity-gcm-old.h",93);
    vector  r=new_vector("r");
    scalar  rho2=new_scalar("rho2");
    if(!is_constant(cm)){
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 98, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 98 "./../my-viscosity-gcm-old.h"
{ 
_stencil_val(rho,0,0,0);_stencil_val(cm,0,0,0);_stencil_val(ibm,0,0,0);        _stencil_val_a(rho2,0,0,0);   
         { 
_stencil_val(rho2,0,0,0); _stencil_val(u.x,0,0,0);            _stencil_val_a(r.x,0,0,0); 
        } 
#line 100
{ 
_stencil_val(rho2,0,0,0); _stencil_val(u.y,0,0,0);            _stencil_val_a(r.y,0,0,0); 
        }
    }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 98 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 98 "./../my-viscosity-gcm-old.h"
{
        val(rho2,0,0,0) = val(rho,0,0,0)*val(cm,0,0,0)/(val(ibm,0,0,0) + 1e-30);
         {
            val(r.x,0,0,0) = val(rho2,0,0,0)* val(u.x,0,0,0);
        } 
#line 100
{
            val(r.y,0,0,0) = val(rho2,0,0,0)* val(u.y,0,0,0);
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 103 "./../my-viscosity-gcm-old.h"
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-viscosity-gcm-old.h", .line = 98, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 98 "./../my-viscosity-gcm-old.h"
{ 
_stencil_val(rho,0,0,0);;_stencil_val(ibm,0,0,0);        _stencil_val_a(rho2,0,0,0);   
         { 
_stencil_val(rho2,0,0,0); _stencil_val(u.x,0,0,0);            _stencil_val_a(r.x,0,0,0); 
        } 
#line 100
{ 
_stencil_val(rho2,0,0,0); _stencil_val(u.y,0,0,0);            _stencil_val_a(r.y,0,0,0); 
        }
    }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 98 "./../my-viscosity-gcm-old.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 98 "./../my-viscosity-gcm-old.h"
{
        val(rho2,0,0,0) = val(rho,0,0,0)*_const_cm/(val(ibm,0,0,0) + 1e-30);
         {
            val(r.x,0,0,0) = val(rho2,0,0,0)* val(u.x,0,0,0);
        } 
#line 100
{
            val(r.y,0,0,0) = val(rho2,0,0,0)* val(u.y,0,0,0);
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 103 "./../my-viscosity-gcm-old.h"
}

    restriction (((scalar[]){mu.x,mu.y, rho2, ibmCells, fm.x, fm.y, cm, ibm,{-1}}));
    struct Viscosity p = { mu, rho2, dt };
    { mgstats _ret= mg_solve ((scalar *)((vector[]){u,{{-1},{-1}}}), (scalar *)((vector[]){r,{{-1},{-1}}})
,                     residual_diffusion, relax_diffusion, &p
,                     nrelax, res, 1
, TOLERANCE_MU ? TOLERANCE_MU : TOLERANCE);delete((scalar*)((scalar[]){rho2,r.x,r.y,{-1}}));{end_tracing("viscosity","./../my-viscosity-gcm-old.h",110);return _ret;}}delete((scalar*)((scalar[]){rho2,r.x,r.y,{-1}}));

end_tracing("viscosity","./../my-viscosity-gcm-old.h",112);}
#line 37 "./../my-centered.h"
#line 50 "./../my-centered.h"
scalar  p={11};
vector  u={{12},{13}},  g={{14},{15}};
scalar  pf={16};
vector  uf={{17},{18}};
#line 76 "./../my-centered.h"
        vector mu = {{_NVARMAX+3},{_NVARMAX+4}}, a = {{_NVARMAX+3},{_NVARMAX+4}}, alpha = {{_NVARMAX+5},{_NVARMAX+6}};
        scalar rho = {_NVARMAX+7};
mgstats mgp = {0}, mgpf = {0}, mgu = {0};
bool stokes = false;
#line 100
static double _boundary8(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary8_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 100 "./../my-centered.h"
{return( ( data ? ((bool *)data)[0] = false, 0 : val(_s,0,0,0)));}}}
static double _boundary9(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, (- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary9_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 101 "./../my-centered.h"
{return( ( data ? ((bool *)data)[0] = false, 0 : val(_s,0,0,0)));}}}


static double _boundary10(Point point,Point neighbor,scalar _s,bool *data){{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 104 "./../my-centered.h"
{return( 0.);}}}
static double _boundary11(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 105 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 105 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, 0 : 2.*0 - val(_s,0,0,0)));}}}static double _boundary11_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 105 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 105 "./../my-centered.h"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}

static double _boundary12(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, ((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary12_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 107 "./../my-centered.h"
{return( ( data ? ((bool *)data)[0] = false, 0 : val(_s,0,0,0)));}}}
#line 133 "./../my-centered.h"
void pressure_ibm_gradient (Point point, scalar p, coord * g)
{if(!is_constant(rho) && !is_constant(cm) && !is_constant(a.x)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 136 "./../my-centered.h"
g->x = val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30)*(val(a.x,0,0,0) + val(a.x,1,0,0))/2.;    g->y = val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30)*(val(a.y,0,0,0) + val(a.y,0,1,0))/2.;
}}else if(is_constant(rho) && !is_constant(cm) && !is_constant(a.x)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
#line 134
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 136 "./../my-centered.h"
g->x = _const_rho/(val(cm,0,0,0) + 1e-30)*(val(a.x,0,0,0) + val(a.x,1,0,0))/2.;    g->y = _const_rho/(val(cm,0,0,0) + 1e-30)*(val(a.y,0,0,0) + val(a.y,0,1,0))/2.;
}}else if(!is_constant(rho) && is_constant(cm) && !is_constant(a.x)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
#line 134
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 136 "./../my-centered.h"
g->x = val(rho,0,0,0)/(_const_cm + 1e-30)*(val(a.x,0,0,0) + val(a.x,1,0,0))/2.;    g->y = val(rho,0,0,0)/(_const_cm + 1e-30)*(val(a.y,0,0,0) + val(a.y,0,1,0))/2.;
}}else if(is_constant(rho) && is_constant(cm) && !is_constant(a.x)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
#line 134
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 136 "./../my-centered.h"
g->x = _const_rho/(_const_cm + 1e-30)*(val(a.x,0,0,0) + val(a.x,1,0,0))/2.;    g->y = _const_rho/(_const_cm + 1e-30)*(val(a.y,0,0,0) + val(a.y,0,1,0))/2.;
}}else if(!is_constant(rho) && !is_constant(cm) && is_constant(a.x)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
#line 134
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 136 "./../my-centered.h"
g->x = val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30)*(_const_a.x + _const_a.x)/2.;    g->y = val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30)*(_const_a.y + _const_a.y)/2.;
}}else if(is_constant(rho) && !is_constant(cm) && is_constant(a.x)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
#line 134
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 136 "./../my-centered.h"
g->x = _const_rho/(val(cm,0,0,0) + 1e-30)*(_const_a.x + _const_a.x)/2.;    g->y = _const_rho/(val(cm,0,0,0) + 1e-30)*(_const_a.y + _const_a.y)/2.;
}}else if(!is_constant(rho) && is_constant(cm) && is_constant(a.x)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
#line 134
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 136 "./../my-centered.h"
g->x = val(rho,0,0,0)/(_const_cm + 1e-30)*(_const_a.x + _const_a.x)/2.;    g->y = val(rho,0,0,0)/(_const_cm + 1e-30)*(_const_a.y + _const_a.y)/2.;
}}else {double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
#line 134
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 136 "./../my-centered.h"
g->x = _const_rho/(_const_cm + 1e-30)*(_const_a.x + _const_a.x)/2.;    g->y = _const_rho/(_const_cm + 1e-30)*(_const_a.y + _const_a.y)/2.;
}}}





static int defaults_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int defaults_0(const int i,const double t,Event *_ev){tracing("defaults_0","./../my-centered.h",143);
{

  CFL = 0.8;




  _attribute[p.i].nodump = _attribute[pf.i].nodump = true;





  if (alpha.x.i == unityf.x.i) {

    alpha = ibmf;
    rho = ibm;




  }
  else if (!is_constant(alpha.x)) {
    vector alphav = alpha;
if(!is_constant(fm.x)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 168, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 168 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);      
#line 169 "./../my-centered.h"
{ _stencil_val(fm.x,0,0,0);_stencil_val_a(alphav.x,0,0,0); } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);      
#line 169 "./../my-centered.h"
{ _stencil_val(fm.y,0,0,0);_stencil_val_a(alphav.y,0,0,0); }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 168 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);      
#line 169 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 169 "./../my-centered.h"
val(alphav.x,0,0,0) = val(fm.x,0,0,0);}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);      
#line 169 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 169 "./../my-centered.h"
val(alphav.y,0,0,0) = val(fm.y,0,0,0);}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 169 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 169 "./../my-centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 168, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 168 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);      
#line 169 "./../my-centered.h"
{;_stencil_val_a(alphav.x,0,0,0); } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);      
#line 169 "./../my-centered.h"
{;_stencil_val_a(alphav.y,0,0,0); }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 168 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);      
#line 169 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 169 "./../my-centered.h"
val(alphav.x,0,0,0) = _const_fm.x;}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);      
#line 169 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 169 "./../my-centered.h"
val(alphav.y,0,0,0) = _const_fm.y;}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 169 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 169 "./../my-centered.h"
}
  }






  _attribute[uf.x.i].refine = refine_face_solenoidal;
#line 195 "./../my-centered.h"
  _attribute[uf.x.i].refine = refine_face;
   {

    _attribute[uf.x.i].prolongation = refine_ibm_face_x;
  } 
#line 196
{

    _attribute[uf.y.i].prolongation = refine_ibm_face_y;
  }
  {scalar*_i=(scalar*)(((scalar[]) {p, pf, u.x, u.y, g.x, g.y,{-1}}));if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].restriction = restriction_ibm_linear;
    _attribute[s.i].refine = _attribute[s.i].prolongation = refine_ibm_linear;
    _attribute[s.i].depends = list_add (_attribute[s.i].depends, ibm);
  }}}
  {scalar*_i=(scalar*)(((scalar[]) {p, pf,{-1}}));if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].ibm_gradient = pressure_ibm_gradient;}}
  






  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 213, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 214 "./../my-centered.h"
{
      {_stencil_val(u.x,0,0,0);   }      {_stencil_val(u.y,0,0,0);   }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 214 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 214 "./../my-centered.h"
{
      dimensional (val(u.x,0,0,0) == Delta/t);      dimensional (val(u.y,0,0,0) == Delta/t);}}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 216 "./../my-centered.h"
}{end_tracing("defaults_0","./../my-centered.h",216);return 0;}end_tracing("defaults_0","./../my-centered.h",216);}





static int default_display_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int default_display(const int i,const double t,Event *_ev){tracing("default_display","./../my-centered.h",222);
{display ("squares (color = 'u.x', spread = -1);"
#line 494 "/home/spencer/basilisk/src/common.h"
, false
#line 223 "./../my-centered.h"
);  }{end_tracing("default_display","./../my-centered.h",223);return 0;}end_tracing("default_display","./../my-centered.h",223);}





double dtmax;

static int init_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int init(const int i,const double t,Event *_ev){tracing("init","./../my-centered.h",231);
{
  trash (((vector[]){uf,{{-1},{-1}}}));
if(!is_constant(fm.x)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 234, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 234 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 235 "./../my-centered.h"
{ _stencil_val(fm.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_ibm_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val_a(uf.x,0,0,0);                 } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 235 "./../my-centered.h"
{ _stencil_val(fm.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_ibm_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(ibm,0,0 -1,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0 -1,0);_stencil_val_a(uf.y,0,0,0);                 }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 234 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 235 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 235 "./../my-centered.h"
val(uf.x,0,0,0) = val(fm.x,0,0,0)*(true && val(ibmf.x,0,0,0) < 1. && val(ibmf.x,0,0,0) > 0. ? ibm_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(ibm,0 -1,0,0)))/ (val(ibm,0,0,0) + val(ibm,0 -1,0,0) + 3.)));}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 235 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 235 "./../my-centered.h"
val(uf.y,0,0,0) = val(fm.y,0,0,0)*(true && val(ibmf.y,0,0,0) < 1. && val(ibmf.y,0,0,0) > 0. ? ibm_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(ibm,0,0 -1,0)))/ (val(ibm,0,0,0) + val(ibm,0,0 -1,0) + 3.)));}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 235 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 235 "./../my-centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 234, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 234 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 235 "./../my-centered.h"
{; _stencil_val(ibmf.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_ibm_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val_a(uf.x,0,0,0);                 } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 235 "./../my-centered.h"
{; _stencil_val(ibmf.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_ibm_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(ibm,0,0 -1,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0 -1,0);_stencil_val_a(uf.y,0,0,0);                 }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 234 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 235 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 235 "./../my-centered.h"
val(uf.x,0,0,0) = _const_fm.x*(true && val(ibmf.x,0,0,0) < 1. && val(ibmf.x,0,0,0) > 0. ? ibm_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(ibm,0 -1,0,0)))/ (val(ibm,0,0,0) + val(ibm,0 -1,0,0) + 3.)));}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 235 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 235 "./../my-centered.h"
val(uf.y,0,0,0) = _const_fm.y*(true && val(ibmf.y,0,0,0) < 1. && val(ibmf.y,0,0,0) > 0. ? ibm_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(ibm,0,0 -1,0)))/ (val(ibm,0,0,0) + val(ibm,0,0 -1,0) + 3.)));}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 235 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 235 "./../my-centered.h"
}




  event ("properties");





  dtmax = DT;
  event ("stability");
}{end_tracing("init","./../my-centered.h",248);return 0;}end_tracing("init","./../my-centered.h",248);}








static int set_dtmax_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 257 "./../my-centered.h"
      static int set_dtmax(const int i,const double t,Event *_ev){tracing("set_dtmax","./../my-centered.h",257);{dtmax = DT; }{end_tracing("set_dtmax","./../my-centered.h",257);return 0;}end_tracing("set_dtmax","./../my-centered.h",257);}

static int stability_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int stability(const int i,const double t,Event *_ev){tracing("stability","./../my-centered.h",259); {
  dt = dtnext (stokes ? dtmax : timestep (uf, dtmax));
}{end_tracing("stability","./../my-centered.h",261);return 0;}end_tracing("stability","./../my-centered.h",261);}







static int vof_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int vof(const int i,const double t,Event *_ev){;return 0;}
static int tracer_advection_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int tracer_advection(const int i,const double t,Event *_ev){;return 0;}
static int tracer_diffusion_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int tracer_diffusion(const int i,const double t,Event *_ev){;return 0;}






static int properties_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int properties(const int i,const double t,Event *_ev){;return 0;}
#line 290 "./../my-centered.h"
void prediction()
{
  vector du;
   {
    scalar s = new_scalar("s");
    du.x = s;
  } 
#line 293
{
    scalar s = new_scalar("s");
    du.y = s;
  }

  if (_attribute[u.x.i].gradient)
    {
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 299, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 300 "./../my-centered.h"
{ {





_stencil_val(ibmf.x,0,0,0);_stencil_val(ibmf.x,1,0,0);{
     {_stencil_val_a(du.x,0,0,0);  }

   
{_stencil_val(u.x,-1,0,0); _stencil_val(u.x,0,0,0); _stencil_val(u.x,1,0,0);_stencil_val_a(du.x,0,0,0);   }}      
} 
#line 300
{





_stencil_val(ibmf.y,0,0,0);_stencil_val(ibmf.y,0,1,0);{
     {_stencil_val_a(du.y,0,0,0);  }

   
{_stencil_val(u.y,0,-1,0); _stencil_val(u.y,0,0,0); _stencil_val(u.y,0,1,0);_stencil_val_a(du.y,0,0,0);   }}      
}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;      
#line 300 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 300 "./../my-centered.h"
{ {





    if (!val(ibmf.x,0,0,0) && !val(ibmf.x,1,0,0))
     val(du.x,0,0,0) = 0.;
 else

   val(du.x,0,0,0) = _attribute[u.x.i].gradient (val(u.x,-1,0,0), val(u.x,0,0,0), val(u.x,1,0,0))/Delta;
      } 
#line 300
{





    if (!val(ibmf.y,0,0,0) && !val(ibmf.y,0,1,0))
     val(du.y,0,0,0) = 0.;
 else

   val(du.y,0,0,0) = _attribute[u.y.i].gradient (val(u.y,0,-1,0), val(u.y,0,0,0), val(u.y,0,1,0))/Delta;
      }}}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 311 "./../my-centered.h"
}
  else
    {    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 313, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 314 "./../my-centered.h"
{ {





_stencil_val(ibmf.x,0,0,0);_stencil_val(ibmf.x,1,0,0);{
   {_stencil_val_a(du.x,0,0,0);  }

   
{_stencil_val(u.x,1,0,0); _stencil_val(u.x,-1,0,0);_stencil_val_a(du.x,0,0,0);   }}    
} 
#line 314
{





_stencil_val(ibmf.y,0,0,0);_stencil_val(ibmf.y,0,1,0);{
   {_stencil_val_a(du.y,0,0,0);  }

   
{_stencil_val(u.y,0,1,0); _stencil_val(u.y,0,-1,0);_stencil_val_a(du.y,0,0,0);   }}    
}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;      
#line 314 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 314 "./../my-centered.h"
{ {





        if (!val(ibmf.x,0,0,0) && !val(ibmf.x,1,0,0))
   val(du.x,0,0,0) = 0.;
 else

   val(du.x,0,0,0) = (val(u.x,1,0,0) - val(u.x,-1,0,0))/(2.*Delta);
    } 
#line 314
{





        if (!val(ibmf.y,0,0,0) && !val(ibmf.y,0,1,0))
   val(du.y,0,0,0) = 0.;
 else

   val(du.y,0,0,0) = (val(u.y,0,1,0) - val(u.y,0,-1,0))/(2.*Delta);
    }}}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 325 "./../my-centered.h"
}

  trash (((vector[]){uf,{{-1},{-1}}}));
if(!is_constant(fm.x)){  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 328, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 328 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 328 "./../my-centered.h"
{              
     _stencil_val(u.x,-1,0,0);_stencil_val(u.x,0,0,0);     
    
_stencil_val(u.x, o_stencil,0,0);_stencil_val(g.x,0,0,0); _stencil_val(g.x,-1,0,0);_stencil_val(du.x,o_stencil,0,0);    _stencil_val_a(uf.x,0,0,0);

_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {        
       _stencil_val(u.x,o_stencil,-1,0);_stencil_val(u.x, o_stencil,0,0);_stencil_val(u.x, o_stencil,0,0); _stencil_val(u.x,o_stencil,1,0);_stencil_val(u.y, o_stencil,0,0);
_stencil_val(u.y,o_stencil,0,0);      _stencil_val_r(uf.x,0,0,0);  
    } 







_stencil_val(fm.x,0,0,0);    _stencil_val_r(uf.x,0,0,0); 


  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 328 "./../my-centered.h"
{              
     _stencil_val(u.y,0,-1,0);_stencil_val(u.y,0,0,0);     
    
_stencil_val(u.y,0, o_stencil,0);_stencil_val(g.y,0,0,0); _stencil_val(g.y,0,-1,0);_stencil_val(du.y,0,o_stencil,0);    _stencil_val_a(uf.y,0,0,0);

_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {        
       _stencil_val(u.y,-1,o_stencil,0);_stencil_val(u.y,0, o_stencil,0);_stencil_val(u.y,0, o_stencil,0); _stencil_val(u.y,1,o_stencil,0);_stencil_val(u.x,0, o_stencil,0);
_stencil_val(u.x,0,o_stencil,0);      _stencil_val_r(uf.y,0,0,0);  
    } 







_stencil_val(fm.y,0,0,0);    _stencil_val_r(uf.y,0,0,0); 


  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 328 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 328 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 328 "./../my-centered.h"
{
    double un = dt*(val(u.x,0,0,0) + val(u.x,-1,0,0))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.x,0,0,0) = val(u.x,i,0,0) + (val(g.x,0,0,0) + val(g.x,-1,0,0))*dt/4. + s*(1. - s*un)*val(du.x,i,0,0)*Delta/2.;

    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double fyy = val(u.y,i,0,0) < 0. ? val(u.x,i,1,0) - val(u.x,i,0,0) : val(u.x,i,0,0) - val(u.x,i,-1,0);
      val(uf.x,0,0,0) -= dt*val(u.y,i,0,0)*fyy/(2.*Delta);
    }







    val(uf.x,0,0,0) *= val(fm.x,0,0,0);


  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 328 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 328 "./../my-centered.h"
{
    double un = dt*(val(u.y,0,0,0) + val(u.y,0,-1,0))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.y,0,0,0) = val(u.y,0,i,0) + (val(g.y,0,0,0) + val(g.y,0,-1,0))*dt/4. + s*(1. - s*un)*val(du.y,0,i,0)*Delta/2.;

    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double fyy = val(u.x,0,i,0) < 0. ? val(u.y,1,i,0) - val(u.y,0,i,0) : val(u.y,0,i,0) - val(u.y,-1,i,0);
      val(uf.y,0,0,0) -= dt*val(u.x,0,i,0)*fyy/(2.*Delta);
    }







    val(uf.y,0,0,0) *= val(fm.y,0,0,0);


  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 347 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 347 "./../my-centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 328, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 328 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 328 "./../my-centered.h"
{              
     _stencil_val(u.x,-1,0,0);_stencil_val(u.x,0,0,0);     
    
_stencil_val(u.x, o_stencil,0,0);_stencil_val(g.x,0,0,0); _stencil_val(g.x,-1,0,0);_stencil_val(du.x,o_stencil,0,0);    _stencil_val_a(uf.x,0,0,0);

;; {        
       _stencil_val(u.x,o_stencil,-1,0);_stencil_val(u.x, o_stencil,0,0);_stencil_val(u.x, o_stencil,0,0); _stencil_val(u.x,o_stencil,1,0);_stencil_val(u.y, o_stencil,0,0);
_stencil_val(u.y,o_stencil,0,0);      _stencil_val_r(uf.x,0,0,0);  
    }







;    _stencil_val_r(uf.x,0,0,0); 


  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 328 "./../my-centered.h"
{              
     _stencil_val(u.y,0,-1,0);_stencil_val(u.y,0,0,0);     
    
_stencil_val(u.y,0, o_stencil,0);_stencil_val(g.y,0,0,0); _stencil_val(g.y,0,-1,0);_stencil_val(du.y,0,o_stencil,0);    _stencil_val_a(uf.y,0,0,0);

;; {        
       _stencil_val(u.y,-1,o_stencil,0);_stencil_val(u.y,0, o_stencil,0);_stencil_val(u.y,0, o_stencil,0); _stencil_val(u.y,1,o_stencil,0);_stencil_val(u.x,0, o_stencil,0);
_stencil_val(u.x,0,o_stencil,0);      _stencil_val_r(uf.y,0,0,0);  
    }







;    _stencil_val_r(uf.y,0,0,0); 


  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 328 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 328 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 328 "./../my-centered.h"
{
    double un = dt*(val(u.x,0,0,0) + val(u.x,-1,0,0))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.x,0,0,0) = val(u.x,i,0,0) + (val(g.x,0,0,0) + val(g.x,-1,0,0))*dt/4. + s*(1. - s*un)*val(du.x,i,0,0)*Delta/2.;

    if (_const_fm.y && _const_fm.y) {
      double fyy = val(u.y,i,0,0) < 0. ? val(u.x,i,1,0) - val(u.x,i,0,0) : val(u.x,i,0,0) - val(u.x,i,-1,0);
      val(uf.x,0,0,0) -= dt*val(u.y,i,0,0)*fyy/(2.*Delta);
    }







    val(uf.x,0,0,0) *= _const_fm.x;


  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 328 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 328 "./../my-centered.h"
{
    double un = dt*(val(u.y,0,0,0) + val(u.y,0,-1,0))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.y,0,0,0) = val(u.y,0,i,0) + (val(g.y,0,0,0) + val(g.y,0,-1,0))*dt/4. + s*(1. - s*un)*val(du.y,0,i,0)*Delta/2.;

    if (_const_fm.x && _const_fm.x) {
      double fyy = val(u.x,0,i,0) < 0. ? val(u.y,1,i,0) - val(u.y,0,i,0) : val(u.y,0,i,0) - val(u.y,-1,i,0);
      val(uf.y,0,0,0) -= dt*val(u.x,0,i,0)*fyy/(2.*Delta);
    }







    val(uf.y,0,0,0) *= _const_fm.y;


  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 347 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 347 "./../my-centered.h"
}

  delete ((scalar *)((vector[]){du,{{-1},{-1}}}));
}
#line 361
static int advection_term_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 361 "./../my-centered.h"
      static int advection_term(const int i,const double t,Event *_ev){tracing("advection_term","./../my-centered.h",361);
{

  if (!stokes) {
    prediction();
    mgpf = project (uf, pf, alpha, dt/2., mgpf.nrelax);
    advection ((scalar *)((vector[]){u,{{-1},{-1}}}), uf, dt, (scalar *)((vector[]){g,{{-1},{-1}}}));
  }
}{end_tracing("advection_term","./../my-centered.h",369);return 0;}end_tracing("advection_term","./../my-centered.h",369);}
#line 378 "./../my-centered.h"
static void correction (double dt)
{  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 380, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 381 "./../my-centered.h"
{

      { _stencil_val(ibmCells,0,0,0);_stencil_val(g.x,0,0,0);_stencil_val_r(u.x,0,0,0); }      { _stencil_val(ibmCells,0,0,0);_stencil_val(g.y,0,0,0);_stencil_val_r(u.y,0,0,0); }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 381 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 381 "./../my-centered.h"
{

      val(u.x,0,0,0) += val(ibmCells,0,0,0)*dt*val(g.x,0,0,0);      val(u.y,0,0,0) += val(ibmCells,0,0,0)*dt*val(g.y,0,0,0);}}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 387 "./../my-centered.h"
}








static int viscous_term_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 396 "./../my-centered.h"
      static int viscous_term(const int i,const double t,Event *_ev){tracing("viscous_term","./../my-centered.h",396);
{
  if (constant(mu.x) != 0.) {
    correction (dt);
    mgu = viscosity (u, mu, rho, dt, mgu.nrelax
#line 94 "./../my-viscosity-gcm-old.h"
, NULL
#line 400 "./../my-centered.h"
);
    correction (-dt);
  }




  if (!is_constant(a.x)) {
    vector af = a;
    trash (((vector[]){af,{{-1},{-1}}}));  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
      
#line 411 "./../my-centered.h"
{_stencil_val_a(af.x,0,0,0);  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
      
#line 411 "./../my-centered.h"
{_stencil_val_a(af.y,0,0,0);  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 410 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);      
#line 411 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 411 "./../my-centered.h"
val(af.x,0,0,0) = 0.;}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);      
#line 411 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 411 "./../my-centered.h"
val(af.y,0,0,0) = 0.;}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 411 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}  
#line 412 "./../my-centered.h"
}
}{end_tracing("viscous_term","./../my-centered.h",413);return 0;}end_tracing("viscous_term","./../my-centered.h",413);}
#line 433
static int acceleration_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 433 "./../my-centered.h"
      static int acceleration(const int i,const double t,Event *_ev){tracing("acceleration","./../my-centered.h",433);
{
  trash (((vector[]){uf,{{-1},{-1}}}));
if(!is_constant(fm.x) && !is_constant(a.x)){  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 436, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 436 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 436 "./../my-centered.h"
{ 
_stencil_val(fm.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_ibm_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val(a.x,0,0,0);    _stencil_val_a(uf.x,0,0,0);                   
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 436 "./../my-centered.h"
{ 
_stencil_val(fm.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_ibm_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(ibm,0,0 -1,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0 -1,0);_stencil_val(a.y,0,0,0);    _stencil_val_a(uf.y,0,0,0);                   
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 436 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 436 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 436 "./../my-centered.h"
{
    val(uf.x,0,0,0) = val(fm.x,0,0,0)*((true && val(ibmf.x,0,0,0) < 1. && val(ibmf.x,0,0,0) > 0. ? ibm_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(ibm,0 -1,0,0)))/ (val(ibm,0,0,0) + val(ibm,0 -1,0,0) + 3.))) + dt*val(a.x,0,0,0));
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 436 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 436 "./../my-centered.h"
{
    val(uf.y,0,0,0) = val(fm.y,0,0,0)*((true && val(ibmf.y,0,0,0) < 1. && val(ibmf.y,0,0,0) > 0. ? ibm_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(ibm,0,0 -1,0)))/ (val(ibm,0,0,0) + val(ibm,0,0 -1,0) + 3.))) + dt*val(a.y,0,0,0));
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 438 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 438 "./../my-centered.h"
}else if(is_constant(fm.x) && !is_constant(a.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 436, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 436 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 436 "./../my-centered.h"
{
; _stencil_val(ibmf.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_ibm_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val(a.x,0,0,0);    _stencil_val_a(uf.x,0,0,0);                   
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 436 "./../my-centered.h"
{
; _stencil_val(ibmf.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_ibm_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(ibm,0,0 -1,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0 -1,0);_stencil_val(a.y,0,0,0);    _stencil_val_a(uf.y,0,0,0);                   
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 436 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 436 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 436 "./../my-centered.h"
{
    val(uf.x,0,0,0) = _const_fm.x*((true && val(ibmf.x,0,0,0) < 1. && val(ibmf.x,0,0,0) > 0. ? ibm_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(ibm,0 -1,0,0)))/ (val(ibm,0,0,0) + val(ibm,0 -1,0,0) + 3.))) + dt*val(a.x,0,0,0));
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 436 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 436 "./../my-centered.h"
{
    val(uf.y,0,0,0) = _const_fm.y*((true && val(ibmf.y,0,0,0) < 1. && val(ibmf.y,0,0,0) > 0. ? ibm_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(ibm,0,0 -1,0)))/ (val(ibm,0,0,0) + val(ibm,0,0 -1,0) + 3.))) + dt*val(a.y,0,0,0));
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 438 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 438 "./../my-centered.h"
}else if(!is_constant(fm.x) && is_constant(a.x)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 436, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 436 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 436 "./../my-centered.h"
{ 
_stencil_val(fm.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_ibm_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0 -1,0,0);;    _stencil_val_a(uf.x,0,0,0);                   
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 436 "./../my-centered.h"
{ 
_stencil_val(fm.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_ibm_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(ibm,0,0 -1,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0 -1,0);;    _stencil_val_a(uf.y,0,0,0);                   
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 436 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 436 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 436 "./../my-centered.h"
{
    val(uf.x,0,0,0) = val(fm.x,0,0,0)*((true && val(ibmf.x,0,0,0) < 1. && val(ibmf.x,0,0,0) > 0. ? ibm_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(ibm,0 -1,0,0)))/ (val(ibm,0,0,0) + val(ibm,0 -1,0,0) + 3.))) + dt*_const_a.x);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 436 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 436 "./../my-centered.h"
{
    val(uf.y,0,0,0) = val(fm.y,0,0,0)*((true && val(ibmf.y,0,0,0) < 1. && val(ibmf.y,0,0,0) > 0. ? ibm_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(ibm,0,0 -1,0)))/ (val(ibm,0,0,0) + val(ibm,0,0 -1,0) + 3.))) + dt*_const_a.y);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 438 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 438 "./../my-centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 436, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 436 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 436 "./../my-centered.h"
{
; _stencil_val(ibmf.x,0,0,0); _stencil_val(ibmf.x,0,0,0); _stencil_ibm_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(ibm,0 -1,0,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0 -1,0,0);;    _stencil_val_a(uf.x,0,0,0);                   
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 436 "./../my-centered.h"
{
; _stencil_val(ibmf.y,0,0,0); _stencil_val(ibmf.y,0,0,0); _stencil_ibm_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(ibm,0,0 -1,0);_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0 -1,0);;    _stencil_val_a(uf.y,0,0,0);                   
  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 436 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 436 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 436 "./../my-centered.h"
{
    val(uf.x,0,0,0) = _const_fm.x*((true && val(ibmf.x,0,0,0) < 1. && val(ibmf.x,0,0,0) > 0. ? ibm_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(ibm,0 -1,0,0)))/ (val(ibm,0,0,0) + val(ibm,0 -1,0,0) + 3.))) + dt*_const_a.x);
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 436 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 436 "./../my-centered.h"
{
    val(uf.y,0,0,0) = _const_fm.y*((true && val(ibmf.y,0,0,0) < 1. && val(ibmf.y,0,0,0) > 0. ? ibm_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(ibm,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(ibm,0,0 -1,0)))/ (val(ibm,0,0,0) + val(ibm,0,0 -1,0) + 3.))) + dt*_const_a.y);
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 438 "./../my-centered.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 438 "./../my-centered.h"
}
}{end_tracing("acceleration","./../my-centered.h",439);return 0;}end_tracing("acceleration","./../my-centered.h",439);}
#line 448 "./../my-centered.h"
void centered_gradient (scalar p, vector g)
{





  vector  gf=new_face_vector("gf");
if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x)){  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 456 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 456 "./../my-centered.h"
{ 

_stencil_val(fm.x,0,0,0);_stencil_val(ibmf.x,0,0,0);_stencil_val(a.x,0,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);    _stencil_val_a(gf.x,0,0,0);   



  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 456 "./../my-centered.h"
{ 

_stencil_val(fm.y,0,0,0);_stencil_val(ibmf.y,0,0,0);_stencil_val(a.y,0,0,0); _stencil_val(fm.y,0,0,0);_stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);    _stencil_val_a(gf.y,0,0,0);   



  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 456 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.x,0,0,0) = val(fm.x,0,0,0)*val(ibmf.x,0,0,0)*val(a.x,0,0,0) - val(fm.x,0,0,0)*val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;



  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.y,0,0,0) = val(fm.y,0,0,0)*val(ibmf.y,0,0,0)*val(a.y,0,0,0) - val(fm.y,0,0,0)*val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;



  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 462 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 462 "./../my-centered.h"
}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 456 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 456 "./../my-centered.h"
{

;_stencil_val(ibmf.x,0,0,0);_stencil_val(a.x,0,0,0);;_stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);    _stencil_val_a(gf.x,0,0,0);   



  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 456 "./../my-centered.h"
{

;_stencil_val(ibmf.y,0,0,0);_stencil_val(a.y,0,0,0);;_stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);    _stencil_val_a(gf.y,0,0,0);   



  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 456 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.x,0,0,0) = _const_fm.x*val(ibmf.x,0,0,0)*val(a.x,0,0,0) - _const_fm.x*val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;



  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.y,0,0,0) = _const_fm.y*val(ibmf.y,0,0,0)*val(a.y,0,0,0) - _const_fm.y*val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;



  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 462 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 462 "./../my-centered.h"
}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 456 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 456 "./../my-centered.h"
{ 

_stencil_val(fm.x,0,0,0);_stencil_val(ibmf.x,0,0,0);; _stencil_val(fm.x,0,0,0);_stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);    _stencil_val_a(gf.x,0,0,0);   



  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 456 "./../my-centered.h"
{ 

_stencil_val(fm.y,0,0,0);_stencil_val(ibmf.y,0,0,0);; _stencil_val(fm.y,0,0,0);_stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);    _stencil_val_a(gf.y,0,0,0);   



  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 456 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.x,0,0,0) = val(fm.x,0,0,0)*val(ibmf.x,0,0,0)*_const_a.x - val(fm.x,0,0,0)*val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;



  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.y,0,0,0) = val(fm.y,0,0,0)*val(ibmf.y,0,0,0)*_const_a.y - val(fm.y,0,0,0)*val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;



  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 462 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 462 "./../my-centered.h"
}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 456 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 456 "./../my-centered.h"
{

;_stencil_val(ibmf.x,0,0,0);;;_stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);    _stencil_val_a(gf.x,0,0,0);   



  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 456 "./../my-centered.h"
{

;_stencil_val(ibmf.y,0,0,0);;;_stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);    _stencil_val_a(gf.y,0,0,0);   



  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 456 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.x,0,0,0) = _const_fm.x*val(ibmf.x,0,0,0)*_const_a.x - _const_fm.x*val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;



  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.y,0,0,0) = _const_fm.y*val(ibmf.y,0,0,0)*_const_a.y - _const_fm.y*val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;



  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 462 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 462 "./../my-centered.h"
}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 456 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 456 "./../my-centered.h"
{ 

_stencil_val(fm.x,0,0,0);_stencil_val(ibmf.x,0,0,0);_stencil_val(a.x,0,0,0); _stencil_val(fm.x,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);    _stencil_val_a(gf.x,0,0,0);   



  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 456 "./../my-centered.h"
{ 

_stencil_val(fm.y,0,0,0);_stencil_val(ibmf.y,0,0,0);_stencil_val(a.y,0,0,0); _stencil_val(fm.y,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);    _stencil_val_a(gf.y,0,0,0);   



  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 456 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.x,0,0,0) = val(fm.x,0,0,0)*val(ibmf.x,0,0,0)*val(a.x,0,0,0) - val(fm.x,0,0,0)*_const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;



  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.y,0,0,0) = val(fm.y,0,0,0)*val(ibmf.y,0,0,0)*val(a.y,0,0,0) - val(fm.y,0,0,0)*_const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;



  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 462 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 462 "./../my-centered.h"
}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 456 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 456 "./../my-centered.h"
{

;_stencil_val(ibmf.x,0,0,0);_stencil_val(a.x,0,0,0);;;_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);    _stencil_val_a(gf.x,0,0,0);   



  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 456 "./../my-centered.h"
{

;_stencil_val(ibmf.y,0,0,0);_stencil_val(a.y,0,0,0);;;_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);    _stencil_val_a(gf.y,0,0,0);   



  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 456 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.x,0,0,0) = _const_fm.x*val(ibmf.x,0,0,0)*val(a.x,0,0,0) - _const_fm.x*_const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;



  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.y,0,0,0) = _const_fm.y*val(ibmf.y,0,0,0)*val(a.y,0,0,0) - _const_fm.y*_const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;



  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 462 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 462 "./../my-centered.h"
}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 456 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 456 "./../my-centered.h"
{ 

_stencil_val(fm.x,0,0,0);_stencil_val(ibmf.x,0,0,0);; _stencil_val(fm.x,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);    _stencil_val_a(gf.x,0,0,0);   



  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 456 "./../my-centered.h"
{ 

_stencil_val(fm.y,0,0,0);_stencil_val(ibmf.y,0,0,0);; _stencil_val(fm.y,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);    _stencil_val_a(gf.y,0,0,0);   



  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 456 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.x,0,0,0) = val(fm.x,0,0,0)*val(ibmf.x,0,0,0)*_const_a.x - val(fm.x,0,0,0)*_const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;



  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.y,0,0,0) = val(fm.y,0,0,0)*val(ibmf.y,0,0,0)*_const_a.y - val(fm.y,0,0,0)*_const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;



  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 462 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 462 "./../my-centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 456 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 456 "./../my-centered.h"
{

;_stencil_val(ibmf.x,0,0,0);;;;_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);    _stencil_val_a(gf.x,0,0,0);   



  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 456 "./../my-centered.h"
{

;_stencil_val(ibmf.y,0,0,0);;;;_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);    _stencil_val_a(gf.y,0,0,0);   



  }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 456 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.x,0,0,0) = _const_fm.x*val(ibmf.x,0,0,0)*_const_a.x - _const_fm.x*_const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;



  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 456 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 456 "./../my-centered.h"
{

    val(gf.y,0,0,0) = _const_fm.y*val(ibmf.y,0,0,0)*_const_a.y - _const_fm.y*_const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;



  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 462 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 462 "./../my-centered.h"
}





  trash (((vector[]){g,{{-1},{-1}}}));
  if(!is_constant(fm.x)){  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 469, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 469 "./../my-centered.h"
{
     {

_stencil_val(gf.x,0,0,0); _stencil_val(gf.x,1,0,0);_stencil_val(fm.x,0,0,0);_stencil_val(ibmf.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val(ibmf.x,1,0,0);      _stencil_val_a(g.x,0,0,0);        



    } 
#line 470
{

_stencil_val(gf.y,0,0,0); _stencil_val(gf.y,0,1,0);_stencil_val(fm.y,0,0,0);_stencil_val(ibmf.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val(ibmf.y,0,1,0);      _stencil_val_a(g.y,0,0,0);        



    }
  }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 469 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 469 "./../my-centered.h"
{
     {

      val(g.x,0,0,0) = (val(gf.x,0,0,0) + val(gf.x,1,0,0)) / (val(fm.x,0,0,0)*val(ibmf.x,0,0,0) + val(fm.x,1,0,0)*val(ibmf.x,1,0,0) + 1e-30);



    } 
#line 470
{

      val(g.y,0,0,0) = (val(gf.y,0,0,0) + val(gf.y,0,1,0)) / (val(fm.y,0,0,0)*val(ibmf.y,0,0,0) + val(fm.y,0,1,0)*val(ibmf.y,0,1,0) + 1e-30);



    }
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 477 "./../my-centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 469, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 469 "./../my-centered.h"
{
     {

_stencil_val(gf.x,0,0,0); _stencil_val(gf.x,1,0,0);;_stencil_val(ibmf.x,0,0,0);;_stencil_val(ibmf.x,1,0,0);      _stencil_val_a(g.x,0,0,0);        



    } 
#line 470
{

_stencil_val(gf.y,0,0,0); _stencil_val(gf.y,0,1,0);;_stencil_val(ibmf.y,0,0,0);;_stencil_val(ibmf.y,0,1,0);      _stencil_val_a(g.y,0,0,0);        



    }
  }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 469 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 469 "./../my-centered.h"
{
     {

      val(g.x,0,0,0) = (val(gf.x,0,0,0) + val(gf.x,1,0,0)) / (_const_fm.x*val(ibmf.x,0,0,0) + _const_fm.x*val(ibmf.x,1,0,0) + 1e-30);



    } 
#line 470
{

      val(g.y,0,0,0) = (val(gf.y,0,0,0) + val(gf.y,0,1,0)) / (_const_fm.y*val(ibmf.y,0,0,0) + _const_fm.y*val(ibmf.y,0,1,0) + 1e-30);



    }
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 477 "./../my-centered.h"
}delete((scalar*)((vector[]){gf,{{-1},{-1}}}));
}






static int projection_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int projection(const int i,const double t,Event *_ev){tracing("projection","./../my-centered.h",485);
{
  mgp = project (uf, p, alpha, dt, mgp.nrelax);
  centered_gradient (p, g);



  correction (dt);
}{end_tracing("projection","./../my-centered.h",493);return 0;}end_tracing("projection","./../my-centered.h",493);}





static int end_timestep_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int end_timestep(const int i,const double t,Event *_ev){;return 0;}









static int adapt_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 509 "./../my-centered.h"
      static int adapt(const int i,const double t,Event *_ev){tracing("adapt","./../my-centered.h",509); {







if(!is_constant(fm.x)){  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 517, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 517 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 518 "./../my-centered.h"
{_stencil_val(uf.x,0,0,0);_stencil_val(fm.x,0,0,0);_stencil_val(ibmf.x,0,0,0);
      {_stencil_val_a(uf.x,0,0,0);  }     } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 518 "./../my-centered.h"
{_stencil_val(uf.y,0,0,0);_stencil_val(fm.y,0,0,0);_stencil_val(ibmf.y,0,0,0);
      {_stencil_val_a(uf.y,0,0,0);  }     }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 517 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 518 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 518 "./../my-centered.h"
if (val(uf.x,0,0,0) && (!val(fm.x,0,0,0) || !val(ibmf.x,0,0,0)))
      val(uf.x,0,0,0) = 0.;}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 518 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 518 "./../my-centered.h"
if (val(uf.y,0,0,0) && (!val(fm.y,0,0,0) || !val(ibmf.y,0,0,0)))
      val(uf.y,0,0,0) = 0.;}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 519 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 519 "./../my-centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-centered.h", .line = 517, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 517 "./../my-centered.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 518 "./../my-centered.h"
{_stencil_val(uf.x,0,0,0);;_stencil_val(ibmf.x,0,0,0);
      {_stencil_val_a(uf.x,0,0,0);  }     } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 518 "./../my-centered.h"
{_stencil_val(uf.y,0,0,0);;_stencil_val(ibmf.y,0,0,0);
      {_stencil_val_a(uf.y,0,0,0);  }     }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 517 "./../my-centered.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 518 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 518 "./../my-centered.h"
if (val(uf.x,0,0,0) && (!_const_fm.x || !val(ibmf.x,0,0,0)))
      val(uf.x,0,0,0) = 0.;}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 518 "./../my-centered.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 518 "./../my-centered.h"
if (val(uf.y,0,0,0) && (!_const_fm.y || !val(ibmf.y,0,0,0)))
      val(uf.y,0,0,0) = 0.;}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 519 "./../my-centered.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 519 "./../my-centered.h"
}

  event ("properties");
}{end_tracing("adapt","./../my-centered.h",522);return 0;}end_tracing("adapt","./../my-centered.h",522);}
#line 6 "sessile-ibm-axi-osc.c"
#line 1 "../ibm-gcm-events.h"
#line 1 "./../ibm-gcm-events.h"

vector  bi={{19},{20}};
#line 14
static int update_metric_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 14 "./../ibm-gcm-events.h"
      static int update_metric(const int i,const double t,Event *_ev){tracing("update_metric","./../ibm-gcm-events.h",14);
{

    boundary_internal ((scalar *)((scalar[]){ibm, ibmf.x, ibmf.y,{-1}}), "./../ibm-gcm-events.h", 17);
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-events.h", .line = 18, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 18 "./../ibm-gcm-events.h"
{
_stencil_val(ibm,0,0,0);{
            {_stencil_val_a(ibmCells,0,0,0);  }
            
{_stencil_val_a(ibmCells,0,0,0);  }}    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 18 "./../ibm-gcm-events.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 18 "./../ibm-gcm-events.h"
{
        if (val(ibm,0,0,0) > 0.5)
            val(ibmCells,0,0,0) = 1;
        else
            val(ibmCells,0,0,0) = 0;
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-events.h", .line = 25, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 25 "./../ibm-gcm-events.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 25 "./../ibm-gcm-events.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,-1,0,0); _stencil_is_ghost_cell (point, ibm);{
            {_stencil_val_a(ibmFaces.x,0,0,0);  }
            
{_stencil_val_a(ibmFaces.x,0,0,0);  }}    
} 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 25 "./../ibm-gcm-events.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,-1,0); _stencil_is_ghost_cell (point, ibm);{
            {_stencil_val_a(ibmFaces.y,0,0,0);  }
            
{_stencil_val_a(ibmFaces.y,0,0,0);  }}    
}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 25 "./../ibm-gcm-events.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 25 "./../ibm-gcm-events.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 25 "./../ibm-gcm-events.h"
{
       if (val(ibm,0,0,0) > 0 || val(ibm,-1,0,0) > 0 || is_ghost_cell (point, ibm))
            val(ibmFaces.x,0,0,0) = 1;
       else
            val(ibmFaces.x,0,0,0) = 0;
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 25 "./../ibm-gcm-events.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 25 "./../ibm-gcm-events.h"
{
       if (val(ibm,0,0,0) > 0 || val(ibm,0,-1,0) > 0 || is_ghost_cell (point, ibm))
            val(ibmFaces.y,0,0,0) = 1;
       else
            val(ibmFaces.y,0,0,0) = 0;
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 30 "./../ibm-gcm-events.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}    
#line 33 "./../ibm-gcm-events.h"
cm_update (cm, ibmCells);
    fm_update (fm, ibmFaces);
    boundary_internal ((scalar *)((scalar[]){fm.x,fm.y, cm, ibmFaces.x, ibmFaces.y, ibmCells,{-1}}), "./../ibm-gcm-events.h", 35);



}{end_tracing("update_metric","./../ibm-gcm-events.h",39);return 0;}end_tracing("update_metric","./../ibm-gcm-events.h",39);}
#line 145 "./../ibm-gcm-events.h"
scalar  ibalphas={21};
vector  normals={{22},{23}};
vector  midPoints={{24},{25}};



static int acceleration_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int acceleration_0(const int i,const double t,Event *_ev){tracing("acceleration_0","./../ibm-gcm-events.h",151);
{
    trash(((vector[]){normals, midPoints,{{-1},{-1}}}));
  


    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-events.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 156 "./../ibm-gcm-events.h"
{  
        
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);{ {
_stencil_val(ibalphas,0,0,0);            _stencil_centroid_point (point, ibm,NULL ,NULL ,NULL );
             {
                _stencil_val_a(midPoints.x,0,0,0);  
                _stencil_val_a(normals.x,0,0,0);  
            } 
#line 160
{
                _stencil_val_a(midPoints.y,0,0,0);  
                _stencil_val_a(normals.y,0,0,0);  
            }
            _stencil_val_r(ibalphas,0,0,0);  
        } 
{_stencil_val(ibm,0,0,0); _stencil_empty_neighbor (point,NULL ,NULL , ibm);{ {
             {
                _stencil_val_a(midPoints.x,0,0,0);  
                _stencil_val_a(normals.x,0,0,0);  
            } 
#line 167
{
                _stencil_val_a(midPoints.y,0,0,0);  
                _stencil_val_a(normals.y,0,0,0);  
            }
            _stencil_val_a(ibalphas,0,0,0);  
        } 
{
             {
                _stencil_val_a(midPoints.x,0,0,0);  
                _stencil_val_a(normals.x,0,0,0);  
            } 
#line 174
{
                _stencil_val_a(midPoints.y,0,0,0);  
                _stencil_val_a(normals.y,0,0,0);  
            }
            _stencil_val_a(ibalphas,0,0,0);  
        }}        }}    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 156 "./../ibm-gcm-events.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../ibm-gcm-events.h"
{
        coord midPoint, n;
        if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7)) {
            centroid_point (point, ibm, &midPoint, &n, &val(ibalphas,0,0,0));
             {
                val(midPoints.x,0,0,0) = midPoint.x;
                val(normals.x,0,0,0) = -n.x;
            } 
#line 160
{
                val(midPoints.y,0,0,0) = midPoint.y;
                val(normals.y,0,0,0) = -n.y;
            }
            val(ibalphas,0,0,0) *= -1;
        }
        else if (val(ibm,0,0,0) == 1 && empty_neighbor (point, &midPoint, &n, ibm)) {
             {
                val(midPoints.x,0,0,0) = midPoint.x;
                val(normals.x,0,0,0) = -n.x;
            } 
#line 167
{
                val(midPoints.y,0,0,0) = midPoint.y;
                val(normals.y,0,0,0) = -n.y;
            }
            val(ibalphas,0,0,0) = 0;
        }
        else {
             {
                val(midPoints.x,0,0,0) = 0;
                val(normals.x,0,0,0) = 0;
            } 
#line 174
{
                val(midPoints.y,0,0,0) = 0;
                val(normals.y,0,0,0) = 0;
            }
            val(ibalphas,0,0,0) = 0;
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}    
#line 182 "./../ibm-gcm-events.h"
boundary_internal ((scalar *)((scalar[]){midPoints.x,midPoints.y, normals.x, normals.y, ibalphas,{-1}}), "./../ibm-gcm-events.h", 182);


    _attribute[u.x.i].mp = bi; _attribute[u.y.i].mp = bi;
  





    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-events.h", .line = 191, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 191 "./../ibm-gcm-events.h"
{
_stencil_is_ghost_cell(point, ibm);{ {        
            
            
            

            _stencil_closest_interface (point, midPoints, ibm, normals,NULL ,NULL ,NULL );  
             _stencil_boundary_int (point,NULL ,NULL , NULL);     

            

            
                {_stencil_val_a(bi.x,0,0,0);  }                {_stencil_val_a(bi.y,0,0,0);  }  

             _stencil_image_velocity2 (point, u,
NULL 
#line 205
,
NULL 
#line 205
,
                                                   midPoints, normals, ibalphas);

            if (local_bc_coordinates) {       
                                       
                                            
                   
                

                

                
                 {    
                      
                    default_stencil ( point,((scalar[]){ u.x,{-1}}));      
                     
                     
                           
                             
                             
                                      
                              


                                  
                                               
                         
                        
                                
                     
                    
                          
                     
                } 
#line 217
{    
                      
                    default_stencil ( point,((scalar[]){ u.y,{-1}}));      
                     
                     
                           
                             
                             
                                      
                              


                                  
                                               
                         
                        
                                
                     
                    
                          
                     
                }         

                
                
                    {_stencil_val_a(u.x,0,0,0);      }                    {_stencil_val_a(u.y,0,0,0);      }
            }
            else {
                 {     
                    
                    default_stencil ( point,((scalar[]){ u.x,{-1}}) );
{ {

                        _stencil_val_a(u.x,0,0,0);    
                    } 
{
                        _stencil_val_a(u.x,0,0,0);  
                    }}                
} 
#line 245
{     
                    
                    default_stencil ( point,((scalar[]){ u.y,{-1}}) );
{ {

                        _stencil_val_a(u.y,0,0,0);    
                    } 
{
                        _stencil_val_a(u.y,0,0,0);  
                    }}                
}
            }
_stencil_val(ibm,0,0,0); { 
_stencil_image_pressure (point, p,NULL );                _stencil_val_a(p,0,0,0); 
_stencil_image_pressure (point, pf,NULL );                _stencil_val_a(pf,0,0,0); 
            }       
} 
{_stencil_val(ibm,0,0,0); {
           _stencil_val_a(p,0,0,0);   _stencil_val_a(pf,0,0,0);  
            {
               _stencil_val_a(u.x,0,0,0);  
           } 
#line 264
{
               _stencil_val_a(u.y,0,0,0);  
           }
       }   }}    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 191 "./../ibm-gcm-events.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 191 "./../ibm-gcm-events.h"
{
        if (is_ghost_cell(point, ibm)) {
            fragment interFrag;
            coord fluidCell, ghostCell = {x,y,z};
            PointIBM bioff = {0,0,0};

            closest_interface (point, midPoints, ibm, normals, &interFrag, &fluidCell, &bioff);
            coord boundaryInt = boundary_int (point, interFrag, fluidCell, ibm);

            coord imagePoint = image_point (boundaryInt, ghostCell);

            
                val(bi.x,0,0,0) = boundaryInt.x;                val(bi.y,0,0,0) = boundaryInt.y;

            coord imageVelocity = image_velocity2 (point, u, imagePoint, bioff,
                                                   midPoints, normals, ibalphas);

            if (local_bc_coordinates) {
                coord n = interFrag.n, t1, t2;
                normal_and_tangents (&n, &t1, &t2);

                coord projVelocity = {dot_product(imageVelocity, n),
                                      dot_product(imageVelocity, t1),
                                      dot_product(imageVelocity, t2)};

                coord gcProjVelocity = {0,0,0};
                 {
                    bool bctype[2] = {false, false};
                    double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, bctype);
                    bool dirichlet = bctype[0], nslip = bctype[1];
                    if (dirichlet) {
                        if (nslip) {
                            double delta = 0;
                            
                                delta += ( (ghostCell.x - imagePoint.x)*(ghostCell.x - imagePoint.x));                                delta += ( (ghostCell.y - imagePoint.y)*(ghostCell.y - imagePoint.y));
                            delta = sqrt(delta);


                            gcProjVelocity.x = delta*(0 - projVelocity.x)/(0.5*delta + vb) +
                                               projVelocity.x;
                        }
                        else
                            gcProjVelocity.x = 2*vb - projVelocity.x;
                    }
                    else {
                        gcProjVelocity.x = projVelocity.x;
                    }
                } 
#line 217
{
                    bool bctype[2] = {false, false};
                    double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, bctype);
                    bool dirichlet = bctype[0], nslip = bctype[1];
                    if (dirichlet) {
                        if (nslip) {
                            double delta = 0;
                            
                                delta += ( (ghostCell.y - imagePoint.y)*(ghostCell.y - imagePoint.y));                                delta += ( (ghostCell.x - imagePoint.x)*(ghostCell.x - imagePoint.x));
                            delta = sqrt(delta);


                            gcProjVelocity.y = delta*(0 - projVelocity.y)/(0.5*delta + vb) +
                                               projVelocity.y;
                        }
                        else
                            gcProjVelocity.y = 2*vb - projVelocity.y;
                    }
                    else {
                        gcProjVelocity.y = projVelocity.y;
                    }
                }

                double gcn = gcProjVelocity.x, gct1 = gcProjVelocity.y, gct2 = gcProjVelocity.z;
                
                    val(u.x,0,0,0) = gcn*n.x + gct1*t1.x + gct2*t2.x;                    val(u.y,0,0,0) = gcn*n.y + gct1*t1.y + gct2*t2.y;
            }
            else {
                 {
                    bool dirichlet = false;
                    double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, &dirichlet);
                    if (dirichlet) {

                        val(u.x,0,0,0) = 2*vb - imageVelocity.x;
                    }
                    else {
                        val(u.x,0,0,0) = imageVelocity.x;
                    }
                } 
#line 245
{
                    bool dirichlet = false;
                    double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, &dirichlet);
                    if (dirichlet) {

                        val(u.y,0,0,0) = 2*vb - imageVelocity.y;
                    }
                    else {
                        val(u.y,0,0,0) = imageVelocity.y;
                    }
                }
            }
            if (val(ibm,0,0,0) <= 0.) {
                val(p,0,0,0) = image_pressure (point, p, imagePoint);
                val(pf,0,0,0) = image_pressure (point, pf, imagePoint);
            }
       }
       else if (val(ibm,0,0,0) == 0) {
           val(p,0,0,0) = 0; val(pf,0,0,0) = 0;
            {
               val(u.x,0,0,0) = 0.;
           } 
#line 264
{
               val(u.y,0,0,0) = 0.;
           }
       }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}    
#line 270 "./../ibm-gcm-events.h"
boundary_internal ((scalar *)(scalar *)((scalar[]){u.x,u.y, p, pf, bi.x, bi.y,{-1}}), "./../ibm-gcm-events.h", 270);
}{end_tracing("acceleration_0","./../ibm-gcm-events.h",271);return 0;}end_tracing("acceleration_0","./../ibm-gcm-events.h",271);}
#line 289
static int end_timestep_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 289 "./../ibm-gcm-events.h"
      static int end_timestep_0(const int i,const double t,Event *_ev){tracing("end_timestep_0","./../ibm-gcm-events.h",289);
{
    correction(-dt);
  


    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-events.h", .line = 294, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 294 "./../ibm-gcm-events.h"
{
_stencil_is_ghost_cell(point, ibm);{ {      
           
           
           

           _stencil_closest_interface (point, midPoints, ibm, normals,NULL ,NULL ,NULL );  
            _stencil_boundary_int (point,NULL ,NULL , NULL);     
           

_stencil_val(ibm,0,0,0); { 
_stencil_image_pressure (point, p,NULL );               _stencil_val_a(p,0,0,0); 
_stencil_image_pressure (point, pf,NULL );               _stencil_val_a(pf,0,0,0); 
           }       
} 
{_stencil_val(ibm,0,0,0); {
           _stencil_val_a(p,0,0,0);   _stencil_val_a(pf,0,0,0);  
       }   }}    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 294 "./../ibm-gcm-events.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 294 "./../ibm-gcm-events.h"
{
        if (is_ghost_cell(point, ibm)) {
           fragment interFrag;
           coord fluidCell, ghostCell = {x,y,z};
           PointIBM bioff;

           closest_interface (point, midPoints, ibm, normals, &interFrag, &fluidCell, &bioff);
           coord boundaryInt = boundary_int (point, interFrag, fluidCell, ibm);
           coord imagePoint = image_point (boundaryInt, ghostCell);

           if (val(ibm,0,0,0) <= 0.) {
               val(p,0,0,0) = image_pressure (point, p, imagePoint);
               val(pf,0,0,0) = image_pressure (point, pf, imagePoint);
           }
       }
       else if (val(ibm,0,0,0) == 0) {
           val(p,0,0,0) = 0; val(pf,0,0,0) = 0;
       }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}    
#line 314 "./../ibm-gcm-events.h"
boundary_internal ((scalar *)((scalar[]){u.x,u.y, p, pf,{-1}}), "./../ibm-gcm-events.h", 314);
    centered_gradient (p, g);


    correction(dt);
    boundary_internal ((scalar *)((vector[]){u,{{-1},{-1}}}), "./../ibm-gcm-events.h", 319);

    _attribute[u.x.i].mp = bi; _attribute[u.y.i].mp = bi;    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-events.h", .line = 327, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 327 "./../ibm-gcm-events.h"
{
_stencil_is_ghost_cell(point, ibm);{ {      
            
            
            

            _stencil_closest_interface (point, midPoints, ibm, normals,NULL ,NULL ,NULL );  
             _stencil_boundary_int (point,NULL ,NULL , NULL);     
            

            
                {_stencil_val_a(bi.x,0,0,0);  }                {_stencil_val_a(bi.y,0,0,0);  }  

             _stencil_image_velocity2 (point, u,
NULL 
#line 340
,
NULL 
#line 340
,
                                                   midPoints, normals, ibalphas);

            if (local_bc_coordinates) {       
                                       
                                            
                   
                

                
                
                 {    
                      
                    default_stencil ( point,((scalar[]){ u.x,{-1}}));      
                     
                     
                           
                             
                             
                                      

                              


                                  
                                               
                         
                        
                                
                     
                    
                          
                     
                } 
#line 351
{    
                      
                    default_stencil ( point,((scalar[]){ u.y,{-1}}));      
                     
                     
                           
                             
                             
                                      

                              


                                  
                                               
                         
                        
                                
                     
                    
                          
                     
                }         

                
                
                    {_stencil_val_a(u.x,0,0,0);      }                    {_stencil_val_a(u.y,0,0,0);      }
            }
            else {
                 {     
                    
                    default_stencil ( point,((scalar[]){ u.x,{-1}}) );
{ {
                        _stencil_val_a(u.x,0,0,0);    
                    } 
{
                        _stencil_val_a(u.x,0,0,0);  
                    }}                
} 
#line 380
{     
                    
                    default_stencil ( point,((scalar[]){ u.y,{-1}}) );
{ {
                        _stencil_val_a(u.y,0,0,0);    
                    } 
{
                        _stencil_val_a(u.y,0,0,0);  
                    }}                
}
            }
       } 
{_stencil_val(ibm,0,0,0); {
            {
               _stencil_val_a(u.x,0,0,0);  
           } 
#line 393
{
               _stencil_val_a(u.y,0,0,0);  
           }
       }   }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 327 "./../ibm-gcm-events.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 327 "./../ibm-gcm-events.h"
{
        if (is_ghost_cell(point, ibm)) {
            fragment interFrag;
            coord fluidCell, ghostCell = {x,y,z};
            PointIBM bioff;

            closest_interface (point, midPoints, ibm, normals, &interFrag, &fluidCell, &bioff);
            coord boundaryInt = boundary_int (point, interFrag, fluidCell, ibm);
            coord imagePoint = image_point (boundaryInt, ghostCell);

            
                val(bi.x,0,0,0) = boundaryInt.x;                val(bi.y,0,0,0) = boundaryInt.y;

            coord imageVelocity = image_velocity2 (point, u, imagePoint, bioff,
                                                   midPoints, normals, ibalphas);

            if (local_bc_coordinates) {
                coord n = interFrag.n, t1, t2;
                normal_and_tangents (&n, &t1, &t2);

                coord projVelocity = {dot_product(imageVelocity, n),
                                      dot_product(imageVelocity, t1),
                                      dot_product(imageVelocity, t2)};
                coord gcProjVelocity = {0,0,0};
                 {
                    bool bctype[2] = {false, false};
                    double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, bctype);
                    bool dirichlet = bctype[0], nslip = bctype[1];
                    if (dirichlet) {
                        if (nslip) {
                            double delta = 0;
                            
                                delta += ( (ghostCell.x - imagePoint.x)*(ghostCell.x - imagePoint.x));                                delta += ( (ghostCell.y - imagePoint.y)*(ghostCell.y - imagePoint.y));

                            delta = sqrt(delta);


                            gcProjVelocity.x = delta*(0 - projVelocity.x)/(0.5*delta + vb) +
                                               projVelocity.x;
                        }
                        else
                            gcProjVelocity.x = 2*vb - projVelocity.x;
                    }
                    else {
                        gcProjVelocity.x = projVelocity.x;
                    }
                } 
#line 351
{
                    bool bctype[2] = {false, false};
                    double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, bctype);
                    bool dirichlet = bctype[0], nslip = bctype[1];
                    if (dirichlet) {
                        if (nslip) {
                            double delta = 0;
                            
                                delta += ( (ghostCell.y - imagePoint.y)*(ghostCell.y - imagePoint.y));                                delta += ( (ghostCell.x - imagePoint.x)*(ghostCell.x - imagePoint.x));

                            delta = sqrt(delta);


                            gcProjVelocity.y = delta*(0 - projVelocity.y)/(0.5*delta + vb) +
                                               projVelocity.y;
                        }
                        else
                            gcProjVelocity.y = 2*vb - projVelocity.y;
                    }
                    else {
                        gcProjVelocity.y = projVelocity.y;
                    }
                }

                double gcn = gcProjVelocity.x, gct1 = gcProjVelocity.y, gct2 = gcProjVelocity.z;
                
                    val(u.x,0,0,0) = gcn*n.x + gct1*t1.x + gct2*t2.x;                    val(u.y,0,0,0) = gcn*n.y + gct1*t1.y + gct2*t2.y;
            }
            else {
                 {
                    bool dirichlet = false;
                    double vb = _attribute[u.x.i].boundary[immersed] (point, point, u.x, &dirichlet);
                    if (dirichlet) {
                        val(u.x,0,0,0) = 2*vb - imageVelocity.x;
                    }
                    else {
                        val(u.x,0,0,0) = imageVelocity.x;
                    }
                } 
#line 380
{
                    bool dirichlet = false;
                    double vb = _attribute[u.y.i].boundary[immersed] (point, point, u.y, &dirichlet);
                    if (dirichlet) {
                        val(u.y,0,0,0) = 2*vb - imageVelocity.y;
                    }
                    else {
                        val(u.y,0,0,0) = imageVelocity.y;
                    }
                }
            }
       }
       else if (val(ibm,0,0,0) == 0) {
            {
               val(u.x,0,0,0) = 0.;
           } 
#line 393
{
               val(u.y,0,0,0) = 0.;
           }
       }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}    
#line 398 "./../ibm-gcm-events.h"
boundary_internal ((scalar *)(scalar *)((vector[]){u, bi,{{-1},{-1}}}), "./../ibm-gcm-events.h", 398);
}{end_tracing("end_timestep_0","./../ibm-gcm-events.h",399);return 0;}end_tracing("end_timestep_0","./../ibm-gcm-events.h",399);}
#line 7 "sessile-ibm-axi-osc.c"
#line 1 "../ibm-gcm-vof-test.h"
#line 1 "./../ibm-gcm-vof-test.h"
#line 10 "./../ibm-gcm-vof-test.h"
        scalar contact_angle;

extern scalar f;

typedef struct proj_coord {
    coord og;
    double x, y;
} proj_coord;

typedef struct triangle {
    coord p[3];
} triangle;

typedef struct plane {
    coord n;
    double alpha;

    coord * p;
    int psize;

    triangle * tri;
    int tsize;
} plane;

double get_percent_error (double a0, double a1)
{
    return (a1 - a0)/(a0+1e-30) * 100;
}

int percent_error_tol (double a0, double a1, double TOL)
{
    return fabs(get_percent_error(a0, a1)) <= TOL;
}

coord get_centroid (int size, coord * np)
{
    coord centroid = {0,0,0};
    for (int i = 0; i < size; ++i) {
        
            centroid.x += np[i].x;            centroid.y += np[i].y;
    }

    
        centroid.x /= size + 1e-30;        centroid.y /= size + 1e-30;

    return centroid;
}

int near_id_cell (Point point, scalar id)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 60 "./../ibm-gcm-vof-test.h"
{
        if (val(id,0,0,0) > 0)
            return 1;
    }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 64 "./../ibm-gcm-vof-test.h"
return 0;
}
#line 58
static void _stencil_near_id_cell (Point point, scalar id)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 60 "./../ibm-gcm-vof-test.h"
{
_stencil_val(id,0,0,0);    

}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
    
#line 64 "./../ibm-gcm-vof-test.h"
return ;
}

     
void reconstruction_real (const scalar c, vector n, scalar alpha, scalar id)
{tracing("reconstruction_real","./../ibm-gcm-vof-test.h",68);
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 70, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 70 "./../ibm-gcm-vof-test.h"
{
_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{ {
            _stencil_val_a(alpha,0,0,0);  
            
                {_stencil_val_a(n.x,0,0,0);  }                {_stencil_val_a(n.y,0,0,0);  }
        } 
{_stencil_near_id_cell(point, id); {  
             _stencil_mycs (point, c);
            
                {_stencil_val_a(n.x,0,0,0);  }                {_stencil_val_a(n.y,0,0,0);  }
_stencil_val(c,0,0,0);            _stencil_val_a(alpha,0,0,0);   
        } }}    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 70 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 70 "./../ibm-gcm-vof-test.h"
{
        if (val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) {
            val(alpha,0,0,0) = 0.;
            
                val(n.x,0,0,0) = 0.;                val(n.y,0,0,0) = 0.;
        }
        else if (near_id_cell(point, id)) {
            coord m = mycs (point, c);
            
                val(n.x,0,0,0) = m.x;                val(n.y,0,0,0) = m.y;
            val(alpha,0,0,0) = line_alpha(val(c,0,0,0), m);
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}        
#line 86 "./../ibm-gcm-vof-test.h"
_attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;        _attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;

    _attribute[alpha.i].n = n;
    _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;

end_tracing("reconstruction_real","./../ibm-gcm-vof-test.h",91);}

void print_plane_points(int pcount, plane * planes)
{
    for (int i = 0; i < pcount; ++i) {
        fprintf(ferr, "\nplane #%d n={%g, %g, %g} alpha=%g\n",
        i+1, planes[i].n.x, planes[i].n.y, planes[i].n.z, planes[i].alpha);

        for (int j = 0; j < planes[i].psize; ++j) {
            fprintf(ferr, "point #%d p = {%g, %g, %g}\n",
                j+1, planes[i].p[j].x, planes[i].p[j].y, planes[i].p[j].z);
        }
    }
}

void print_plane_triangles(int pcount, plane * planes)
{
    for (int i = 0; i < pcount; ++i) {
        fprintf(ferr, "\nplane #%d n={%g, %g, %g} alpha=%g\n",
        i+1, planes[i].n.x, planes[i].n.y, planes[i].n.z, planes[i].alpha);

        for (int j = 0; j < planes[i].tsize; ++j) {

            fprintf (ferr, "triangle #%d\n", j+1);
            for (int k = 0; k < 3; ++k) {
                fprintf(ferr, "point #%d p = {%g, %g, %g}\n",
                    k+1, planes[i].tri[j].p[k].x, planes[i].tri[j].p[k].y, planes[i].tri[j].p[k].z);
            }
        }
    }
}

void print_coord_list (int size, coord list[size])
{
    for (int i = 0; i < size; ++i) {
        fprintf(ferr, "point #%d = {%0.15g, %0.15g, %0.15g}\n", i+1, list[i].x, list[i].y, list[i].z);
    }
}



coord plane_p0 (plane pl1, plane pl2, coord d)
{
    coord n1 = pl1.n, n2 = pl2.n;
    double alpha1 = pl1.alpha, alpha2 = pl2.alpha;

    int drop = (fabs(d.x) >= fabs(d.y) && fabs(d.x) >= fabs(d.z)) ? 0 :
               (fabs(d.y) >= fabs(d.z)) ? 1 : 2;

    double a1, a2, b1, b2;

    switch (drop) {
        case 0:
            a1 = n1.y; b1 = n1.z; a2 = n2.y; b2 = n2.z; break;
        case 1:
            a1 = n1.x; b1 = n1.z; a2 = n2.x; b2 = n2.z; break;
        case 2:
            a1 = n1.x; b1 = n1.y; a2 = n2.x; b2 = n2.y; break;
    }

    double det = a1*b2 - a2*b1;



    double u = (alpha1 * b2 - alpha2 * b1) / (det + 1e-30);
    double v = (alpha2 * a1 - alpha1 * a2) / (det + 1e-30);

    coord p0;
    switch (drop) {
        case 0:
            p0.x = 0; p0.y = u; p0.z = v; break;
        case 1:
            p0.x = u; p0.y = 0; p0.z = v; break;
        case 2:
            p0.x = u; p0.y = v; p0.z = 0; break;
    }

    return p0;
}

double plane_t (coord p0, coord d, coord face)
{
    int type = face.x? 0: face.y? 1: 2;

    switch(type) {
        case 0:
            if (fabs(d.x) < 1e-14) return 1e30f;
            return (face.x - p0.x) / d.x;
        case 1:
            if (fabs(d.y) < 1e-14) return 1e30f;
                return (face.y - p0.y) / d.y;
        case 2:
            if (fabs(d.z) < 1e-14) return 1e30f;
                return (face.z - p0.z) / d.z;
    }
    return 1e30f;
}

int bounds_check (coord p, double ufdx)
{
    return p.x <= ufdx+1e-11 && fabs(p.x) <= 0.5+1e-11 && fabs(p.y) <= 0.5+1e-11 && fabs(p.z) <= 0.5+1e-11;
}

int point_is_unique (int size, coord pint[size], coord p)
{
    for (int i = 0; i < size; ++i)
        if (approx_equal(pint[i], p, 1e-11))
            return 0;
    return 1;
}

int plane_is_unique (int size, plane pint[size], plane p)
{
    for (int i = 0; i < size; ++i)
        if (approx_equal(pint[i].n, p.n, 1e-11) &&
            approx_equal_double(pint[i].alpha, p.alpha, 1e-11))
            return 0;
    return 1;
}

const coord cubeface[6] = {
        { 0.5, 0.0, 0.0},
        {-0.5, 0.0, 0.0},
        { 0.0, 0.5, 0.0},
        { 0.0,-0.5, 0.0},
        { 0.0, 0.0, 0.5},
        { 0.0, 0.0,-0.5}
};



int plane_intersect (plane pl1, plane pl2, plane padv, coord pint[2], int print)
{
    if (determinant(pl1.n, pl2.n) <= 1e-15) {



        return 0;
    }

    coord d = cross_product(pl1.n, pl2.n);
    coord p0 = plane_p0 (pl1, pl2, d);
#line 244 "./../ibm-gcm-vof-test.h"
    coord cubeface_copy[6];
    memcpy(cubeface_copy, cubeface, sizeof(cubeface));
    cubeface_copy[0].x = padv.alpha;

    int count = 0;
    for (int i = 0; i < 6; ++i) {
        double t = plane_t (p0, d, cubeface_copy[i]);

        if (t == 1e30f)
            continue;

        coord pit = {p0.x + t*d.x, p0.y + t*d.y, p0.z + t*d.z};
#line 276 "./../ibm-gcm-vof-test.h"
        if (bounds_check(pit, padv.alpha) && point_is_unique(2, pint, pit)) {

            if (count > 2)
                fprintf(ferr, "WARNING: count > 2 in plane_intersect!\n");
            else {
                pint[count] = pit;
                count++;
            }
        }
    }

    return count;
}

static coord cube_vertices[8] = {
        { 0.5, 0.5, 0.5},
        { 0.5,-0.5, 0.5},
        { 0.5, 0.5,-0.5},
        { 0.5,-0.5,-0.5},
        {-0.5, 0.5, 0.5},
        {-0.5, 0.5,-0.5},
        {-0.5,-0.5, 0.5},
        {-0.5,-0.5,-0.5}
};







bool is_triple_point (Point point, coord nf, coord ns)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 309 "./../ibm-gcm-vof-test.h"
if (!((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7)) || !((val(f,0,0,0) > 0+1e-7 && val(f,0,0,0) < 1-1e-7)))
        return false;
    if ((ns.x == 0 && ns.y == 0 && ns.z == 0) || (nf.x == 0 && nf.y == 0 && nf.z == 0))
        return false;

    double alphas = line_alpha (val(ibm,0,0,0), ns);

    double alphaf = line_alpha (val(f,0,0,0), nf);







    coord pt_int = {0,0};
    pt_int.x = ((alphas/(ns.y+1e-30)) - (alphaf/(nf.y+1e-30))) /
                  ((ns.x/(ns.y+1e-30)) - (nf.x/(nf.y+1e-30)) + 1e-30);
    pt_int.y = (alphaf/(nf.y + 1e-30)) - (nf.x*pt_int.x)/(nf.y + 1e-30);

    return (fabs(pt_int.x) <= 0.5 && fabs(pt_int.y) <= 0.5);
#line 338 "./../ibm-gcm-vof-test.h"
}
#line 307
static void _stencil_is_triple_point (Point point,_stencil_undefined * nf,_stencil_undefined * ns)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 309 "./../ibm-gcm-vof-test.h"
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);    




_stencil_val(ibm,0,0,0);     

    _stencil_val(f,0,0,0);   







     
            
                  
            

    return       ;
#line 338 "./../ibm-gcm-vof-test.h"
}







int boundary_points (coord nf, double alphaf, coord lhs, coord rhs, coord bp[2])
{
    int i = 0;

    double dx = rhs.x - lhs.x;
    if (fabs(dx) < 1e-15)
        return 0;

    if (fabs(nf.x) < 1e-15 && fabs(nf.y) < 1e-15)
        return 0;

    for (double xint = rhs.x; xint >= lhs.x; xint -= dx) {
        double yint = (alphaf - nf.x*xint)/(nf.y+1e-30);
        if (fabs(yint) <= 0.5) {
            bp[i].x = xint;
            bp[i].y = yint;
            ++i;
        }
    }


    for (double yint = -0.5; yint <= 0.5; yint += 1.) {
        double xint = (alphaf - nf.y*yint)/(nf.x+1e-30);
        if (xint <= rhs.x && xint >= lhs.x) {
            bp[i].x = xint;
            bp[i].y = yint;
            ++i;
        }
    }

    return i;
}
#line 389 "./../ibm-gcm-vof-test.h"
int interface_intersect (coord nf, double alphaf, coord ns, double alphas,
                         coord lhs, coord rhs, coord * pint)
{

    coord pt;
    pt.x = (alphas/(ns.y + 1e-30) - alphaf/(nf.y + 1e-30)) /
                  ((ns.x/(ns.y + 1e-30)) - (nf.x/(nf.y + 1e-30)) + 1e-30);

    pt.y = (alphaf/(nf.y + 1e-30)) - (nf.x*pt.x)/(nf.y + 1e-30);

     {
        if (pt.x < lhs.x || pt.x > rhs.x) {
            return 0;
        }
    } 
#line 399
{
        if (pt.y < lhs.y || pt.y > rhs.y) {
            return 0;
        }
    }
    if (pint)
        *pint = pt;

    return 1;
}
#line 421 "./../ibm-gcm-vof-test.h"
double region_check2(plane plf, plane pls, coord pc)
{

    double fluid = plf.alpha - plf.n.x*pc.x - plf.n.y*pc.y;
    double solid = pls.alpha - pls.n.x*pc.x - pls.n.y*pc.y;






    return ( fluid < solid ? fluid : solid);
}


double region_check (plane pl, coord pc)
{

    return pl.alpha - pl.n.x*pc.x - pl.n.y*pc.y;



}

int vertices_region(plane pls, plane plf, plane padv, coord pv[8], int print)
{
    coord cube_vertices_copy[8];
    memcpy(cube_vertices_copy, cube_vertices, sizeof(cube_vertices));

    for (int i = 0; i < 8; ++i) {
        if (approx_equal_double (cube_vertices_copy[i].x, 0.5
#line 142 "./../ibm-gcm.h"
, 1e-11
#line 451 "./../ibm-gcm-vof-test.h"
))
            cube_vertices_copy[i].x = padv.alpha;
    }

    int count = 0;
    for (int i = 0; i < 8; ++i) {
        double placement = region_check2(plf, pls, cube_vertices_copy[i]);
        if ((placement >= 0 || fabs(placement) < 1e-6) && bounds_check(cube_vertices_copy[i], padv.alpha))
            pv[i] = cube_vertices_copy[i], count++;
        else
            {
                pv[i].x = 1e30f;                pv[i].y = 1e30f;}
    }
    return count;
}

int fill_faces (plane plf, plane pls, plane padv, int nump, const coord tp[nump], plane** planes)
{


    plane cellnx = {{-1, 0, 0}, 0.5};
    plane cellpy = {{ 0, 1, 0}, 0.5};
    plane cellny = {{ 0,-1, 0}, 0.5};
    plane cellpz = {{ 0, 0, 1}, 0.5};
    plane cellnz = {{ 0, 0,-1}, 0.5};

    int numplanes = 6;

    plane allPlanes[8] = {
        plf, cellnx, cellpy, cellny, cellpz, cellnz
    };


    if (plane_is_unique(numplanes, allPlanes, padv)) {
        allPlanes[numplanes] = padv;
        ++numplanes;
    }


    if (plane_is_unique(numplanes, allPlanes, pls)) {
        allPlanes[numplanes] = pls;
        ++numplanes;
    }

    int planeCount = 0;
    for (int i = 0; i < numplanes; ++i) {

        int pcount = 0;
        for (int j = 0; j < nump; ++j) {
            double placement = region_check(allPlanes[i], tp[j]);
            if (fabs(placement) <= 1e-10)
                pcount++;
        }

        if (pcount < 3) {
            allPlanes[i].p = NULL;
            allPlanes[i].psize = 0;
            continue;
        }

        if (!(pcount >= 3)) qassert ("./../ibm-gcm-vof-test.h", 511, "pcount >= 3");

        allPlanes[i].p = pmalloc((pcount * sizeof(coord)),__func__,__FILE__,__LINE__);
        allPlanes[i].psize = pcount;

        for (int j = 0, jtrue = 0; j < nump; ++j) {
            double placement = region_check(allPlanes[i], tp[j]);
            if (fabs(placement) <= 1e-10) {
                allPlanes[i].p[jtrue] = tp[j];
                jtrue++;
            }
        }

        planeCount++;
    }

    *planes = pmalloc(planeCount * sizeof(plane),__func__,__FILE__,__LINE__);

    for (int i = 0, itrue = 0; i < numplanes; ++i) {
        if (allPlanes[i].psize > 0) {
            (*planes)[itrue] = allPlanes[i];
            ++itrue;
        }
    }

    return planeCount;
}





typedef int (*qsort_cmp_r)(const void *a, const void *b, void *arg);

static void *qsort_r_arg;

static int qsort_r_trampoline(const void *a, const void *b) {
    extern qsort_cmp_r qsort_r_func;
    return qsort_r_func(a, b, qsort_r_arg);
}

qsort_cmp_r qsort_r_func;

void qsort_r_fallback(void *base, size_t nmemb, size_t size,
                      qsort_cmp_r compar, void *arg) {
    qsort_r_func = compar;
    qsort_r_arg = arg;
    qsort(base, nmemb, size, qsort_r_trampoline);
}
#line 574 "./../ibm-gcm-vof-test.h"
int is_behind (const void *pa, const void *pb, void *center)
{
    const coord *a = pa, *b = pb, *c = center;
    double atheta = atan2 (a->y - c->y, a->x - c->x);
    double btheta = atan2 (b->y - c->y, b->x - c->x);

    if (atheta < 0) atheta += 2*3.14159265358979;
    if (btheta < 0) btheta += 2*3.14159265358979;

    if (atheta > btheta) return -1;
    if (atheta < btheta) return 1;



    double dista = ( (a->x - c->x)*(a->x - c->x)) + ( (a->y - c->y)*(a->y - c->y));
    double distb = ( (b->x - c->x)*(b->x - c->x)) + ( (b->y - c->y)*(b->y - c->y));

    return (dista > distb) ? -1: (dista < distb);
}

int compare_projected(const void *a, const void *b) {
    const proj_coord *pa = a;
    const proj_coord *pb = b;
    double angle_a = atan2(pa->y, pa->x);
    double angle_b = atan2(pb->y, pb->x);
    return (angle_a < angle_b) ? -1 : (angle_a > angle_b);
}

coord face_normal(coord a, coord b, coord c)
{
    coord ab = {b.x - a.x, b.y - a.y, b.z - a.z};
    coord ac = {c.x - a.x, c.y - a.y, c.z - a.z};
    coord n = cross_product (ab, ac);

    double norm = 0;
    
        norm += n.x;        norm += n.y;

    
        n.x /= norm + 1e-30;        n.y /= norm + 1e-30;

    return n;
}
#line 626 "./../ibm-gcm-vof-test.h"
void sort_clockwise (int nump, coord cf[nump], int print)
{
    double xsum = 0, ysum = 0;
    for (int i = 0; i < nump; ++i) {
        xsum += cf[i].x;
        ysum += cf[i].y;
    }
    coord pc = {xsum/nump, ysum/nump};

    if (print)
        fprintf(ferr, "SORTING: pc={%g, %g} nump=%d\n", pc.x, pc.y, nump);
    qsort_r_fallback (cf, nump, sizeof(coord), is_behind, &pc);
}

void sort_clockwise3 (int nump, coord cf[nump], coord n)
{
    if (!(nump >= 3)) qassert ("./../ibm-gcm-vof-test.h", 642, "nump >= 3");

    coord a = cf[0], b = cf[1];
    if (!n.x && !n.y && !n.z) {
        coord c = cf[2];
        n = face_normal(a, b, c);
    }
    normalize2(&n);

    coord u = (coord){b.x - a.x, b.y - a.y, b.z - a.z};
    coord v = cross_product(n, u);

    normalize2(&u); normalize2(&v);

    coord centroid = get_centroid(nump, cf);

    proj_coord cfp[nump];

    for (int i = 0; i < nump; ++i) {
        double px = (cf[i].x - centroid.x)*u.x +
                    (cf[i].y - centroid.y)*u.y +
                    (cf[i].z - centroid.z)*u.z;
        double py = (cf[i].x - centroid.x)*v.x +
                    (cf[i].y - centroid.y)*v.y +
                    (cf[i].z - centroid.z)*v.z;
        cfp[i].og = cf[i];
        cfp[i].x = px, cfp[i].y = py;
    }

    qsort(cfp, nump, sizeof(proj_coord), compare_projected);

    for (int i = 0; i < nump; ++i) {
        cf[i] = cfp[i].og;





    }



}

void triangulate_planes(int plcount, plane * planes)
{
    for (int i = 0; i < plcount; ++i) {

        if (!(planes[i].psize >= 3)) qassert ("./../ibm-gcm-vof-test.h", 690, "planes[i].psize >= 3");

        planes[i].tri = pmalloc ((planes[i].psize - 2) * sizeof(triangle),__func__,__FILE__,__LINE__);
        planes[i].tsize = planes[i].psize - 2;

        for (int j = 1, tricount = 0; j < planes[i].psize - 1; ++j) {
            if (!(tricount < (planes)[i].tsize)) qassert ("./../ibm-gcm-vof-test.h", 696, "tricount < (planes)[i].tsize");
            planes[i].tri[tricount] = (triangle){{planes[i].p[0], planes[i].p[j], planes[i].p[j+1]}};
            tricount++;
        }
    }
}

double tetrahedron_volume(triangle tri, coord pc)
{
    coord a = {tri.p[0].x - pc.x, tri.p[0].y - pc.y, tri.p[0].z - pc.z};
    coord b = {tri.p[1].x - pc.x, tri.p[1].y - pc.y, tri.p[1].z - pc.z};
    coord c = {tri.p[2].x - pc.x, tri.p[2].y - pc.y, tri.p[2].z - pc.z};

    return 1./6. * fabs((a.x*(b.y*c.z - c.y*b.z) +
                         a.y*(b.z*c.x - c.z*b.x) +
                         a.z*(b.x*c.y - c.x*b.y)));
}

double polyhedron_volume(int pcount, plane * planes, coord pc)
{
    double volume = 0;
    for (int i = 0; i < pcount; ++i)
        for (int j = 0; j < planes[i].tsize; ++j) {
            volume += tetrahedron_volume(planes[i].tri[j], pc);
        }

    return volume;
}

double rectangular_prism_volume (coord bc, coord tc)
{
    double l = tc.x - bc.x;
    double w = tc.y - bc.y;
    double h = tc.z - bc.z;

    return l*w*h;
}

int make_list_unique(coord** tp, int tsize, int sizes[tsize], coord* set[tsize],
                     plane plf, plane pls)
{
    coord unique[34];
    int ucount = 0;

    for (int i = 0; i < tsize; ++i) {
        for (int j = 0; j < sizes[i]; ++j) {
            double placement = region_check2(plf, pls, set[i][j]);
            if ((placement > 0 || fabs(placement) <= 1e-6) && set[i][j].x != 1e30f &&
                point_is_unique(ucount, unique, set[i][j])) {
                unique[ucount] = set[i][j];
                ucount++;
            }
        }
    }

    *tp = pmalloc (ucount * sizeof(coord),__func__,__FILE__,__LINE__);

    int ucount1 = 0;
    for (int i = 0; i < tsize; ++i) {
        for (int j = 0; j < sizes[i]; ++j) {
            double placement = region_check2(plf, pls, set[i][j]);
            if ((placement > 0 || fabs(placement) <= 1e-6) && set[i][j].x != 1e30f &&
                point_is_unique(ucount1, *tp, set[i][j])) {
                (*tp)[ucount1] = set[i][j];
                ucount1++;
            }
        }
    }

    return ucount;
}

int remove_invalid_points(int size, coord ps[size], plane fluid, plane solid, plane padv)
{
    int fcount = 0;
    for (int i = 0; i < size; ++i) {
        double placement = region_check2(fluid, solid, ps[i]);
        if ((placement >= 0 || fabs(placement) < 1e-6) && bounds_check(ps[i], padv.alpha))
            fcount++;
        else
            ps[i].x = 1e30f, ps[i].y = 1e30f, ps[i].z = 1e30f;
    }
    return fcount;
}

double fit_volume (double advVolume, coord ns, double alphas, double ufdt);
#line 889 "./../ibm-gcm-vof-test.h"
double polygon_area (int nump, coord cf[nump])
{
    double area = 0;
    for (int i = 0; i < nump; ++i) {
        int next = i + 1 < nump? i + 1: 0;
        area += cf[i].x*cf[next].y - cf[next].x*cf[i].y;
    }

    return fabs(area)/2.;
}

double rectangle_area (coord bp, coord tp)
{
    return (tp.x - bp.x) * (tp.y - bp.y);
}







double line_intersect (double alpha, coord n, double x, double y)
{
    double inter = 0;
    if (x == 1e30f && y != 1e30f)
        inter = alpha/n.x - (n.y/(n.x+1e-30))*y;
    else
        inter = alpha/n.y - (n.x/(n.y+1e-30))*x;
    return inter;
}







double immersed_area (double c, coord nf, double alphaf, coord ns, double alphas,
                      coord lhs, coord rhs, double advVolume, int print)
{
    if (lhs.x == rhs.x)
        return 0;


    coord lhst = {lhs.x,0.5}, rhsb = {rhs.x,-0.5};
    coord rect[4] = {lhs,rhsb,rhs,lhst};
    double areaTotal = polygon_area (4, rect);
    double areaLiquid = rectangle_fraction (ns, alphas, lhs, rhs);
#line 946 "./../ibm-gcm-vof-test.h"
    double cvy = line_intersect (alphas, ns, -0.5
#line 911
, 1e30f
#line 946
);



    double rhsx = 0;
    if (rhs.x < 0.5 && areaLiquid < 1 && advVolume) {
        cvy = ( cvy < (-0.5) ? (-0.5) : cvy > 0.5 ? 0.5 : cvy);
        rhsx = fit_volume (advVolume, ns, alphas, rhs.x);
        rhs.x = rhsx;
        rhsb.x = rhsx;
        coord rect0[4] = {lhs,rhsb,rhs,lhst};
        areaTotal = polygon_area (4, rect0);
        areaLiquid = rectangle_fraction (ns, alphas, lhs, rhs);
    }


    double areaAdv = 0;


    if (!advVolume)
        areaAdv = areaTotal*areaLiquid;
    else
        areaAdv = advVolume;
#line 981 "./../ibm-gcm-vof-test.h"
    coord pf[2], ps[2];
    for (int i = 0; i < 2; ++i)
        { {
            pf[i].x = 1e30f;
            ps[i].x = 1e30f;
        } 
#line 983
{
            pf[i].y = 1e30f;
            ps[i].y = 1e30f;
        }}

    int numpf = boundary_points(nf, alphaf, lhs, rhs, pf);
    int numps = boundary_points(ns, alphas, lhs, rhs, ps);


    coord pint = {1e30f,1e30f,1e30f};
    int numpi = interface_intersect (nf, alphaf, ns, alphas, lhs, rhs, &pint);




    coord poly[9];
    poly[0] = pf[0], poly[1] = pf[1], poly[2] = ps[0], poly[3] = ps[1], poly[4] = pint;
    poly[5] = lhs, poly[6] = rhs, poly[7] = lhst, poly[8]= rhsb;

    int nump = 0;
    for (int i = 0; i < 9; ++i) {
        double placement = region_check2((plane){nf, alphaf}, (plane){ns, alphas}, poly[i]);
        if ((placement >= 0 || fabs(placement) < 1e-11) && poly[i].x != 1e30f)
            nump++;
        else
            poly[i].x = 1e30f, poly[i].y = 1e30f;
    }

    if (print == 1) {
        fprintf(ferr, "||  pf1=(%g,%g) pf2(%g,%g) ps1=(%g,%g) ps2=(%g,%g) pint=(%g,%g)\n",
                        pf[0].x, pf[0].y, pf[1].x, pf[1].y, ps[0].x, ps[0].y, ps[1].x,
                        ps[1].y, pint.x, pint.y);

        fprintf(ferr, "|| p0=(%g,%g) p1=(%g,%g) p2=(%g,%g) p3=(%g,%g) p4=(%g,%g)"
                        "   p5=(%g,%g) p6=(%g,%g) p7=(%g,%g) p8=(%g,%g)\n",
                        poly[0].x, poly[0].y, poly[1].x, poly[1].y,poly[2].x, poly[2].y,
                        poly[3].x, poly[3].y, poly[4].x, poly[4].y, poly[5].x, poly[5].y,
                        poly[6].x, poly[6].y, poly[7].x, poly[7].y, poly[8].x, poly[8].y);

        fprintf(ferr, "||  lhs=(%g,%g) rhs=(%g,%g) lhst=(%g,%g) rhsb=(%g,%g)\n",
                        lhs.x, lhs.y, rhs.x, rhs.y, lhst.x, lhst.y, rhsb.x, rhsb.y);

        fprintf(ferr, "||  nf=(%g,%g) alphaf=%g ns=(%g,%g) alphas=%g c=%g %d %d %d %d\n",
                        nf.x, nf.y, alphaf, ns.x, ns.y, alphas, c, numpf, numps, numpi, nump);
    }

    if (nump == 0)
        return 0;

    coord cf[nump];
    int count = 0;
    for (int i = 0; i < 9; ++i)
        if (poly[i].x != 1e30f && count < nump) {
            cf[count] = poly[i];
            count++;
        }

    if (print == 1)
        for (int i = 0; i < nump; ++i)
            fprintf(ferr, "cf[%d] = (%g,%g)\n", i, cf[i].x, cf[i].y);


    sort_clockwise (nump, cf, print);


    double area = polygon_area (nump, cf);
#line 1066 "./../ibm-gcm-vof-test.h"
    double vf = ( (area/(areaAdv+1e-30)) < 0. ? 0. : (area/(areaAdv+1e-30)) > 1. ? 1. : (area/(areaAdv+1e-30)));
    return vf;
}
#line 1079 "./../ibm-gcm-vof-test.h"
     
double immersed_fraction (double c, coord nf, double alphaf, coord ns, double alphas,
                          coord lhs, coord rhs, double advVolume, int print)
{tracing("immersed_fraction","./../ibm-gcm-vof-test.h",1080);
    if (c <= 0)
        {end_tracing("immersed_fraction","./../ibm-gcm-vof-test.h",1084);return 0;}


    { double _ret= immersed_area(c, nf, alphaf, ns, alphas, lhs, rhs, advVolume, print);end_tracing("immersed_fraction","./../ibm-gcm-vof-test.h",1087);return _ret;}
#line 1099 "./../ibm-gcm-vof-test.h"
end_tracing("immersed_fraction","./../ibm-gcm-vof-test.h",1099);}
#line 1112 "./../ibm-gcm-vof-test.h"
typedef struct tripoint
{
    coord nf, ns;
    double alphaf, alphas;
    double f, fr, s;

} tripoint;


tripoint fill_tripoint (double fr, coord nf, double alphaf, coord ns, double alphas,
                        double f, double s)
{
    tripoint tcell = {nf, ns, alphaf, alphas, f, fr, s};
    return tcell;
}


int rsolver_bisection (double* a, double amin, double amax, const void* data, double (*func)(const void*, double),
                       double tolerance, int maxitr, int print)
{
    double errmax = (*func)(data, amax);
    if (fabs(errmax) < tolerance) {
        *a = amax;
        return 0;
    }

    double b = 0, error = 1e30f;
    int itr = 0;
    while (fabs(error) > tolerance && itr < maxitr) {
        b = (amin + amax)/2.;
        error = (*func)(data, b);
        if (( (int)(error > 0 ? 1 : error < 0 ? -1 : 0)) == ( (int)(errmax > 0 ? 1 : errmax < 0 ? -1 : 0))) {
            amax = b;
            errmax = error;
        }
        else
            amin = b;
        itr++;
    }

    if (itr == maxitr) {
        fprintf(ferr, "WARNING: alpha  solver does not converge after"
                        " maximum iteration (%d), error = %g\n", maxitr, error);
    }
    *a = b;
    return itr;
}


int rsolver_brent (double* result, double a, double b, const void* data, double (*func)(const void*, double),
                   double tolerance, int maxitr, int print, int warning)
{
    double fa = (*func)(data, a);
    if (fabs(fa) < tolerance) {
        *result = a;
        return 0;
    }

    double fb = (*func)(data, b);
    if (fabs(fb) < tolerance) {
        *result = b;
        return 0;
    }

    if (fa * fb >= 0) {
        if (warning)
            fprintf(ferr, "WARNING: range in Brent's solver does not contain root!\n");






        return -1;
    }

    if (fabs(fa) < fabs(fb)) {
        do { double _tmp_ = a; a = b; b = _tmp_; } while(false);
        do { double _tmp_ = fa; fa = fb; fb = _tmp_; } while(false);
    }

    double c = a, fc = fa, d = b - a;
    int iter = 0, mflag = 1;

    while (fabs(b - a) > tolerance && fabs(fb) > tolerance && fabs(fa) > tolerance && iter < maxitr) {

        double s;
        if (!approx_equal_double(fa, fc
#line 142 "./../ibm-gcm.h"
, 1e-11
#line 1199 "./../ibm-gcm-vof-test.h"
) && !approx_equal_double(fb, fc
#line 142 "./../ibm-gcm.h"
, 1e-11
#line 1199 "./../ibm-gcm-vof-test.h"
)) {
            s = (a*fb*fc)/((fa-fb)*(fa-fc)) +
                (b*fa*fc)/((fb-fa)*(fb-fc)) +
                (c*fa*fb)/((fc-fa)*(fc-fb));
        }
        else
            s = b - fb*(b-a)/(fb-fa + 1e-30);

        int cond1 = s <= fmin(a, b) || s >= fmax(a, b);

        int cond2 = mflag && fabs(s - b) >= fabs(b-c)*0.5;
        int cond3 = !mflag && fabs(s - b) >= fabs(c-d)*0.5;
        int cond4 = mflag && fabs(b - c) < tolerance;
        int cond5 = !mflag && fabs(c - d) < tolerance;
        if (cond1 || cond2 || cond3 || cond4 || cond5) {
            s = (a + b) * 0.5;
            mflag = 1;
        }
        else
            mflag = 0;

        double fs = (*func)(data, s);
        d = c;
        c = b; fc = fb;

        if (fa*fs < 0)
            b = s, fb = fs;
        else
            a = s, fa = fs;

        if (fabs(fa) < fabs(fb)) {
            do { double _tmp_ = a; a = b; b = _tmp_; } while(false);
            do { double _tmp_ = fa; fa = fb; fb = _tmp_; } while(false);
        }
        if (fabs(fb) < tolerance || fabs(fa) < tolerance)
            break;

        ++iter;
    }

    if (iter == maxitr && warning)
        fprintf(ferr, "WARNING: alpha  solver does not converge after"
                        " maximum iteration (%d), error = %g\n", maxitr, fb);

    *result = (fabs(fa) < fabs(fb)) ? a : b;
    return iter;
}






double fit_volume_error (const void* data, double newx)
{
    const tripoint tcell = (*(tripoint*)data);

    static const coord lhs = {-0.5,-0.5,-0.5};
    coord rhs = {newx, 0.5, 0.5};


    double vtotal = rectangle_area (lhs, rhs);



    double vfrac = rectangle_fraction (tcell.ns, tcell.alphas, lhs, rhs);
    double vreal = vtotal * vfrac;







    return (vreal - tcell.fr);
}


double fit_volume (double advVolume, coord ns, double alphas, double ufdt)
{
    if (advVolume < 1e-9)
        return ufdt;

    double oldx = ufdt;

    tripoint tcell;
    tcell.ns = ns; tcell.alphas = alphas; tcell.fr = advVolume;

    double xmin = -0.5, xmax = 0.5, newx = 1e30f;

    int maxitr = 30;
    int itr = rsolver_brent (&newx, xmin, xmax, &tcell, fit_volume_error
, 1e-14, maxitr
#line 1162
, 0
#line 1291
, 0);


    bool smallcell = false;
    if (itr == -1) {
        smallcell = true;
        tcell.fr = rectangle_fraction (tcell.ns, tcell.alphas,
                    (coord){-0.5,-0.5,-0.5}, (coord){0.5,0.5,0.5});
        itr = rsolver_brent (&newx, xmin, xmax, &tcell, fit_volume_error
, 1e-14, maxitr
#line 1162
, 0, 1
#line 1300
);
    }
#line 1312 "./../ibm-gcm-vof-test.h"
    (void) smallcell;
    if (itr == maxitr || (itr == 0 && newx == 1e30f)) {
        fprintf(ferr, "WARNING: area root solver didn't converge after %d iterations\n", itr);
        return oldx;
    }

    return newx;
}


double get_real_error (const void* data, double alpha)
{
    tripoint tcell = (*(tripoint*)data);

    static const coord lhs = {-0.5,-0.5,-0.5}, rhs = {0.5,0.5,0.5};

    double fa = rectangle_fraction (tcell.nf, alpha, lhs, rhs);
    double frcalc = tcell.s*immersed_fraction (fa, tcell.nf, alpha, tcell.ns
,                                              tcell.alphas, lhs, rhs
#line 1081
, 0
#line 1330
, 0);
#line 1339 "./../ibm-gcm-vof-test.h"
    return frcalc - ( (tcell.fr) < 0 ? 0 : (tcell.fr) > (tcell.s) ? (tcell.s) : (tcell.fr));
}


extern scalar f;


double ghost_alpha (const tripoint tcell, double alphaMin, double alphaMax, int * numitr)
{
    static const coord lhs = {-0.5,-0.5,-0.5}, rhs = {0.5,0.5,0.5};

    coord ip[2];
    int dp = facets (tcell.ns, tcell.alphas, ip);




    double alphaArray[4];
    double frArray[4];

    for (int i = 0; i < dp; ++i) {
        alphaArray[i] = 0;
        
            alphaArray[i] += tcell.nf.x*ip[i].x;            alphaArray[i] += tcell.nf.y*ip[i].y;
        double fi = line_area(tcell.nf.x, tcell.nf.y, alphaArray[i]);
        frArray[i] = tcell.s*immersed_fraction (fi, tcell.nf, alphaArray[i]
,                                                tcell.ns, tcell.alphas, lhs, rhs
#line 1081
, 0, 0
#line 1365
);
    }

    for (int i = 0; i < dp; ++i) {

        if (frArray[i] >= tcell.fr - 1e-7 && frArray[i] <= tcell.fr + 1e-7) {





            return alphaArray[i];
        }
    }


    double alpha = 0;
    int itr = rsolver_brent (&alpha, alphaMin, alphaMax, &tcell, get_real_error, 1e-12
#line 1162
, 50, 0, 1
#line 1382
);

    if (numitr)
        *numitr = itr;

    return alpha;
}


     
double immersed_alpha (double f, double ibm, coord nf, double alphaf, coord ns, double alphas,
                       double freal, double tolerance, int * numitr)
{tracing("immersed_alpha","./../ibm-gcm-vof-test.h",1392);
    if ((freal <= 1e-11 || freal >= 1-1e-11) && !nf.x && !nf.y && !nf.z)
        {end_tracing("immersed_alpha","./../ibm-gcm-vof-test.h",1396);return alphaf;}



    double alphaMin = -0.6, alphaMax = 0.6, alpha = 0;

    double f0 = ( f < 0. ? 0. : f > 1. ? 1. : f);

    double ibm0 = ibm;
    freal = ( freal < 0. ? 0. : freal > ibm0 ? ibm0 : freal);
    const tripoint tcell = fill_tripoint (freal, nf, alphaf, ns, alphas, f0, ibm0);

    int maxitr = 50;






    if (!nf.x && !nf.y && !nf.z)
        fprintf(ferr, "WARNING: all components of nf are 0 in alpha solver!\n");



      if ((nf.x || nf.y || nf.z) && (freal >= ibm0 - 1e-11 || freal <= 0 + 1e-11)) {
        { double _ret= ghost_alpha (tcell, alphaMin, alphaMax, numitr);end_tracing("immersed_alpha","./../ibm-gcm-vof-test.h",1421);return _ret;}
    }
#line 1431 "./../ibm-gcm-vof-test.h"
    int itr = rsolver_brent (&alpha, alphaMin, alphaMax, &tcell, get_real_error
, 1e-12, maxitr
#line 1162
, 0, 1
#line 1432
);
    if (numitr)
        *numitr = itr;

    {end_tracing("immersed_alpha","./../ibm-gcm-vof-test.h",1436);return alpha;}
end_tracing("immersed_alpha","./../ibm-gcm-vof-test.h",1437);}







void real_fluid (scalar f, scalar fr, vector nf, scalar alphaf, vector ns, scalar alphas)
{    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1447, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1447 "./../ibm-gcm-vof-test.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);{
            {_stencil_val(f,0,0,0);_stencil_val(nf.x,0,0,0); _stencil_val(nf.y,0,0,0);; _stencil_val(alphaf,0,0,0);
_stencil_val(ns.x,0,0,0); _stencil_val(ns.y,0,0,0);; _stencil_val(alphas,0,0,0); 

_stencil_val(ibm,0,0,0);
#line 1449
_stencil_val_a(fr,0,0,0);    
                                           
                                            
                                              }
            
{_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val_a(fr,0,0,0);                }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1447 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1447 "./../ibm-gcm-vof-test.h"
{
        if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7) && (val(f,0,0,0) > 0+1e-7 && val(f,0,0,0) < 1-1e-7))
            val(fr,0,0,0) = immersed_fraction (val(f,0,0,0), (coord){val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension}, val(alphaf,0,0,0)
,                                           (coord){val(ns.x,0,0,0), val(ns.y,0,0,0), _val_higher_dimension}, val(alphas,0,0,0)
,                                           (coord){-0.5,-0.5,-0.5}
,                                           (coord){ 0.5, 0.5, 0.5}
#line 1081
, 0, 0
#line 1452
) * val(ibm,0,0,0);
        else
            val(fr,0,0,0) = ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0))) * val(ibm,0,0,0);
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}

#line 1456 "./../ibm-gcm-vof-test.h"
}
#line 1469 "./../ibm-gcm-vof-test.h"
bool is_interior_cell (Point point, scalar ibm, scalar c, scalar cr)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1479 "./../ibm-gcm-vof-test.h"
    if (val(ibm,0,0,0) <= 0 || val(ibm,0,0,0) >= 1 || val(cr,0,0,0) == 0)
        return false;
  
#line 1493 "./../ibm-gcm-vof-test.h"
    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 1493 "./../ibm-gcm-vof-test.h"
{







        if (val(ibm,0,0,0) && fabs(val(cr,0,0,0) - val(ibm,0,0,0)) > 1e-7) {
            return false;
        }
    }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }

    
#line 1506 "./../ibm-gcm-vof-test.h"
return true;


}
#line 1469 "./../ibm-gcm-vof-test.h"
static void _stencil_is_interior_cell (Point point, scalar ibm,_stencil_undefined * c, scalar cr)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1479 "./../ibm-gcm-vof-test.h"
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(cr,0,0,0);
   
        
#line 1479 "./../ibm-gcm-vof-test.h"
             
#line 1493 "./../ibm-gcm-vof-test.h"
    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 1493 "./../ibm-gcm-vof-test.h"
{







_stencil_val(ibm,0,0,0);_stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0);    


}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }

    
#line 1506 "./../ibm-gcm-vof-test.h"
return ;


}
#line 1525 "./../ibm-gcm-vof-test.h"
double avgitr = 0;
int g_count = 0;

     
void immersed_reconstruction (scalar c, scalar cr, vector nf, scalar alphaf,
                              vector ns, scalar alphas, scalar id, int * fix)
{tracing("immersed_reconstruction","./../ibm-gcm-vof-test.h",1529);
    double error_sum = 0;
    int itrsum = 0, count = 0;    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1534, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1534 "./../ibm-gcm-vof-test.h"
{
_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);        _stencil_val_a(c,0,0,0);
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(c,0,0,0); {






_stencil_val(cr,0,0,0);{ { 
_stencil_val_a(c,0,0,0);                _stencil_val_a(cr,0,0,0);   

                
            } 
{_stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(c,0,0,0);{ { 
_stencil_val(ibm,0,0,0);                _stencil_val_a(cr,0,0,0); 

                
            } 
{_stencil_is_interior_cell(point, ibm, NULL, cr); { 
_stencil_val(ibm,0,0,0);                _stencil_val_a(cr,0,0,0); 
                _stencil_val_a(c,0,0,0);  
                
            } }}            }}

_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(cr,0,0,0);            _stencil_val_a(cr,0,0,0);

; _stencil_val(nf.y,0,0,0);_stencil_val(nf.x,0,0,0);; _stencil_val(ns.y,0,0,0);_stencil_val(ns.x,0,0,0); 

{
                _stencil_val_a(c,0,0,0); 
_stencil_mycs (point, c);            
}            








_stencil_val(ibm,0,0,0); 
#line 1574
_stencil_val(alphas,0,0,0); _stencil_val(alphaf,0,0,0);_stencil_val(c,0,0,0);
#line 1590
_stencil_val(cr,0,0,0); 
#line 1590 "./../ibm-gcm-vof-test.h"
                  

_stencil_val(cr,0,0,0);             





_stencil_val(cr,0,0,0); _stencil_val(alphas,0,0,0); _stencil_val(alphaf,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(c,0,0,0);





            _stencil_val_a(c,0,0,0);    
            _stencil_val_a(alphaf,0,0,0);   
#line 1614 "./../ibm-gcm-vof-test.h"
             
            
        }
_stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0); { 
_stencil_val_a(c,0,0,0);            _stencil_val_a(cr,0,0,0);   

            
        }    


}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:error_sum) reduction(+:itrsum) reduction(+:count)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1534 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1534 "./../ibm-gcm-vof-test.h"
{
        val(c,0,0,0) = ( (val(c,0,0,0)) < 0 ? 0 : (val(c,0,0,0)) > 1 ? 1 : (val(c,0,0,0)));
        if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7) && val(c,0,0,0)) {






            if (val(cr,0,0,0) < 1e-12) {
                val(cr,0,0,0) = val(c,0,0,0) = 0;

                continue;
            }
            else if (approx_equal_double (val(cr,0,0,0), val(ibm,0,0,0)
#line 142 "./../ibm-gcm.h"
, 1e-11
#line 1548 "./../ibm-gcm-vof-test.h"
) && val(c,0,0,0) >= 1.) {
                val(cr,0,0,0) = val(ibm,0,0,0);

                continue;
            }
            else if (is_interior_cell(point, ibm, c, cr)) {
                val(cr,0,0,0) = val(ibm,0,0,0);
                val(c,0,0,0) = 1;
                continue;
            }

            val(cr,0,0,0) = ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm,0,0,0)) ? (val(ibm,0,0,0)) : (val(cr,0,0,0)));

            coord nsolid = {val(ns.x,0,0,0), val(ns.y,0,0,0), _val_higher_dimension}, nfluid = {val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension};

            if (!nfluid.x && !nfluid.y && !nfluid.z) {
                val(c,0,0,0) = 0.9999;
                nfluid = mycs (point, c);
            }







            double freal = immersed_fraction (val(c,0,0,0), nfluid, val(alphaf,0,0,0), nsolid, val(alphas,0,0,0)
,                                              (coord){-0.5,-0.5,-0.5}, (coord){0.5,0.5,0.5},0
#line 1081
, 0
#line 1575
)*val(ibm,0,0,0);
#line 1590 "./../ibm-gcm-vof-test.h"
            error_sum += fabs(val(cr,0,0,0) - freal) * pow(Delta, 2);

            if (approx_equal_double (val(cr,0,0,0), freal, 1e-10)) {

                continue;
            }

            int iter = 0;
            double alpha = immersed_alpha (val(c,0,0,0), val(ibm,0,0,0), nfluid, val(alphaf,0,0,0), nsolid, val(alphas,0,0,0), val(cr,0,0,0)
#line 1393
, 1e-9
#line 1598
, &iter);





            val(c,0,0,0) = line_area(nfluid.x, nfluid.y, alpha);
            val(alphaf,0,0,0) = alpha;
#line 1614 "./../ibm-gcm-vof-test.h"
            itrsum += iter;
            count++;
        }
        if (val(cr,0,0,0) < 1e-12 && val(ibm,0,0,0) == 1) {
            val(cr,0,0,0) = val(c,0,0,0) = 0;

            continue;
        }


    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1624 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&count,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&itrsum,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&error_sum,MPI_DOUBLE,MPI_SUM,1);}

    boundary_internal ((scalar *)((scalar[]){id,{-1}}), "./../ibm-gcm-vof-test.h", 1626);





    avgitr = ((double)itrsum)/(count+1e-30);
    g_count = count;

    if (fix)
        *fix = error_sum > 1e-10? 1: 0;
end_tracing("immersed_reconstruction","./../ibm-gcm-vof-test.h",1637);}



     
double immersed_alpha_temp (double f, double ibm, coord nf, double alphaf, coord ns, double alphas,
                            double freal, double tolerance, int * numitr)
{tracing("immersed_alpha_temp","./../ibm-gcm-vof-test.h",1642);
    if ((freal <= 1e-11 || freal >= 1-1e-11) && !nf.x && !nf.y && !nf.z)
        {end_tracing("immersed_alpha_temp","./../ibm-gcm-vof-test.h",1646);return alphaf;}



    double alphaMin = -0.6, alphaMax = 0.6, alpha = 0;

    double f0 = ( f < 0. ? 0. : f > 1. ? 1. : f);
    double ibm0 = ibm;
    freal = ( freal < 0. ? 0. : freal > ibm0 ? ibm0 : freal);
    const tripoint tcell = fill_tripoint (freal, nf, alphaf, ns, alphas, f0, ibm0);

    int maxitr = 40;






    if (!nf.x && !nf.y && !nf.z)
        fprintf(ferr, "WARNING: all components of nf are 0 in alpha solver!\n");




      if ((nf.x || nf.y || nf.z) && (freal <= 0 + 1e-11 || freal >= ibm0 - 1e-11)) {
        { double _ret= ghost_alpha (tcell, alphaMin, alphaMax, numitr);end_tracing("immersed_alpha_temp","./../ibm-gcm-vof-test.h",1671);return _ret;}
    }
#line 1681 "./../ibm-gcm-vof-test.h"
    int itr = rsolver_brent (&alpha, alphaMin, alphaMax, &tcell, get_real_error
#line 1161
, 
1e-9
#line 1681
, maxitr
#line 1162
, 0, 1
#line 1681
);
    if (numitr)
        *numitr = itr;

    {end_tracing("immersed_alpha_temp","./../ibm-gcm-vof-test.h",1685);return alpha;}
end_tracing("immersed_alpha_temp","./../ibm-gcm-vof-test.h",1686);}


     
void immersed_reconstruction_temp (scalar c, scalar cr, vector nf, scalar alphaf,
                                   vector ns, scalar alphas, int * fix)
{tracing("immersed_reconstruction_temp","./../ibm-gcm-vof-test.h",1690);




    double error_sum = 0;
    int itrsum = 0, count = 0;    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1699, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1699 "./../ibm-gcm-vof-test.h"
{
_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);        _stencil_val_a(c,0,0,0);
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(c,0,0,0); {
#line 1713
_stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(c,0,0,0); { 
_stencil_val(ibm,0,0,0);                _stencil_val_a(cr,0,0,0); 
                
            }

_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(cr,0,0,0);
#line 1713 "./../ibm-gcm-vof-test.h"
                 

            


_stencil_val_a(cr,0,0,0);

; _stencil_val(nf.y,0,0,0);_stencil_val(nf.x,0,0,0);; _stencil_val(ns.y,0,0,0);_stencil_val(ns.x,0,0,0); 

{
                _stencil_val_a(c,0,0,0); 
_stencil_mycs (point, c);            
}            








_stencil_val(ibm,0,0,0); 
#line 1733
_stencil_val(alphas,0,0,0); _stencil_val(alphaf,0,0,0);_stencil_val(c,0,0,0);


_stencil_val(cr,0,0,0); 

                  _stencil_val(cr,0,0,0);             




_stencil_val(cr,0,0,0); _stencil_val(alphas,0,0,0); _stencil_val(alphaf,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(c,0,0,0);





            _stencil_val_a(c,0,0,0);     
#line 1758 "./../ibm-gcm-vof-test.h"
             
            
        }    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:error_sum) reduction(+:itrsum) reduction(+:count)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1699 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1699 "./../ibm-gcm-vof-test.h"
{
        val(c,0,0,0) = ( (val(c,0,0,0)) < 0 ? 0 : (val(c,0,0,0)) > 1 ? 1 : (val(c,0,0,0)));
        if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7) && val(c,0,0,0)) {
#line 1713 "./../ibm-gcm-vof-test.h"
            if (approx_equal_double (val(cr,0,0,0), val(ibm,0,0,0)
#line 142 "./../ibm-gcm.h"
, 1e-11
#line 1713 "./../ibm-gcm-vof-test.h"
) && val(c,0,0,0) >= 1.) {
                val(cr,0,0,0) = val(ibm,0,0,0);
                continue;
            }

            val(cr,0,0,0) = ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm,0,0,0)) ? (val(ibm,0,0,0)) : (val(cr,0,0,0)));

            coord nsolid = {val(ns.x,0,0,0), val(ns.y,0,0,0), _val_higher_dimension}, nfluid = {val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension};

            if (!nfluid.x && !nfluid.y && !nfluid.z) {
                val(c,0,0,0) = 0.9999;
                nfluid = mycs (point, c);
            }







            double freal = immersed_fraction (val(c,0,0,0), nfluid, val(alphaf,0,0,0), nsolid, val(alphas,0,0,0)
,                                              (coord){-0.5,-0.5,-0.5}, (coord){0.5,0.5,0.5},0
#line 1081
, 0
#line 1734
)*val(ibm,0,0,0);

            error_sum += fabs(val(cr,0,0,0) - freal) * pow(Delta, 2);

           if (approx_equal_double (val(cr,0,0,0), freal, 1e-10)) {
                continue;
           }

            int iter = 0;
            double alpha = immersed_alpha_temp (val(c,0,0,0), val(ibm,0,0,0), nfluid, val(alphaf,0,0,0), nsolid, val(alphas,0,0,0), val(cr,0,0,0)
#line 1643
, 1e-9
#line 1743
, &iter);





            val(c,0,0,0) = line_area(nfluid.x, nfluid.y, alpha);
#line 1758 "./../ibm-gcm-vof-test.h"
            itrsum += iter;
            count++;
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1761 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&count,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&itrsum,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&error_sum,MPI_DOUBLE,MPI_SUM,1);}





    avgitr = ((double)itrsum)/(count+1e-30);
    g_count = count;

    if (fix)
        *fix = error_sum > 1e-10? 1: 0;
end_tracing("immersed_reconstruction_temp","./../ibm-gcm-vof-test.h",1772);}







double real_volume (scalar f)
{
    vector  nf=new_vector("nf"),  ns=new_vector("ns");
    scalar  alphaf=new_scalar("alphaf"),  alphas=new_scalar("alphas");

    reconstruction (f, nf, alphaf);
    reconstruction (ibm, ns, alphas);

    double volume = 0.;
    if(!is_constant(cm)){    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1789, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1789 "./../ibm-gcm-vof-test.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);{
            {_stencil_val(f,0,0,0);_stencil_val(nf.x,0,0,0); _stencil_val(nf.y,0,0,0);; _stencil_val(alphaf,0,0,0);
_stencil_val(ns.x,0,0,0); _stencil_val(ns.y,0,0,0);; _stencil_val(alphas,0,0,0);

_stencil_val(ibm,0,0,0);_stencil_val(cm,0,0,0);                                                  }
            
{ _stencil_val(f,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(cm,0,0,0); }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:volume)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1789 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1789 "./../ibm-gcm-vof-test.h"
{
        if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7) && (val(f,0,0,0) > 0+1e-7 && val(f,0,0,0) < 1-1e-7))
            volume += immersed_fraction (val(f,0,0,0), (coord){val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension}, val(alphaf,0,0,0)
,                                              (coord){val(ns.x,0,0,0), val(ns.y,0,0,0), _val_higher_dimension}, val(alphas,0,0,0)
,                                              (coord){-0.5, -0.5, -0.5}
,                                              (coord){0.5, 0.5, 0.5}, 0
#line 1081
, 0
#line 1794
) * (pow(Delta,2)*val(ibm,0,0,0)*val(cm,0,0,0));
        else
            volume += val(f,0,0,0)*(pow(Delta,2)*val(ibm,0,0,0)*val(cm,0,0,0));
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1797 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1789, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1789 "./../ibm-gcm-vof-test.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);{
            {_stencil_val(f,0,0,0);_stencil_val(nf.x,0,0,0); _stencil_val(nf.y,0,0,0);; _stencil_val(alphaf,0,0,0);
_stencil_val(ns.x,0,0,0); _stencil_val(ns.y,0,0,0);; _stencil_val(alphas,0,0,0);

_stencil_val(ibm,0,0,0);;                                                  }
            
{ _stencil_val(f,0,0,0);_stencil_val(ibm,0,0,0);; }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:volume)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1789 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1789 "./../ibm-gcm-vof-test.h"
{
        if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7) && (val(f,0,0,0) > 0+1e-7 && val(f,0,0,0) < 1-1e-7))
            volume += immersed_fraction (val(f,0,0,0), (coord){val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension}, val(alphaf,0,0,0)
,                                              (coord){val(ns.x,0,0,0), val(ns.y,0,0,0), _val_higher_dimension}, val(alphas,0,0,0)
,                                              (coord){-0.5, -0.5, -0.5}
,                                              (coord){0.5, 0.5, 0.5}, 0
#line 1081
, 0
#line 1794
) * (pow(Delta,2)*val(ibm,0,0,0)*_const_cm);
        else
            volume += val(f,0,0,0)*(pow(Delta,2)*val(ibm,0,0,0)*_const_cm);
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1797 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);}}

    {delete((scalar*)((scalar[]){alphas,alphaf,ns.x,ns.y,nf.x,nf.y,{-1}}));return volume;}delete((scalar*)((scalar[]){alphas,alphaf,ns.x,ns.y,nf.x,nf.y,{-1}}));
}



double get_contact_angle (scalar f, scalar ibm)
{
    vector  nf=new_vector("nf"),  ns=new_vector("ns");
    scalar  alphaf=new_scalar("alphaf"),  alphas=new_scalar("alphas");

    reconstruction (f, nf, alphaf);
    reconstruction (ibm, ns, alphas);

    scalar  fr_temp=new_scalar("fr_temp");
    real_fluid (f, fr_temp, nf, alphaf, ns, alphas);

    double theta = 0;
    int count = 0;    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1817, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1817 "./../ibm-gcm-vof-test.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,0,0); _stencil_val(fr_temp,0,0,0); {      
             _stencil_val(ns.y,0,0,0);_stencil_val(ns.x,0,0,0); _stencil_val(nf.y,0,0,0);_stencil_val(nf.x,0,0,0);
_stencil_is_triple_point (point,NULL ,NULL ); {   
                _stencil_val(ns.y,0,0,0); _stencil_val(nf.y,0,0,0);_stencil_val(ns.x,0,0,0); _stencil_val(nf.x,0,0,0);             
                _stencil_val(ns.y,0,0,0);_stencil_val(ns.y,0,0,0);_stencil_val(ns.x,0,0,0);_stencil_val(ns.x,0,0,0);_stencil_val(nf.y,0,0,0);_stencil_val(nf.y,0,0,0);_stencil_val(nf.x,0,0,0);_stencil_val(nf.x,0,0,0); 
                  
                
            }        
}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:theta) reduction(+:count)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1817 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1817 "./../ibm-gcm-vof-test.h"
{
        if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7) && (val(f,0,0,0) > 0+1e-7 && val(f,0,0,0) < 1-1e-7) && val(fr_temp,0,0,0)) {
            coord nf_temp = {val(nf.x,0,0,0), val(nf.y,0,0,0)}, ns_temp = {val(ns.x,0,0,0), val(ns.y,0,0,0)};
            if (is_triple_point (point, nf_temp, ns_temp)) {
                double num = val(nf.x,0,0,0)*val(ns.x,0,0,0) + val(nf.y,0,0,0)*val(ns.y,0,0,0);
                double den = sqrt(( (val(nf.x,0,0,0))*(val(nf.x,0,0,0))) + ( (val(nf.y,0,0,0))*(val(nf.y,0,0,0)))) * sqrt(( (val(ns.x,0,0,0))*(val(ns.x,0,0,0))) + ( (val(ns.y,0,0,0))*(val(ns.y,0,0,0))));
                theta += acos (num/den);
                count++;
            }
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1827 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&count,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&theta,MPI_DOUBLE,MPI_SUM,1);}

    if (count > 0)
        { double _ret= (theta / count)*180./3.14159265358979;delete((scalar*)((scalar[]){fr_temp,alphas,alphaf,ns.x,ns.y,nf.x,nf.y,{-1}}));return _ret;}
    else
        {delete((scalar*)((scalar[]){fr_temp,alphas,alphaf,ns.x,ns.y,nf.x,nf.y,{-1}}));return 0;}delete((scalar*)((scalar[]){fr_temp,alphas,alphaf,ns.x,ns.y,nf.x,nf.y,{-1}}));
}
#line 1848 "./../ibm-gcm-vof-test.h"
double redistribute_volume (scalar c, scalar cr, const scalar ibm)
{


    double verror = 0;
    int icells = 0;
    if(!is_constant(cm)){    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1854, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1854 "./../ibm-gcm-vof-test.h"
{
_stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0);{ {
_stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(cm,0,0,0); 
                _stencil_val(ibm,0,0,0);            _stencil_val_a(cr,0,0,0); 
            _stencil_val_a(c,0,0,0);  
        } 
{_stencil_val(cr,0,0,0); { 
_stencil_val(cr,0,0,0);_stencil_val(cm,0,0,0);
               _stencil_val_a(cr,0,0,0);            _stencil_val_a(c,0,0,0);   
        }   }}







_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); _stencil_val(ibm,0,0,0);    

}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (+:verror) reduction (+:icells)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1854 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1854 "./../ibm-gcm-vof-test.h"
{
        if (val(cr,0,0,0) > val(ibm,0,0,0)) {
            verror += (val(cr,0,0,0) - val(ibm,0,0,0))*(( Delta*Delta)*val(cm,0,0,0));
            val(cr,0,0,0) = val(ibm,0,0,0);
            val(c,0,0,0) = 1;
        }
        else if (val(cr,0,0,0) < 0) {
            verror += val(cr,0,0,0)*(( Delta*Delta)*val(cm,0,0,0));
            val(c,0,0,0) = val(cr,0,0,0) = 0;
        }







        if ((val(c,0,0,0) > 0+1e-7 && val(c,0,0,0) < 1-1e-7) && val(ibm,0,0,0) >= 1)
            icells++;
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1873 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&icells,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&verror,MPI_DOUBLE,MPI_SUM,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1854, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1854 "./../ibm-gcm-vof-test.h"
{
_stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0);{ {
_stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0);; 
                _stencil_val(ibm,0,0,0);            _stencil_val_a(cr,0,0,0); 
            _stencil_val_a(c,0,0,0);  
        } 
{_stencil_val(cr,0,0,0); { 
_stencil_val(cr,0,0,0);;
               _stencil_val_a(cr,0,0,0);            _stencil_val_a(c,0,0,0);   
        }   }}







_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); _stencil_val(ibm,0,0,0);    

}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (+:verror) reduction (+:icells)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1854 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1854 "./../ibm-gcm-vof-test.h"
{
        if (val(cr,0,0,0) > val(ibm,0,0,0)) {
            verror += (val(cr,0,0,0) - val(ibm,0,0,0))*(( Delta*Delta)*_const_cm);
            val(cr,0,0,0) = val(ibm,0,0,0);
            val(c,0,0,0) = 1;
        }
        else if (val(cr,0,0,0) < 0) {
            verror += val(cr,0,0,0)*(( Delta*Delta)*_const_cm);
            val(c,0,0,0) = val(cr,0,0,0) = 0;
        }







        if ((val(c,0,0,0) > 0+1e-7 && val(c,0,0,0) < 1-1e-7) && val(ibm,0,0,0) >= 1)
            icells++;
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1873 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&icells,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&verror,MPI_DOUBLE,MPI_SUM,1);}}

    if (verror == 0) return verror;

    boundary_internal ((scalar *)((scalar[]){cr,{-1}}), "./../ibm-gcm-vof-test.h", 1877);


    vector  id=new_vector("id");

    int count = 0, overfill = 0;

    if(!is_constant(cm)){    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1884, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1884 "./../ibm-gcm-vof-test.h"
{
_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); _stencil_val(ibm,0,0,0);{ {


_stencil_val(cr,0,0,0);_stencil_val(cm,0,0,0); _stencil_val(ibm,0,0,0);{ {    
                 

                


                
                for (int i = -1; i <= 1; i += 2)
                    {_stencil_val(cr,i,0,0);_stencil_val(cm,0,0,0); _stencil_val(ibm,i,0,0); _stencil_val(ibm,i,0,0);
                        {_stencil_val_a(id.x,0,0,0);     }      }
                   


for (int j = -1; j <= 1; j += 2)
                       {_stencil_val(cr,0,j,0);_stencil_val(cm,0,j,0); _stencil_val(ibm,0,j,0); _stencil_val(ibm,0,j,0);
                           {_stencil_val_a(id.y,0,0,0);     }     }


                  
#line 1912 "./../ibm-gcm-vof-test.h"
                  
                    
            } 
{

_stencil_val(cm,0,0,0);                _stencil_val_r(cr,0,0,0);
_stencil_val(cm,0,0,0);                _stencil_val_r(c,0,0,0);   
            }}        
} 
{
            
                {_stencil_val_a(id.x,0,0,0);  }                {_stencil_val_a(id.y,0,0,0);  }
        }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:overfill) reduction(+:count)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1884 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1884 "./../ibm-gcm-vof-test.h"
{
        if ((val(c,0,0,0) > 0+1e-7 && val(c,0,0,0) < 1-1e-7) && val(ibm,0,0,0) >= 1) {


            if (val(cr,0,0,0) + (verror/(icells*(( Delta*Delta)*val(cm,0,0,0)))) > val(ibm,0,0,0)) {
                overfill = 1;

                count++;


                bool done = false;
                for (int i = -1; i <= 1; i += 2)
                    if (val(cr,i,0,0) + 2*(verror/(icells*(( Delta*Delta)*val(cm,0,0,0)))) < val(ibm,i,0,0) && val(ibm,i,0,0))
                        val(id.x,0,0,0) = i, done = true;


                if (!done)
                   for (int j = -1; j <= 1; j += 2)
                       if (val(cr,0,j,0) + 2*(verror/(pow(Delta,2)*val(cm,0,j,0)*icells)) < val(ibm,0,j,0) && val(ibm,0,j,0))
                           val(id.y,0,0,0) = j, done = true;
#line 1912 "./../ibm-gcm-vof-test.h"
                if (!done)
                    fprintf (ferr, "WARNING: could not fill cell with volume error!\n");
            }
            else {

                val(cr,0,0,0) += verror/(icells*(( Delta*Delta)*val(cm,0,0,0)));
                val(c,0,0,0) += verror/(icells*(( Delta*Delta)*val(cm,0,0,0)));
            }
        }
        else {
            
                val(id.x,0,0,0) = 0;                val(id.y,0,0,0) = 0;
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1925 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&count,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&overfill,MPI_INT,MPI_MAX,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1884, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1884 "./../ibm-gcm-vof-test.h"
{
_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); _stencil_val(ibm,0,0,0);{ {


_stencil_val(cr,0,0,0);; _stencil_val(ibm,0,0,0);{ {    
                 

                


                
                for (int i = -1; i <= 1; i += 2)
                    {_stencil_val(cr,i,0,0);; _stencil_val(ibm,i,0,0); _stencil_val(ibm,i,0,0);
                        {_stencil_val_a(id.x,0,0,0);     }      }
                   


for (int j = -1; j <= 1; j += 2)
                       {_stencil_val(cr,0,j,0);; _stencil_val(ibm,0,j,0); _stencil_val(ibm,0,j,0);
                           {_stencil_val_a(id.y,0,0,0);     }     }


                  
#line 1912 "./../ibm-gcm-vof-test.h"
                  
                    
            } 
{

;                _stencil_val_r(cr,0,0,0);
;                _stencil_val_r(c,0,0,0);   
            }}        
} 
{
            
                {_stencil_val_a(id.x,0,0,0);  }                {_stencil_val_a(id.y,0,0,0);  }
        }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:overfill) reduction(+:count)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1884 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1884 "./../ibm-gcm-vof-test.h"
{
        if ((val(c,0,0,0) > 0+1e-7 && val(c,0,0,0) < 1-1e-7) && val(ibm,0,0,0) >= 1) {


            if (val(cr,0,0,0) + (verror/(icells*(( Delta*Delta)*_const_cm))) > val(ibm,0,0,0)) {
                overfill = 1;

                count++;


                bool done = false;
                for (int i = -1; i <= 1; i += 2)
                    if (val(cr,i,0,0) + 2*(verror/(icells*(( Delta*Delta)*_const_cm))) < val(ibm,i,0,0) && val(ibm,i,0,0))
                        val(id.x,0,0,0) = i, done = true;


                if (!done)
                   for (int j = -1; j <= 1; j += 2)
                       if (val(cr,0,j,0) + 2*(verror/(pow(Delta,2)*_const_cm*icells)) < val(ibm,0,j,0) && val(ibm,0,j,0))
                           val(id.y,0,0,0) = j, done = true;
#line 1912 "./../ibm-gcm-vof-test.h"
                if (!done)
                    fprintf (ferr, "WARNING: could not fill cell with volume error!\n");
            }
            else {

                val(cr,0,0,0) += verror/(icells*(( Delta*Delta)*_const_cm));
                val(c,0,0,0) += verror/(icells*(( Delta*Delta)*_const_cm));
            }
        }
        else {
            
                val(id.x,0,0,0) = 0;                val(id.y,0,0,0) = 0;
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1925 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&count,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&overfill,MPI_INT,MPI_MAX,1);}}

    boundary_internal ((scalar *)((vector[]){id,{{-1},{-1}}}), "./../ibm-gcm-vof-test.h", 1927);


    int fixed = overfill? 0: 1;
    if (overfill)
        {if(!is_constant(cm)){        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1932, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1932 "./../ibm-gcm-vof-test.h"
{
            for (int i = -1; i <= 1; i += 2)
                {
                    {_stencil_val(id.x,i,0,0); {

_stencil_val(cm,i,0,0);                        _stencil_val_r(cr,0,0,0);
_stencil_val(cm,i,0,0);                        _stencil_val_r(c,0,0,0);   
                         




_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(cr,0,0,0);                        _stencil_val_a(cr,0,0,0);
_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);                        _stencil_val_a(c,0,0,0);               
                    }   }                    
#line 1935
{_stencil_val(id.y,0,i,0); {

_stencil_val(cm,0,i,0);                        _stencil_val_r(cr,0,0,0);
_stencil_val(cm,0,i,0);                        _stencil_val_r(c,0,0,0);   
                         




_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(cr,0,0,0);                        _stencil_val_a(cr,0,0,0);
_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);                        _stencil_val_a(c,0,0,0);               
                    }   }}
        }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:fixed)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1932 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1932 "./../ibm-gcm-vof-test.h"
{
            for (int i = -1; i <= 1; i += 2)
                {
                    if (val(id.x,i,0,0) == -i) {

                        val(cr,0,0,0) += verror/(icells*pow(Delta,2)*val(cm,i,0,0));
                        val(c,0,0,0) += verror/(icells*pow(Delta,2)*val(cm,i,0,0));
                        fixed = 1;




                        val(cr,0,0,0) = ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm,0,0,0)) ? (val(ibm,0,0,0)) : (val(cr,0,0,0)));
                        val(c,0,0,0) = ( (val(c,0,0,0)) < 0 ? 0 : (val(c,0,0,0)) > 1 ? 1 : (val(c,0,0,0)));
                    }                    
#line 1935
if (val(id.y,0,i,0) == -i) {

                        val(cr,0,0,0) += verror/(icells*pow(Delta,2)*val(cm,0,i,0));
                        val(c,0,0,0) += verror/(icells*pow(Delta,2)*val(cm,0,i,0));
                        fixed = 1;




                        val(cr,0,0,0) = ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm,0,0,0)) ? (val(ibm,0,0,0)) : (val(cr,0,0,0)));
                        val(c,0,0,0) = ( (val(c,0,0,0)) < 0 ? 0 : (val(c,0,0,0)) > 1 ? 1 : (val(c,0,0,0)));
                    }}
        }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1947 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&fixed,MPI_INT,MPI_MAX,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../ibm-gcm-vof-test.h", .line = 1932, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1932 "./../ibm-gcm-vof-test.h"
{
            for (int i = -1; i <= 1; i += 2)
                {
                    {_stencil_val(id.x,i,0,0); {

;                        _stencil_val_r(cr,0,0,0);
;                        _stencil_val_r(c,0,0,0);   
                         




_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(cr,0,0,0);                        _stencil_val_a(cr,0,0,0);
_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);                        _stencil_val_a(c,0,0,0);               
                    }   }                    
#line 1935
{_stencil_val(id.y,0,i,0); {

;                        _stencil_val_r(cr,0,0,0);
;                        _stencil_val_r(c,0,0,0);   
                         




_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val(cr,0,0,0);                        _stencil_val_a(cr,0,0,0);
_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,0,0);                        _stencil_val_a(c,0,0,0);               
                    }   }}
        }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(max:fixed)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 1932 "./../ibm-gcm-vof-test.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 1932 "./../ibm-gcm-vof-test.h"
{
            for (int i = -1; i <= 1; i += 2)
                {
                    if (val(id.x,i,0,0) == -i) {

                        val(cr,0,0,0) += verror/(icells*pow(Delta,2)*_const_cm);
                        val(c,0,0,0) += verror/(icells*pow(Delta,2)*_const_cm);
                        fixed = 1;




                        val(cr,0,0,0) = ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm,0,0,0)) ? (val(ibm,0,0,0)) : (val(cr,0,0,0)));
                        val(c,0,0,0) = ( (val(c,0,0,0)) < 0 ? 0 : (val(c,0,0,0)) > 1 ? 1 : (val(c,0,0,0)));
                    }                    
#line 1935
if (val(id.y,0,i,0) == -i) {

                        val(cr,0,0,0) += verror/(icells*pow(Delta,2)*_const_cm);
                        val(c,0,0,0) += verror/(icells*pow(Delta,2)*_const_cm);
                        fixed = 1;




                        val(cr,0,0,0) = ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm,0,0,0)) ? (val(ibm,0,0,0)) : (val(cr,0,0,0)));
                        val(c,0,0,0) = ( (val(c,0,0,0)) < 0 ? 0 : (val(c,0,0,0)) > 1 ? 1 : (val(c,0,0,0)));
                    }}
        }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 1947 "./../ibm-gcm-vof-test.h"
{mpi_all_reduce_array(&fixed,MPI_INT,MPI_MAX,1);}}}




    boundary_internal ((scalar *)((scalar[]){cr, c,{-1}}), "./../ibm-gcm-vof-test.h", 1952);
    (void) fixed;

    {delete((scalar*)((vector[]){id,{{-1},{-1}}}));return verror;}delete((scalar*)((vector[]){id,{{-1},{-1}}}));
}
#line 8 "sessile-ibm-axi-osc.c"
#line 1 "../my-two-phase.h"
#line 1 "./../my-two-phase.h"
#line 14 "./../my-two-phase.h"
#line 1 "../my-vof-testv2.h"
#line 1 "./../my-vof-testv2.h"












scalar  cid={26};

extern scalar * interfaces;
extern vector uf;
extern double dt;


static double vof_concentration_gradient_x (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 22 "./../my-vof-testv2.h"
static const double cmin = 0.5;
  double cl = val(c,-1,0,0), cc = val(c,0,0,0), cr = val(c,1,0,0);
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (val(t,-1,0,0)/cl, val(t,0,0,0)/cc, val(t,1,0,0)/cr)/Delta;
 else
   return (val(t,1,0,0)/cr - val(t,-1,0,0)/cl)/(2.*Delta);
      }
      else
 return (val(t,1,0,0)/cr - val(t,0,0,0)/cc)/Delta;
    }
    else if (cl >= cmin)
      return (val(t,0,0,0)/cc - val(t,-1,0,0)/cl)/Delta;
  }
  return 0.;
}
#line 20
static double vof_concentration_gradient_y (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 22 "./../my-vof-testv2.h"
static const double cmin = 0.5;
  double cl = val(c,0,-1,0), cc = val(c,0,0,0), cr = val(c,0,1,0);
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (val(t,0,-1,0)/cl, val(t,0,0,0)/cc, val(t,0,1,0)/cr)/Delta;
 else
   return (val(t,0,1,0)/cr - val(t,0,-1,0)/cl)/(2.*Delta);
      }
      else
 return (val(t,0,1,0)/cr - val(t,0,0,0)/cc)/Delta;
    }
    else if (cl >= cmin)
      return (val(t,0,0,0)/cc - val(t,0,-1,0)/cl)/Delta;
  }
  return 0.;
}
#line 20
static void _stencil_vof_concentration_gradient_x (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 23 "./../my-vof-testv2.h"
_stencil_val(c,1,0,0); _stencil_val(c,0,0,0); _stencil_val(c,-1,0,0); 


{
{ {
{ {
 if (_attribute[t.i].gradient)
   {_stencil_val(t,-1,0,0); _stencil_val(t,0,0,0); _stencil_val(t,1,0,0);  }
 else
   {_stencil_val(t,1,0,0); _stencil_val(t,-1,0,0);  }
      }
 
{_stencil_val(t,1,0,0); _stencil_val(t,0,0,0);  }}    
}
      
{_stencil_val(t,0,0,0); _stencil_val(t,-1,0,0);  }}  
}  
return ;
}
#line 20
static void _stencil_vof_concentration_gradient_y (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 23 "./../my-vof-testv2.h"
_stencil_val(c,0,1,0); _stencil_val(c,0,0,0); _stencil_val(c,0,-1,0); 


{
{ {
{ {
 if (_attribute[t.i].gradient)
   {_stencil_val(t,0,-1,0); _stencil_val(t,0,0,0); _stencil_val(t,0,1,0);  }
 else
   {_stencil_val(t,0,1,0); _stencil_val(t,0,-1,0);  }
      }
 
{_stencil_val(t,0,1,0); _stencil_val(t,0,0,0);  }}    
}
      
{_stencil_val(t,0,0,0); _stencil_val(t,0,-1,0);  }}  
}  
return ;
}



static void vof_concentration_refine (Point point, scalar s)
{if(!is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 47 "./../my-vof-testv2.h"
scalar f = _attribute[s.i].c;
  if (val(cm,0,0,0) == 0. || (!_attribute[s.i].inverse && val(f,0,0,0) <= 0.) || (_attribute[s.i].inverse && val(f,0,0,0) >= 1.))
     
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;      
#line 50 "./../my-vof-testv2.h"
val(s,0,0,0) = 0.;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}  
#line 51 "./../my-vof-testv2.h"
else {
    coord g;
    
      g.x = Delta*vof_concentration_gradient_x (point, f, s);      g.y = Delta*vof_concentration_gradient_y (point, f, s);
    double sc = _attribute[s.i].inverse ? val(s,0,0,0)/(1. - val(f,0,0,0)) : val(s,0,0,0)/val(f,0,0,0), cmc = 4.*val(cm,0,0,0);
  
    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 56 "./../my-vof-testv2.h"
{
      val(s,0,0,0) = sc;
      
 val(s,0,0,0) += child.x*g.x*val(cm,-child.x,0,0)/cmc; val(s,0,0,0) += child.y*g.y*val(cm,0,-child.y,0)/cmc;
      val(s,0,0,0) *= _attribute[s.i].inverse ? 1. - val(f,0,0,0) : val(f,0,0,0);
    }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 62 "./../my-vof-testv2.h"
}
}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
#line 46
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 47 "./../my-vof-testv2.h"
scalar f = _attribute[s.i].c;
  if (_const_cm == 0. || (!_attribute[s.i].inverse && val(f,0,0,0) <= 0.) || (_attribute[s.i].inverse && val(f,0,0,0) >= 1.))
     
#line 367 "/home/spencer/basilisk/src/grid/tree.h"
{
  {
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;      
#line 50 "./../my-vof-testv2.h"
val(s,0,0,0) = 0.;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
}  
#line 51 "./../my-vof-testv2.h"
else {
    coord g;
    
      g.x = Delta*vof_concentration_gradient_x (point, f, s);      g.y = Delta*vof_concentration_gradient_y (point, f, s);
    double sc = _attribute[s.i].inverse ? val(s,0,0,0)/(1. - val(f,0,0,0)) : val(s,0,0,0)/val(f,0,0,0), cmc = 4.*_const_cm;
  
    
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 56 "./../my-vof-testv2.h"
{
      val(s,0,0,0) = sc;
      
 val(s,0,0,0) += child.x*g.x*_const_cm/cmc; val(s,0,0,0) += child.y*g.y*_const_cm/cmc;
      val(s,0,0,0) *= _attribute[s.i].inverse ? 1. - val(f,0,0,0) : val(f,0,0,0);
    }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 62 "./../my-vof-testv2.h"
}
}}}

scalar  ch={27},  cr={28};
static int defaults_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int defaults_1(const int i,const double t,Event *_ev){tracing("defaults_1","./../my-vof-testv2.h",66);
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
    _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
    _attribute[c.i].dirty = true;
    scalar * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      _attribute[t.i].restriction = restriction_volume_average;
      _attribute[t.i].refine = _attribute[t.i].prolongation = vof_concentration_refine;
      _attribute[t.i].dirty = true;
      _attribute[t.i].c = c;
    }}}
  }}}
  _attribute[ch.i].refine = _attribute[ch.i].prolongation = fraction_refine;
  _attribute[ch.i].dirty = true;
  _attribute[cr.i].refine = _attribute[cr.i].prolongation = fraction_refine;
  _attribute[cr.i].dirty = true;
}{end_tracing("defaults_1","./../my-vof-testv2.h",83);return 0;}end_tracing("defaults_1","./../my-vof-testv2.h",83);}



static int defaults_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int defaults_2(const int i,const double t,Event *_ev){tracing("defaults_2","./../my-vof-testv2.h",87);
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
    scalar * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
      _attribute[t.i].depends = list_add (_attribute[t.i].depends, c);}}
  }}}
}{end_tracing("defaults_2","./../my-vof-testv2.h",94);return 0;}end_tracing("defaults_2","./../my-vof-testv2.h",94);}


static int stability_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int stability_0(const int i,const double t,Event *_ev){tracing("stability_0","./../my-vof-testv2.h",97); {
  if (CFL > 0.5)
    CFL = 0.5;
}{end_tracing("stability_0","./../my-vof-testv2.h",100);return 0;}end_tracing("stability_0","./../my-vof-testv2.h",100);}

void set_contact_angle (scalar f, const scalar fr0, const scalar ibm,
                        vector nu, scalar alphau, vector ns, scalar alphas, scalar id);
void set_contact_angle_tension (scalar f, const scalar fr0, const scalar ibm,
                                vector nf, scalar alphaf, vector ns, scalar alphas);
coord indicator = {0,1,2};

vector  nfg={{29},{30}},  nsg={{31},{32}},  divs={{33},{34}};
scalar  alphafg={35},  alphasg={36};

vector  ibmf_temp={{37},{38}};
vector  fluxr={{39},{40}};

void move_solid_x(scalar ibm, vector ibmf);
void move_solid_y(scalar ibm, vector ibmf);
void move_solid_z(scalar ibm, vector ibmf);


static void sweep_x (scalar c, scalar ch, scalar cc, scalar * tcl, scalar cr, scalar ibm0,
                     vector ibmf0, vector ns, scalar alphas, vector nf, scalar alphaf,
                     vector nfh, scalar alphafh, int last)
{
  scalar  flux=new_scalar("flux");
  double cfl = 0.;


  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}
  


    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 136, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 136 "./../my-vof-testv2.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 { _stencil_vof_concentration_gradient_x (point, c, t);_stencil_val_a(gf,0,0,0); }}}
    }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 136 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 136 "./../my-vof-testv2.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 val(gf,0,0,0) = vof_concentration_gradient_x (point, c, t);}}
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 141 "./../my-vof-testv2.h"
}
#line 150 "./../my-vof-testv2.h"
  scalar  ct=new_scalar("ct");
  scalar  ctid=new_scalar("ctid");




if(!is_constant(fm.x) && !is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 156 "./../my-vof-testv2.h"
{              



    _stencil_val(ibmf_temp.x,0,0,0);_stencil_val(fm.x,0,0,0); _stencil_val(uf.x,0,0,0);     



    







_stencil_val(ibm0,0,0,0);

    {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);
      {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);    }     }



;_stencil_val(nfh.y, o_stencil,0,0);_stencil_val(nfh.x,o_stencil,0,0);            
     

_stencil_val(c,0,0,0);    _stencil_val_a(ct,0,0,0); 
    _stencil_val_a(ctid,0,0,0);

{ 
          
{_stencil_val(ibm0,o_stencil,0,0);{ {

_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(alphaf, o_stencil,0,0);    
} 

{_stencil_val(ibm0,o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{ {
;_stencil_val(ns.y, o_stencil,0,0);_stencil_val(ns.x,o_stencil,0,0);   


        _stencil_val(ibmf_temp.x,0,0,0);









_stencil_val(cr,o_stencil,0,0);{
               
{_stencil_val(cr,o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{





              
#line 223 "./../my-vof-testv2.h"
          
{_stencil_val(cr,o_stencil,0,0);_stencil_val(cr, o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{ {



;_stencil_val(nfh.y, o_stencil,0,0);_stencil_val(nfh.x,o_stencil,0,0);

_stencil_val(ch,o_stencil,0,0);{
                  
              
{_stencil_val(ch,o_stencil,0,0);{
                  
              
{      
                _stencil_val(cr, o_stencil,0,0);_stencil_val(alphas, o_stencil,0,0);_stencil_val(alphaf, o_stencil,0,0);_stencil_val(ibm, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);     
                
_stencil_val(alphas, o_stencil,0,0);                

_stencil_val_a(ct,0,0,0);  
                _stencil_val_a(ctid,0,0,0);  
            }}            }}       







}
             
}       }}        }}
#line 206 "./../my-vof-testv2.h"
           
        
    
#line 254
}
          
     

}    }}    }}    

_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux,0,0,0); 
_stencil_val(flux,0,0,0);    _stencil_val_a(fluxr.x,0,0,0); 

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {               
     _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
_stencil_val(uf.x,0,0,0);     _stencil_val_a(tflux,0,0,0);  
      }
     
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 698
{
  if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 156 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../my-vof-testv2.h"
{



    double un = val(uf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0)*val(ibmf_temp.x,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));



    int i = -(s + 1.)/2.;







    if (val(ibm0,0,0,0) >= 1.)

    if (un*val(fm.x,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*val(fm.x,0,0,0)*s/(val(cm,0,0,0) + 1e-30);

    double cf = 0;

    coord tempnf = {-s*val(nfh.x,i,0,0), val(nfh.y,i,0,0), _val_higher_dimension};
    coord lhs = {-0.5, -0.5, -0.5}, rhs = {s*un - 0.5, 0.5, 0.5};

    val(ct,0,0,0) = val(c,0,0,0);
    val(ctid,0,0,0) = 0;

    if (un == 0)
        cf = 0;
    else if (val(ibm0,i,0,0) >= 1.) {

        cf = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.)? val(c,i,0,0) : rectangle_fraction (tempnf, val(alphaf,i,0,0), lhs, rhs);
    }

    else if (val(ibm0,i,0,0) > 0. && val(ibm0,i,0,0) < 1.) {
        coord tempns = {-s*val(ns.x,i,0,0), val(ns.y,i,0,0), _val_higher_dimension};


        double advVolume = fabs(un)*val(ibmf_temp.x,0,0,0);
#line 206 "./../my-vof-testv2.h"
        if (val(cr,i,0,0) <= 0.)
            cf = 0.;
        else if (val(cr,i,0,0) >= val(ibm0,i,0,0)-1e-10) {





            cf = 1;
#line 223 "./../my-vof-testv2.h"
        }
        else if (val(cr,i,0,0) > 0. && val(cr,i,0,0) < val(ibm0,i,0,0)-1e-10) {



            coord tempnfh = {-s*val(nfh.x,i,0,0), val(nfh.y,i,0,0), _val_higher_dimension};

            if (val(ch,i,0,0) >=1 && !tempnfh.x && !tempnfh.y && !tempnfh.z) {
                cf = 1;
            }
            else if (val(ch,i,0,0) <= 1e-10 && !tempnfh.x && !tempnfh.y && !tempnfh.z) {
                cf = 0;
            }
            else {
                double alphacr = immersed_alpha (val(c,i,0,0), val(ibm,i,0,0), tempnfh, val(alphaf,i,0,0), tempns, val(alphas,i,0,0), val(cr,i,0,0)
#line 1393 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 237 "./../my-vof-testv2.h"
);
                double newc = line_area(tempnfh.x, tempnfh.y, alphacr);
                cf = immersed_fraction (newc, tempnfh, alphacr, tempns, val(alphas,i,0,0), lhs, rhs, advVolume, 0);

                val(ct,0,0,0) = newc;
                val(ctid,0,0,0) = i;
            }







       }
       else
           cf = 0;
    }

    else {
        cf = 0;
    }

    val(flux,0,0,0) = cf*val(uf.x,0,0,0);
    val(fluxr.x,0,0,0) = val(flux,0,0,0);

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
     cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
     double ff = val(t,i,0,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,i,0,0)*Delta/2.;
     val(tflux,0,0,0) = ff*cf1*val(uf.x,0,0,0);
      }
      else
     val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 275 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(fm.x) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 156 "./../my-vof-testv2.h"
{              



    _stencil_val(ibmf_temp.x,0,0,0);; _stencil_val(uf.x,0,0,0);     



    







_stencil_val(ibm0,0,0,0);

    {;_stencil_val(cm,0,0,0);
      {;_stencil_val(cm,0,0,0);    }     }



;_stencil_val(nfh.y, o_stencil,0,0);_stencil_val(nfh.x,o_stencil,0,0);            
     

_stencil_val(c,0,0,0);    _stencil_val_a(ct,0,0,0); 
    _stencil_val_a(ctid,0,0,0);

{ 
          
{_stencil_val(ibm0,o_stencil,0,0);{ {

_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(alphaf, o_stencil,0,0);    
} 

{_stencil_val(ibm0,o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{ {
;_stencil_val(ns.y, o_stencil,0,0);_stencil_val(ns.x,o_stencil,0,0);   


        _stencil_val(ibmf_temp.x,0,0,0);









_stencil_val(cr,o_stencil,0,0);{
               
{_stencil_val(cr,o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{





              
#line 223 "./../my-vof-testv2.h"
          
{_stencil_val(cr,o_stencil,0,0);_stencil_val(cr, o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{ {



;_stencil_val(nfh.y, o_stencil,0,0);_stencil_val(nfh.x,o_stencil,0,0);

_stencil_val(ch,o_stencil,0,0);{
                  
              
{_stencil_val(ch,o_stencil,0,0);{
                  
              
{      
                _stencil_val(cr, o_stencil,0,0);_stencil_val(alphas, o_stencil,0,0);_stencil_val(alphaf, o_stencil,0,0);_stencil_val(ibm, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);     
                
_stencil_val(alphas, o_stencil,0,0);                

_stencil_val_a(ct,0,0,0);  
                _stencil_val_a(ctid,0,0,0);  
            }}            }}       







}
             
}       }}        }}
#line 206 "./../my-vof-testv2.h"
           
        
    
#line 254
}
          
     

}    }}    }}    

_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux,0,0,0); 
_stencil_val(flux,0,0,0);    _stencil_val_a(fluxr.x,0,0,0); 

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {               
     _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
_stencil_val(uf.x,0,0,0);     _stencil_val_a(tflux,0,0,0);  
      }
     
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 698
{
  if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 156 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../my-vof-testv2.h"
{



    double un = val(uf.x,0,0,0)*dt/(Delta*_const_fm.x*val(ibmf_temp.x,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));



    int i = -(s + 1.)/2.;







    if (val(ibm0,0,0,0) >= 1.)

    if (un*_const_fm.x*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*_const_fm.x*s/(val(cm,0,0,0) + 1e-30);

    double cf = 0;

    coord tempnf = {-s*val(nfh.x,i,0,0), val(nfh.y,i,0,0), _val_higher_dimension};
    coord lhs = {-0.5, -0.5, -0.5}, rhs = {s*un - 0.5, 0.5, 0.5};

    val(ct,0,0,0) = val(c,0,0,0);
    val(ctid,0,0,0) = 0;

    if (un == 0)
        cf = 0;
    else if (val(ibm0,i,0,0) >= 1.) {

        cf = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.)? val(c,i,0,0) : rectangle_fraction (tempnf, val(alphaf,i,0,0), lhs, rhs);
    }

    else if (val(ibm0,i,0,0) > 0. && val(ibm0,i,0,0) < 1.) {
        coord tempns = {-s*val(ns.x,i,0,0), val(ns.y,i,0,0), _val_higher_dimension};


        double advVolume = fabs(un)*val(ibmf_temp.x,0,0,0);
#line 206 "./../my-vof-testv2.h"
        if (val(cr,i,0,0) <= 0.)
            cf = 0.;
        else if (val(cr,i,0,0) >= val(ibm0,i,0,0)-1e-10) {





            cf = 1;
#line 223 "./../my-vof-testv2.h"
        }
        else if (val(cr,i,0,0) > 0. && val(cr,i,0,0) < val(ibm0,i,0,0)-1e-10) {



            coord tempnfh = {-s*val(nfh.x,i,0,0), val(nfh.y,i,0,0), _val_higher_dimension};

            if (val(ch,i,0,0) >=1 && !tempnfh.x && !tempnfh.y && !tempnfh.z) {
                cf = 1;
            }
            else if (val(ch,i,0,0) <= 1e-10 && !tempnfh.x && !tempnfh.y && !tempnfh.z) {
                cf = 0;
            }
            else {
                double alphacr = immersed_alpha (val(c,i,0,0), val(ibm,i,0,0), tempnfh, val(alphaf,i,0,0), tempns, val(alphas,i,0,0), val(cr,i,0,0)
#line 1393 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 237 "./../my-vof-testv2.h"
);
                double newc = line_area(tempnfh.x, tempnfh.y, alphacr);
                cf = immersed_fraction (newc, tempnfh, alphacr, tempns, val(alphas,i,0,0), lhs, rhs, advVolume, 0);

                val(ct,0,0,0) = newc;
                val(ctid,0,0,0) = i;
            }







       }
       else
           cf = 0;
    }

    else {
        cf = 0;
    }

    val(flux,0,0,0) = cf*val(uf.x,0,0,0);
    val(fluxr.x,0,0,0) = val(flux,0,0,0);

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
     cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
     double ff = val(t,i,0,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,i,0,0)*Delta/2.;
     val(tflux,0,0,0) = ff*cf1*val(uf.x,0,0,0);
      }
      else
     val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 275 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 156 "./../my-vof-testv2.h"
{              



    _stencil_val(ibmf_temp.x,0,0,0);_stencil_val(fm.x,0,0,0); _stencil_val(uf.x,0,0,0);     



    







_stencil_val(ibm0,0,0,0);

    {_stencil_val(fm.x,0,0,0);;
      {_stencil_val(fm.x,0,0,0);;    }     }



;_stencil_val(nfh.y, o_stencil,0,0);_stencil_val(nfh.x,o_stencil,0,0);            
     

_stencil_val(c,0,0,0);    _stencil_val_a(ct,0,0,0); 
    _stencil_val_a(ctid,0,0,0);

{ 
          
{_stencil_val(ibm0,o_stencil,0,0);{ {

_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(alphaf, o_stencil,0,0);    
} 

{_stencil_val(ibm0,o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{ {
;_stencil_val(ns.y, o_stencil,0,0);_stencil_val(ns.x,o_stencil,0,0);   


        _stencil_val(ibmf_temp.x,0,0,0);









_stencil_val(cr,o_stencil,0,0);{
               
{_stencil_val(cr,o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{





              
#line 223 "./../my-vof-testv2.h"
          
{_stencil_val(cr,o_stencil,0,0);_stencil_val(cr, o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{ {



;_stencil_val(nfh.y, o_stencil,0,0);_stencil_val(nfh.x,o_stencil,0,0);

_stencil_val(ch,o_stencil,0,0);{
                  
              
{_stencil_val(ch,o_stencil,0,0);{
                  
              
{      
                _stencil_val(cr, o_stencil,0,0);_stencil_val(alphas, o_stencil,0,0);_stencil_val(alphaf, o_stencil,0,0);_stencil_val(ibm, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);     
                
_stencil_val(alphas, o_stencil,0,0);                

_stencil_val_a(ct,0,0,0);  
                _stencil_val_a(ctid,0,0,0);  
            }}            }}       







}
             
}       }}        }}
#line 206 "./../my-vof-testv2.h"
           
        
    
#line 254
}
          
     

}    }}    }}    

_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux,0,0,0); 
_stencil_val(flux,0,0,0);    _stencil_val_a(fluxr.x,0,0,0); 

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {               
     _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
_stencil_val(uf.x,0,0,0);     _stencil_val_a(tflux,0,0,0);  
      }
     
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 698
{
  if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 156 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../my-vof-testv2.h"
{



    double un = val(uf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0)*val(ibmf_temp.x,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));



    int i = -(s + 1.)/2.;







    if (val(ibm0,0,0,0) >= 1.)

    if (un*val(fm.x,0,0,0)*s/(_const_cm + 1e-30) > cfl)
      cfl = un*val(fm.x,0,0,0)*s/(_const_cm + 1e-30);

    double cf = 0;

    coord tempnf = {-s*val(nfh.x,i,0,0), val(nfh.y,i,0,0), _val_higher_dimension};
    coord lhs = {-0.5, -0.5, -0.5}, rhs = {s*un - 0.5, 0.5, 0.5};

    val(ct,0,0,0) = val(c,0,0,0);
    val(ctid,0,0,0) = 0;

    if (un == 0)
        cf = 0;
    else if (val(ibm0,i,0,0) >= 1.) {

        cf = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.)? val(c,i,0,0) : rectangle_fraction (tempnf, val(alphaf,i,0,0), lhs, rhs);
    }

    else if (val(ibm0,i,0,0) > 0. && val(ibm0,i,0,0) < 1.) {
        coord tempns = {-s*val(ns.x,i,0,0), val(ns.y,i,0,0), _val_higher_dimension};


        double advVolume = fabs(un)*val(ibmf_temp.x,0,0,0);
#line 206 "./../my-vof-testv2.h"
        if (val(cr,i,0,0) <= 0.)
            cf = 0.;
        else if (val(cr,i,0,0) >= val(ibm0,i,0,0)-1e-10) {





            cf = 1;
#line 223 "./../my-vof-testv2.h"
        }
        else if (val(cr,i,0,0) > 0. && val(cr,i,0,0) < val(ibm0,i,0,0)-1e-10) {



            coord tempnfh = {-s*val(nfh.x,i,0,0), val(nfh.y,i,0,0), _val_higher_dimension};

            if (val(ch,i,0,0) >=1 && !tempnfh.x && !tempnfh.y && !tempnfh.z) {
                cf = 1;
            }
            else if (val(ch,i,0,0) <= 1e-10 && !tempnfh.x && !tempnfh.y && !tempnfh.z) {
                cf = 0;
            }
            else {
                double alphacr = immersed_alpha (val(c,i,0,0), val(ibm,i,0,0), tempnfh, val(alphaf,i,0,0), tempns, val(alphas,i,0,0), val(cr,i,0,0)
#line 1393 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 237 "./../my-vof-testv2.h"
);
                double newc = line_area(tempnfh.x, tempnfh.y, alphacr);
                cf = immersed_fraction (newc, tempnfh, alphacr, tempns, val(alphas,i,0,0), lhs, rhs, advVolume, 0);

                val(ct,0,0,0) = newc;
                val(ctid,0,0,0) = i;
            }







       }
       else
           cf = 0;
    }

    else {
        cf = 0;
    }

    val(flux,0,0,0) = cf*val(uf.x,0,0,0);
    val(fluxr.x,0,0,0) = val(flux,0,0,0);

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
     cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
     double ff = val(t,i,0,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,i,0,0)*Delta/2.;
     val(tflux,0,0,0) = ff*cf1*val(uf.x,0,0,0);
      }
      else
     val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 275 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 156 "./../my-vof-testv2.h"
{              



    _stencil_val(ibmf_temp.x,0,0,0);; _stencil_val(uf.x,0,0,0);     



    







_stencil_val(ibm0,0,0,0);

    {;;
      {;;    }     }



;_stencil_val(nfh.y, o_stencil,0,0);_stencil_val(nfh.x,o_stencil,0,0);            
     

_stencil_val(c,0,0,0);    _stencil_val_a(ct,0,0,0); 
    _stencil_val_a(ctid,0,0,0);

{ 
          
{_stencil_val(ibm0,o_stencil,0,0);{ {

_stencil_val(c,o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(alphaf, o_stencil,0,0);    
} 

{_stencil_val(ibm0,o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{ {
;_stencil_val(ns.y, o_stencil,0,0);_stencil_val(ns.x,o_stencil,0,0);   


        _stencil_val(ibmf_temp.x,0,0,0);









_stencil_val(cr,o_stencil,0,0);{
               
{_stencil_val(cr,o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{





              
#line 223 "./../my-vof-testv2.h"
          
{_stencil_val(cr,o_stencil,0,0);_stencil_val(cr, o_stencil,0,0);_stencil_val(ibm0, o_stencil,0,0);{ {



;_stencil_val(nfh.y, o_stencil,0,0);_stencil_val(nfh.x,o_stencil,0,0);

_stencil_val(ch,o_stencil,0,0);{
                  
              
{_stencil_val(ch,o_stencil,0,0);{
                  
              
{      
                _stencil_val(cr, o_stencil,0,0);_stencil_val(alphas, o_stencil,0,0);_stencil_val(alphaf, o_stencil,0,0);_stencil_val(ibm, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);     
                
_stencil_val(alphas, o_stencil,0,0);                

_stencil_val_a(ct,0,0,0);  
                _stencil_val_a(ctid,0,0,0);  
            }}            }}       







}
             
}       }}        }}
#line 206 "./../my-vof-testv2.h"
           
        
    
#line 254
}
          
     

}    }}    }}    

_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux,0,0,0); 
_stencil_val(flux,0,0,0);    _stencil_val_a(fluxr.x,0,0,0); 

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {               
     _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
_stencil_val(uf.x,0,0,0);     _stencil_val_a(tflux,0,0,0);  
      }
     
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 698
{
  if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 156 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../my-vof-testv2.h"
{



    double un = val(uf.x,0,0,0)*dt/(Delta*_const_fm.x*val(ibmf_temp.x,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));



    int i = -(s + 1.)/2.;







    if (val(ibm0,0,0,0) >= 1.)

    if (un*_const_fm.x*s/(_const_cm + 1e-30) > cfl)
      cfl = un*_const_fm.x*s/(_const_cm + 1e-30);

    double cf = 0;

    coord tempnf = {-s*val(nfh.x,i,0,0), val(nfh.y,i,0,0), _val_higher_dimension};
    coord lhs = {-0.5, -0.5, -0.5}, rhs = {s*un - 0.5, 0.5, 0.5};

    val(ct,0,0,0) = val(c,0,0,0);
    val(ctid,0,0,0) = 0;

    if (un == 0)
        cf = 0;
    else if (val(ibm0,i,0,0) >= 1.) {

        cf = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.)? val(c,i,0,0) : rectangle_fraction (tempnf, val(alphaf,i,0,0), lhs, rhs);
    }

    else if (val(ibm0,i,0,0) > 0. && val(ibm0,i,0,0) < 1.) {
        coord tempns = {-s*val(ns.x,i,0,0), val(ns.y,i,0,0), _val_higher_dimension};


        double advVolume = fabs(un)*val(ibmf_temp.x,0,0,0);
#line 206 "./../my-vof-testv2.h"
        if (val(cr,i,0,0) <= 0.)
            cf = 0.;
        else if (val(cr,i,0,0) >= val(ibm0,i,0,0)-1e-10) {





            cf = 1;
#line 223 "./../my-vof-testv2.h"
        }
        else if (val(cr,i,0,0) > 0. && val(cr,i,0,0) < val(ibm0,i,0,0)-1e-10) {



            coord tempnfh = {-s*val(nfh.x,i,0,0), val(nfh.y,i,0,0), _val_higher_dimension};

            if (val(ch,i,0,0) >=1 && !tempnfh.x && !tempnfh.y && !tempnfh.z) {
                cf = 1;
            }
            else if (val(ch,i,0,0) <= 1e-10 && !tempnfh.x && !tempnfh.y && !tempnfh.z) {
                cf = 0;
            }
            else {
                double alphacr = immersed_alpha (val(c,i,0,0), val(ibm,i,0,0), tempnfh, val(alphaf,i,0,0), tempns, val(alphas,i,0,0), val(cr,i,0,0)
#line 1393 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 237 "./../my-vof-testv2.h"
);
                double newc = line_area(tempnfh.x, tempnfh.y, alphacr);
                cf = immersed_fraction (newc, tempnfh, alphacr, tempns, val(alphas,i,0,0), lhs, rhs, advVolume, 0);

                val(ct,0,0,0) = newc;
                val(ctid,0,0,0) = i;
            }







       }
       else
           cf = 0;
    }

    else {
        cf = 0;
    }

    val(flux,0,0,0) = cf*val(uf.x,0,0,0);
    val(fluxr.x,0,0,0) = val(flux,0,0,0);

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
     cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
     double ff = val(t,i,0,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,i,0,0)*Delta/2.;
     val(tflux,0,0,0) = ff*cf1*val(uf.x,0,0,0);
      }
      else
     val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 275 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "src/vof.h:%d: warning: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      284, cfl - 0.5), fflush (ferr);

  double crsum = 0, crsumclamp = 0;
  if(!is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 287, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 288 "./../my-vof-testv2.h"
{_stencil_val(ibm0,0,0,0); {









_stencil_val(ibm0,0,0,0); _stencil_val(ibm0,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(ibm0,0,0,0);
        for (int _i = -1; _i <= 1; _i += 1)
            {_stencil_val(ctid,_i,0,0); _stencil_val(ibm0,_i,0,0); _stencil_val(ibm0,_i,0,0);
                { _stencil_val(ct,_i,0,0);_stencil_val_a(c,0,0,0); }         }  
#line 298 "./../my-vof-testv2.h"
                 



       


_stencil_val(cm,0,0,0);




_stencil_val(flux,0,0,0); _stencil_val(flux,1,0,0); _stencil_val(cc,0,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0); _stencil_val(divs.x,0,0,0);      _stencil_val_r(c,0,0,0);
_stencil_val(flux,0,0,0); _stencil_val(flux,1,0,0); _stencil_val(cc,0,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0); _stencil_val(divs.x,0,0,0);      _stencil_val_r(cr,0,0,0);      

      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
        {_stencil_val(tflux,0,0,0); _stencil_val(tflux,1,0,0); _stencil_val(tc,0,0,0);_stencil_val(ibmf.x,1,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(ibmf.x,0,0,0);_stencil_val(uf.x,0,0,0);_stencil_val(cm,0,0,0);_stencil_val_r(t,0,0,0);     }}} 







_stencil_val(cr,0,0,0);_stencil_val(cm,0,0,0);       
_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm0,0,0,0);_stencil_val(ibm0,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(cm,0,0,0);    
}   }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (+:crsum) reduction (+:crsumclamp)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 288 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 288 "./../my-vof-testv2.h"
if (val(ibm0,0,0,0) > 0) {
#line 298 "./../my-vof-testv2.h"
      if (val(ibm0,0,0,0) > 0. && val(ibm0,0,0,0) < 1. && val(cr,0,0,0) > 0. && val(cr,0,0,0) < val(ibm0,0,0,0)-1e-10)
        for (int _i = -1; _i <= 1; _i += 1)
            if (val(ctid,_i,0,0) == -_i && val(ibm0,_i,0,0) > 0. && val(ibm0,_i,0,0) < 1.)
                val(c,0,0,0) = val(ct,_i,0,0);



      double val = val(cm,0,0,0);




      val(c,0,0,0) += dt*(val(flux,0,0,0) - val(flux,1,0,0) + val(cc,0,0,0)*(val(uf.x,1,0,0) - val(uf.x,0,0,0) - val(divs.x,0,0,0)))/(val*Delta);
      val(cr,0,0,0) += dt*(val(flux,0,0,0) - val(flux,1,0,0) + val(cc,0,0,0)*(val(uf.x,1,0,0) - val(uf.x,0,0,0) - val(divs.x,0,0,0)))/(val*Delta);

      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
        val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,1,0,0) + val(tc,0,0,0)*(val(ibmf.x,1,0,0)*val(uf.x,1,0,0) - val(ibmf.x,0,0,0)*val(uf.x,0,0,0)))/(val(cm,0,0,0)*Delta);}}







      crsum += val(cr,0,0,0)*pow(Delta, 2)*val(cm,0,0,0);
      crsumclamp += ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm0,0,0,0)) ? (val(ibm0,0,0,0)) : (val(cr,0,0,0)))*pow(Delta, 2)*val(cm,0,0,0);
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 325 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&crsumclamp,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&crsum,MPI_DOUBLE,MPI_SUM,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 287, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 288 "./../my-vof-testv2.h"
{_stencil_val(ibm0,0,0,0); {









_stencil_val(ibm0,0,0,0); _stencil_val(ibm0,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(ibm0,0,0,0);
        for (int _i = -1; _i <= 1; _i += 1)
            {_stencil_val(ctid,_i,0,0); _stencil_val(ibm0,_i,0,0); _stencil_val(ibm0,_i,0,0);
                { _stencil_val(ct,_i,0,0);_stencil_val_a(c,0,0,0); }         }



;




_stencil_val(flux,0,0,0); _stencil_val(flux,1,0,0); _stencil_val(cc,0,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0); _stencil_val(divs.x,0,0,0);      _stencil_val_r(c,0,0,0);
_stencil_val(flux,0,0,0); _stencil_val(flux,1,0,0); _stencil_val(cc,0,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0); _stencil_val(divs.x,0,0,0);      _stencil_val_r(cr,0,0,0);      

      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
        {_stencil_val(tflux,0,0,0); _stencil_val(tflux,1,0,0); _stencil_val(tc,0,0,0);_stencil_val(ibmf.x,1,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(ibmf.x,0,0,0);_stencil_val(uf.x,0,0,0);;_stencil_val_r(t,0,0,0);     }}} 







_stencil_val(cr,0,0,0);;       
_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm0,0,0,0);_stencil_val(ibm0,0,0,0);_stencil_val(cr,0,0,0);;    
}   }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (+:crsum) reduction (+:crsumclamp)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 288 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 288 "./../my-vof-testv2.h"
if (val(ibm0,0,0,0) > 0) {
#line 298 "./../my-vof-testv2.h"
      if (val(ibm0,0,0,0) > 0. && val(ibm0,0,0,0) < 1. && val(cr,0,0,0) > 0. && val(cr,0,0,0) < val(ibm0,0,0,0)-1e-10)
        for (int _i = -1; _i <= 1; _i += 1)
            if (val(ctid,_i,0,0) == -_i && val(ibm0,_i,0,0) > 0. && val(ibm0,_i,0,0) < 1.)
                val(c,0,0,0) = val(ct,_i,0,0);



      double val = _const_cm;




      val(c,0,0,0) += dt*(val(flux,0,0,0) - val(flux,1,0,0) + val(cc,0,0,0)*(val(uf.x,1,0,0) - val(uf.x,0,0,0) - val(divs.x,0,0,0)))/(val*Delta);
      val(cr,0,0,0) += dt*(val(flux,0,0,0) - val(flux,1,0,0) + val(cc,0,0,0)*(val(uf.x,1,0,0) - val(uf.x,0,0,0) - val(divs.x,0,0,0)))/(val*Delta);

      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
        val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,1,0,0) + val(tc,0,0,0)*(val(ibmf.x,1,0,0)*val(uf.x,1,0,0) - val(ibmf.x,0,0,0)*val(uf.x,0,0,0)))/(_const_cm*Delta);}}







      crsum += val(cr,0,0,0)*pow(Delta, 2)*_const_cm;
      crsumclamp += ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm0,0,0,0)) ? (val(ibm0,0,0,0)) : (val(cr,0,0,0)))*pow(Delta, 2)*_const_cm;
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 325 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&crsumclamp,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&crsum,MPI_DOUBLE,MPI_SUM,1);}}

  if (!approx_equal_double (crsum, crsumclamp, 1e-14))
    fprintf (ferr, "WARNING %g: crsum != crsumclamp. crsum=%0.15g crsumclamp=%0.15g err=%g\n",
        indicator.x, crsum, crsumclamp, get_percent_error(crsum, crsumclamp));
#line 352 "./../my-vof-testv2.h"
  double verror = redistribute_volume (c, cr, ibm);
#line 362 "./../my-vof-testv2.h"
  (void) verror;  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 364, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 364 "./../my-vof-testv2.h"
{
_stencil_val(cr,0,0,0);
        { _stencil_val_a(c,0,0,0);_stencil_val_a(cr,0,0,0);   }  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 364 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 364 "./../my-vof-testv2.h"
{
    if (val(cr,0,0,0) < 1e-11)
        val(cr,0,0,0) = val(c,0,0,0) = 0;
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 369 "./../my-vof-testv2.h"
reconstruction (c, nf, alphaf);





  trash(((scalar[]){ch,{-1}}));  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 376, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 376 "./../my-vof-testv2.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0);{
        {_stencil_val_a(ch,0,0,0);  }
        
{ _stencil_val(cr,0,0,0);_stencil_val_a(ch,0,0,0); }}  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 376 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 376 "./../my-vof-testv2.h"
{
    if (val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1 && val(cr,0,0,0) >= val(ibm,0,0,0)-1e-10)
        val(ch,0,0,0) = 1.;
    else
        val(ch,0,0,0) = val(cr,0,0,0);
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 382 "./../my-vof-testv2.h"
boundary_internal ((scalar *)((scalar[]){ch,{-1}}), "./../my-vof-testv2.h", 382);
  set_contact_angle_tension(ch, cr, ibm0, nf, alphaf, ns, alphas);



  if (!last)
      reconstruction (ch, nfh, alphafh);

  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){ctid,ct,flux,{-1}}));
}
#line 119
static void sweep_y (scalar c, scalar ch, scalar cc, scalar * tcl, scalar cr, scalar ibm0,
                     vector ibmf0, vector ns, scalar alphas, vector nf, scalar alphaf,
                     vector nfh, scalar alphafh, int last)
{
  scalar  flux=new_scalar("flux");
  double cfl = 0.;


  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}
  


    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 136, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 136 "./../my-vof-testv2.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 { _stencil_vof_concentration_gradient_y (point, c, t);_stencil_val_a(gf,0,0,0); }}}
    }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 136 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 136 "./../my-vof-testv2.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 val(gf,0,0,0) = vof_concentration_gradient_y (point, c, t);}}
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 141 "./../my-vof-testv2.h"
}
#line 150 "./../my-vof-testv2.h"
  scalar  ct=new_scalar("ct");
  scalar  ctid=new_scalar("ctid");




if(!is_constant(fm.y) && !is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1); 
#line 156 "./../my-vof-testv2.h"
{              



    _stencil_val(ibmf_temp.y,0,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(uf.y,0,0,0);     



    







_stencil_val(ibm0,0,0,0);

    {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);
      {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);    }     }



;_stencil_val(nfh.x,0, o_stencil,0);_stencil_val(nfh.y,0,o_stencil,0);            
     

_stencil_val(c,0,0,0);    _stencil_val_a(ct,0,0,0); 
    _stencil_val_a(ctid,0,0,0);

{ 
          
{_stencil_val(ibm0,0,o_stencil,0);{ {

_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(alphaf,0, o_stencil,0);    
} 

{_stencil_val(ibm0,0,o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{ {
;_stencil_val(ns.x,0, o_stencil,0);_stencil_val(ns.y,0,o_stencil,0);   


        _stencil_val(ibmf_temp.y,0,0,0);









_stencil_val(cr,0,o_stencil,0);{
               
{_stencil_val(cr,0,o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{





              
#line 223 "./../my-vof-testv2.h"
          
{_stencil_val(cr,0,o_stencil,0);_stencil_val(cr,0, o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{ {



;_stencil_val(nfh.x,0, o_stencil,0);_stencil_val(nfh.y,0,o_stencil,0);

_stencil_val(ch,0,o_stencil,0);{
                  
              
{_stencil_val(ch,0,o_stencil,0);{
                  
              
{      
                _stencil_val(cr,0, o_stencil,0);_stencil_val(alphas,0, o_stencil,0);_stencil_val(alphaf,0, o_stencil,0);_stencil_val(ibm,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);     
                
_stencil_val(alphas,0, o_stencil,0);                

_stencil_val_a(ct,0,0,0);  
                _stencil_val_a(ctid,0,0,0);  
            }}            }}       







}
             
}       }}        }}
#line 206 "./../my-vof-testv2.h"
           
        
    
#line 254
}
          
     

}    }}    }}    

_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux,0,0,0); 
_stencil_val(flux,0,0,0);    _stencil_val_a(fluxr.y,0,0,0); 

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {               
     _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
_stencil_val(uf.y,0,0,0);     _stencil_val_a(tflux,0,0,0);  
      }
     
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 706
{
  if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 156 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../my-vof-testv2.h"
{



    double un = val(uf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0)*val(ibmf_temp.y,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));



    int i = -(s + 1.)/2.;







    if (val(ibm0,0,0,0) >= 1.)

    if (un*val(fm.y,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*val(fm.y,0,0,0)*s/(val(cm,0,0,0) + 1e-30);

    double cf = 0;

    coord tempnf = {-s*val(nfh.y,0,i,0), val(nfh.x,0,i,0), _val_higher_dimension};
    coord lhs = {-0.5, -0.5, -0.5}, rhs = {s*un - 0.5, 0.5, 0.5};

    val(ct,0,0,0) = val(c,0,0,0);
    val(ctid,0,0,0) = 0;

    if (un == 0)
        cf = 0;
    else if (val(ibm0,0,i,0) >= 1.) {

        cf = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.)? val(c,0,i,0) : rectangle_fraction (tempnf, val(alphaf,0,i,0), lhs, rhs);
    }

    else if (val(ibm0,0,i,0) > 0. && val(ibm0,0,i,0) < 1.) {
        coord tempns = {-s*val(ns.y,0,i,0), val(ns.x,0,i,0), _val_higher_dimension};


        double advVolume = fabs(un)*val(ibmf_temp.y,0,0,0);
#line 206 "./../my-vof-testv2.h"
        if (val(cr,0,i,0) <= 0.)
            cf = 0.;
        else if (val(cr,0,i,0) >= val(ibm0,0,i,0)-1e-10) {





            cf = 1;
#line 223 "./../my-vof-testv2.h"
        }
        else if (val(cr,0,i,0) > 0. && val(cr,0,i,0) < val(ibm0,0,i,0)-1e-10) {



            coord tempnfh = {-s*val(nfh.y,0,i,0), val(nfh.x,0,i,0), _val_higher_dimension};

            if (val(ch,0,i,0) >=1 && !tempnfh.y && !tempnfh.x && !tempnfh.y) {
                cf = 1;
            }
            else if (val(ch,0,i,0) <= 1e-10 && !tempnfh.y && !tempnfh.x && !tempnfh.y) {
                cf = 0;
            }
            else {
                double alphacr = immersed_alpha (val(c,0,i,0), val(ibm,0,i,0), tempnfh, val(alphaf,0,i,0), tempns, val(alphas,0,i,0), val(cr,0,i,0)
#line 1393 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 237 "./../my-vof-testv2.h"
);
                double newc = line_area(tempnfh.y, tempnfh.x, alphacr);
                cf = immersed_fraction (newc, tempnfh, alphacr, tempns, val(alphas,0,i,0), lhs, rhs, advVolume, 0);

                val(ct,0,0,0) = newc;
                val(ctid,0,0,0) = i;
            }







       }
       else
           cf = 0;
    }

    else {
        cf = 0;
    }

    val(flux,0,0,0) = cf*val(uf.y,0,0,0);
    val(fluxr.y,0,0,0) = val(flux,0,0,0);

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
     cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
     double ff = val(t,0,i,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,i,0)*Delta/2.;
     val(tflux,0,0,0) = ff*cf1*val(uf.y,0,0,0);
      }
      else
     val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 275 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(fm.y) && !is_constant(cm)){_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1); 
#line 156 "./../my-vof-testv2.h"
{              



    _stencil_val(ibmf_temp.y,0,0,0);; _stencil_val(uf.y,0,0,0);     



    







_stencil_val(ibm0,0,0,0);

    {;_stencil_val(cm,0,0,0);
      {;_stencil_val(cm,0,0,0);    }     }



;_stencil_val(nfh.x,0, o_stencil,0);_stencil_val(nfh.y,0,o_stencil,0);            
     

_stencil_val(c,0,0,0);    _stencil_val_a(ct,0,0,0); 
    _stencil_val_a(ctid,0,0,0);

{ 
          
{_stencil_val(ibm0,0,o_stencil,0);{ {

_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(alphaf,0, o_stencil,0);    
} 

{_stencil_val(ibm0,0,o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{ {
;_stencil_val(ns.x,0, o_stencil,0);_stencil_val(ns.y,0,o_stencil,0);   


        _stencil_val(ibmf_temp.y,0,0,0);









_stencil_val(cr,0,o_stencil,0);{
               
{_stencil_val(cr,0,o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{





              
#line 223 "./../my-vof-testv2.h"
          
{_stencil_val(cr,0,o_stencil,0);_stencil_val(cr,0, o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{ {



;_stencil_val(nfh.x,0, o_stencil,0);_stencil_val(nfh.y,0,o_stencil,0);

_stencil_val(ch,0,o_stencil,0);{
                  
              
{_stencil_val(ch,0,o_stencil,0);{
                  
              
{      
                _stencil_val(cr,0, o_stencil,0);_stencil_val(alphas,0, o_stencil,0);_stencil_val(alphaf,0, o_stencil,0);_stencil_val(ibm,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);     
                
_stencil_val(alphas,0, o_stencil,0);                

_stencil_val_a(ct,0,0,0);  
                _stencil_val_a(ctid,0,0,0);  
            }}            }}       







}
             
}       }}        }}
#line 206 "./../my-vof-testv2.h"
           
        
    
#line 254
}
          
     

}    }}    }}    

_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux,0,0,0); 
_stencil_val(flux,0,0,0);    _stencil_val_a(fluxr.y,0,0,0); 

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {               
     _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
_stencil_val(uf.y,0,0,0);     _stencil_val_a(tflux,0,0,0);  
      }
     
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 706
{
  if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 156 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../my-vof-testv2.h"
{



    double un = val(uf.y,0,0,0)*dt/(Delta*_const_fm.y*val(ibmf_temp.y,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));



    int i = -(s + 1.)/2.;







    if (val(ibm0,0,0,0) >= 1.)

    if (un*_const_fm.y*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*_const_fm.y*s/(val(cm,0,0,0) + 1e-30);

    double cf = 0;

    coord tempnf = {-s*val(nfh.y,0,i,0), val(nfh.x,0,i,0), _val_higher_dimension};
    coord lhs = {-0.5, -0.5, -0.5}, rhs = {s*un - 0.5, 0.5, 0.5};

    val(ct,0,0,0) = val(c,0,0,0);
    val(ctid,0,0,0) = 0;

    if (un == 0)
        cf = 0;
    else if (val(ibm0,0,i,0) >= 1.) {

        cf = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.)? val(c,0,i,0) : rectangle_fraction (tempnf, val(alphaf,0,i,0), lhs, rhs);
    }

    else if (val(ibm0,0,i,0) > 0. && val(ibm0,0,i,0) < 1.) {
        coord tempns = {-s*val(ns.y,0,i,0), val(ns.x,0,i,0), _val_higher_dimension};


        double advVolume = fabs(un)*val(ibmf_temp.y,0,0,0);
#line 206 "./../my-vof-testv2.h"
        if (val(cr,0,i,0) <= 0.)
            cf = 0.;
        else if (val(cr,0,i,0) >= val(ibm0,0,i,0)-1e-10) {





            cf = 1;
#line 223 "./../my-vof-testv2.h"
        }
        else if (val(cr,0,i,0) > 0. && val(cr,0,i,0) < val(ibm0,0,i,0)-1e-10) {



            coord tempnfh = {-s*val(nfh.y,0,i,0), val(nfh.x,0,i,0), _val_higher_dimension};

            if (val(ch,0,i,0) >=1 && !tempnfh.y && !tempnfh.x && !tempnfh.y) {
                cf = 1;
            }
            else if (val(ch,0,i,0) <= 1e-10 && !tempnfh.y && !tempnfh.x && !tempnfh.y) {
                cf = 0;
            }
            else {
                double alphacr = immersed_alpha (val(c,0,i,0), val(ibm,0,i,0), tempnfh, val(alphaf,0,i,0), tempns, val(alphas,0,i,0), val(cr,0,i,0)
#line 1393 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 237 "./../my-vof-testv2.h"
);
                double newc = line_area(tempnfh.y, tempnfh.x, alphacr);
                cf = immersed_fraction (newc, tempnfh, alphacr, tempns, val(alphas,0,i,0), lhs, rhs, advVolume, 0);

                val(ct,0,0,0) = newc;
                val(ctid,0,0,0) = i;
            }







       }
       else
           cf = 0;
    }

    else {
        cf = 0;
    }

    val(flux,0,0,0) = cf*val(uf.y,0,0,0);
    val(fluxr.y,0,0,0) = val(flux,0,0,0);

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
     cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
     double ff = val(t,0,i,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,i,0)*Delta/2.;
     val(tflux,0,0,0) = ff*cf1*val(uf.y,0,0,0);
      }
      else
     val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 275 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(fm.y) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1); 
#line 156 "./../my-vof-testv2.h"
{              



    _stencil_val(ibmf_temp.y,0,0,0);_stencil_val(fm.y,0,0,0); _stencil_val(uf.y,0,0,0);     



    







_stencil_val(ibm0,0,0,0);

    {_stencil_val(fm.y,0,0,0);;
      {_stencil_val(fm.y,0,0,0);;    }     }



;_stencil_val(nfh.x,0, o_stencil,0);_stencil_val(nfh.y,0,o_stencil,0);            
     

_stencil_val(c,0,0,0);    _stencil_val_a(ct,0,0,0); 
    _stencil_val_a(ctid,0,0,0);

{ 
          
{_stencil_val(ibm0,0,o_stencil,0);{ {

_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(alphaf,0, o_stencil,0);    
} 

{_stencil_val(ibm0,0,o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{ {
;_stencil_val(ns.x,0, o_stencil,0);_stencil_val(ns.y,0,o_stencil,0);   


        _stencil_val(ibmf_temp.y,0,0,0);









_stencil_val(cr,0,o_stencil,0);{
               
{_stencil_val(cr,0,o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{





              
#line 223 "./../my-vof-testv2.h"
          
{_stencil_val(cr,0,o_stencil,0);_stencil_val(cr,0, o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{ {



;_stencil_val(nfh.x,0, o_stencil,0);_stencil_val(nfh.y,0,o_stencil,0);

_stencil_val(ch,0,o_stencil,0);{
                  
              
{_stencil_val(ch,0,o_stencil,0);{
                  
              
{      
                _stencil_val(cr,0, o_stencil,0);_stencil_val(alphas,0, o_stencil,0);_stencil_val(alphaf,0, o_stencil,0);_stencil_val(ibm,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);     
                
_stencil_val(alphas,0, o_stencil,0);                

_stencil_val_a(ct,0,0,0);  
                _stencil_val_a(ctid,0,0,0);  
            }}            }}       







}
             
}       }}        }}
#line 206 "./../my-vof-testv2.h"
           
        
    
#line 254
}
          
     

}    }}    }}    

_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux,0,0,0); 
_stencil_val(flux,0,0,0);    _stencil_val_a(fluxr.y,0,0,0); 

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {               
     _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
_stencil_val(uf.y,0,0,0);     _stencil_val_a(tflux,0,0,0);  
      }
     
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 706
{
  if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 156 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../my-vof-testv2.h"
{



    double un = val(uf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0)*val(ibmf_temp.y,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));



    int i = -(s + 1.)/2.;







    if (val(ibm0,0,0,0) >= 1.)

    if (un*val(fm.y,0,0,0)*s/(_const_cm + 1e-30) > cfl)
      cfl = un*val(fm.y,0,0,0)*s/(_const_cm + 1e-30);

    double cf = 0;

    coord tempnf = {-s*val(nfh.y,0,i,0), val(nfh.x,0,i,0), _val_higher_dimension};
    coord lhs = {-0.5, -0.5, -0.5}, rhs = {s*un - 0.5, 0.5, 0.5};

    val(ct,0,0,0) = val(c,0,0,0);
    val(ctid,0,0,0) = 0;

    if (un == 0)
        cf = 0;
    else if (val(ibm0,0,i,0) >= 1.) {

        cf = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.)? val(c,0,i,0) : rectangle_fraction (tempnf, val(alphaf,0,i,0), lhs, rhs);
    }

    else if (val(ibm0,0,i,0) > 0. && val(ibm0,0,i,0) < 1.) {
        coord tempns = {-s*val(ns.y,0,i,0), val(ns.x,0,i,0), _val_higher_dimension};


        double advVolume = fabs(un)*val(ibmf_temp.y,0,0,0);
#line 206 "./../my-vof-testv2.h"
        if (val(cr,0,i,0) <= 0.)
            cf = 0.;
        else if (val(cr,0,i,0) >= val(ibm0,0,i,0)-1e-10) {





            cf = 1;
#line 223 "./../my-vof-testv2.h"
        }
        else if (val(cr,0,i,0) > 0. && val(cr,0,i,0) < val(ibm0,0,i,0)-1e-10) {



            coord tempnfh = {-s*val(nfh.y,0,i,0), val(nfh.x,0,i,0), _val_higher_dimension};

            if (val(ch,0,i,0) >=1 && !tempnfh.y && !tempnfh.x && !tempnfh.y) {
                cf = 1;
            }
            else if (val(ch,0,i,0) <= 1e-10 && !tempnfh.y && !tempnfh.x && !tempnfh.y) {
                cf = 0;
            }
            else {
                double alphacr = immersed_alpha (val(c,0,i,0), val(ibm,0,i,0), tempnfh, val(alphaf,0,i,0), tempns, val(alphas,0,i,0), val(cr,0,i,0)
#line 1393 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 237 "./../my-vof-testv2.h"
);
                double newc = line_area(tempnfh.y, tempnfh.x, alphacr);
                cf = immersed_fraction (newc, tempnfh, alphacr, tempns, val(alphas,0,i,0), lhs, rhs, advVolume, 0);

                val(ct,0,0,0) = newc;
                val(ctid,0,0,0) = i;
            }







       }
       else
           cf = 0;
    }

    else {
        cf = 0;
    }

    val(flux,0,0,0) = cf*val(uf.y,0,0,0);
    val(fluxr.y,0,0,0) = val(flux,0,0,0);

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
     cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
     double ff = val(t,0,i,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,i,0)*Delta/2.;
     val(tflux,0,0,0) = ff*cf1*val(uf.y,0,0,0);
      }
      else
     val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 275 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else {_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 156, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1); 
#line 156 "./../my-vof-testv2.h"
{              



    _stencil_val(ibmf_temp.y,0,0,0);; _stencil_val(uf.y,0,0,0);     



    







_stencil_val(ibm0,0,0,0);

    {;;
      {;;    }     }



;_stencil_val(nfh.x,0, o_stencil,0);_stencil_val(nfh.y,0,o_stencil,0);            
     

_stencil_val(c,0,0,0);    _stencil_val_a(ct,0,0,0); 
    _stencil_val_a(ctid,0,0,0);

{ 
          
{_stencil_val(ibm0,0,o_stencil,0);{ {

_stencil_val(c,0,o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(alphaf,0, o_stencil,0);    
} 

{_stencil_val(ibm0,0,o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{ {
;_stencil_val(ns.x,0, o_stencil,0);_stencil_val(ns.y,0,o_stencil,0);   


        _stencil_val(ibmf_temp.y,0,0,0);









_stencil_val(cr,0,o_stencil,0);{
               
{_stencil_val(cr,0,o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{





              
#line 223 "./../my-vof-testv2.h"
          
{_stencil_val(cr,0,o_stencil,0);_stencil_val(cr,0, o_stencil,0);_stencil_val(ibm0,0, o_stencil,0);{ {



;_stencil_val(nfh.x,0, o_stencil,0);_stencil_val(nfh.y,0,o_stencil,0);

_stencil_val(ch,0,o_stencil,0);{
                  
              
{_stencil_val(ch,0,o_stencil,0);{
                  
              
{      
                _stencil_val(cr,0, o_stencil,0);_stencil_val(alphas,0, o_stencil,0);_stencil_val(alphaf,0, o_stencil,0);_stencil_val(ibm,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);     
                
_stencil_val(alphas,0, o_stencil,0);                

_stencil_val_a(ct,0,0,0);  
                _stencil_val_a(ctid,0,0,0);  
            }}            }}       







}
             
}       }}        }}
#line 206 "./../my-vof-testv2.h"
           
        
    
#line 254
}
          
     

}    }}    }}    

_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux,0,0,0); 
_stencil_val(flux,0,0,0);    _stencil_val_a(fluxr.y,0,0,0); 

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {               
     _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
_stencil_val(uf.y,0,0,0);     _stencil_val_a(tflux,0,0,0);  
      }
     
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags; 
#line 706
{
  if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 156 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 156 "./../my-vof-testv2.h"
{



    double un = val(uf.y,0,0,0)*dt/(Delta*_const_fm.y*val(ibmf_temp.y,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));



    int i = -(s + 1.)/2.;







    if (val(ibm0,0,0,0) >= 1.)

    if (un*_const_fm.y*s/(_const_cm + 1e-30) > cfl)
      cfl = un*_const_fm.y*s/(_const_cm + 1e-30);

    double cf = 0;

    coord tempnf = {-s*val(nfh.y,0,i,0), val(nfh.x,0,i,0), _val_higher_dimension};
    coord lhs = {-0.5, -0.5, -0.5}, rhs = {s*un - 0.5, 0.5, 0.5};

    val(ct,0,0,0) = val(c,0,0,0);
    val(ctid,0,0,0) = 0;

    if (un == 0)
        cf = 0;
    else if (val(ibm0,0,i,0) >= 1.) {

        cf = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.)? val(c,0,i,0) : rectangle_fraction (tempnf, val(alphaf,0,i,0), lhs, rhs);
    }

    else if (val(ibm0,0,i,0) > 0. && val(ibm0,0,i,0) < 1.) {
        coord tempns = {-s*val(ns.y,0,i,0), val(ns.x,0,i,0), _val_higher_dimension};


        double advVolume = fabs(un)*val(ibmf_temp.y,0,0,0);
#line 206 "./../my-vof-testv2.h"
        if (val(cr,0,i,0) <= 0.)
            cf = 0.;
        else if (val(cr,0,i,0) >= val(ibm0,0,i,0)-1e-10) {





            cf = 1;
#line 223 "./../my-vof-testv2.h"
        }
        else if (val(cr,0,i,0) > 0. && val(cr,0,i,0) < val(ibm0,0,i,0)-1e-10) {



            coord tempnfh = {-s*val(nfh.y,0,i,0), val(nfh.x,0,i,0), _val_higher_dimension};

            if (val(ch,0,i,0) >=1 && !tempnfh.y && !tempnfh.x && !tempnfh.y) {
                cf = 1;
            }
            else if (val(ch,0,i,0) <= 1e-10 && !tempnfh.y && !tempnfh.x && !tempnfh.y) {
                cf = 0;
            }
            else {
                double alphacr = immersed_alpha (val(c,0,i,0), val(ibm,0,i,0), tempnfh, val(alphaf,0,i,0), tempns, val(alphas,0,i,0), val(cr,0,i,0)
#line 1393 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 237 "./../my-vof-testv2.h"
);
                double newc = line_area(tempnfh.y, tempnfh.x, alphacr);
                cf = immersed_fraction (newc, tempnfh, alphacr, tempns, val(alphas,0,i,0), lhs, rhs, advVolume, 0);

                val(ct,0,0,0) = newc;
                val(ctid,0,0,0) = i;
            }







       }
       else
           cf = 0;
    }

    else {
        cf = 0;
    }

    val(flux,0,0,0) = cf*val(uf.y,0,0,0);
    val(fluxr.y,0,0,0) = val(flux,0,0,0);

    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
     cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
     double ff = val(t,0,i,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,i,0)*Delta/2.;
     val(tflux,0,0,0) = ff*cf1*val(uf.y,0,0,0);
      }
      else
     val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
}      
#line 447
}
  }
}

#line 696
}
#line 275 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "src/vof.h:%d: warning: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      284, cfl - 0.5), fflush (ferr);

  double crsum = 0, crsumclamp = 0;
  if(!is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 287, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 288 "./../my-vof-testv2.h"
{_stencil_val(ibm0,0,0,0); {









_stencil_val(ibm0,0,0,0); _stencil_val(ibm0,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(ibm0,0,0,0);
        for (int _i = -1; _i <= 1; _i += 1)
            {_stencil_val(ctid,0,_i,0); _stencil_val(ibm0,0,_i,0); _stencil_val(ibm0,0,_i,0);
                { _stencil_val(ct,0,_i,0);_stencil_val_a(c,0,0,0); }         }  
#line 298 "./../my-vof-testv2.h"
                 



       


_stencil_val(cm,0,0,0);




_stencil_val(flux,0,0,0); _stencil_val(flux,0,1,0); _stencil_val(cc,0,0,0);_stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0); _stencil_val(divs.y,0,0,0);      _stencil_val_r(c,0,0,0);
_stencil_val(flux,0,0,0); _stencil_val(flux,0,1,0); _stencil_val(cc,0,0,0);_stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0); _stencil_val(divs.y,0,0,0);      _stencil_val_r(cr,0,0,0);      

      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
        {_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,1,0); _stencil_val(tc,0,0,0);_stencil_val(ibmf.y,0,1,0);_stencil_val(uf.y,0,1,0); _stencil_val(ibmf.y,0,0,0);_stencil_val(uf.y,0,0,0);_stencil_val(cm,0,0,0);_stencil_val_r(t,0,0,0);     }}} 







_stencil_val(cr,0,0,0);_stencil_val(cm,0,0,0);       
_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm0,0,0,0);_stencil_val(ibm0,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(cm,0,0,0);    
}   }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (+:crsum) reduction (+:crsumclamp)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 288 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 288 "./../my-vof-testv2.h"
if (val(ibm0,0,0,0) > 0) {
#line 298 "./../my-vof-testv2.h"
      if (val(ibm0,0,0,0) > 0. && val(ibm0,0,0,0) < 1. && val(cr,0,0,0) > 0. && val(cr,0,0,0) < val(ibm0,0,0,0)-1e-10)
        for (int _i = -1; _i <= 1; _i += 1)
            if (val(ctid,0,_i,0) == -_i && val(ibm0,0,_i,0) > 0. && val(ibm0,0,_i,0) < 1.)
                val(c,0,0,0) = val(ct,0,_i,0);



      double val = val(cm,0,0,0);




      val(c,0,0,0) += dt*(val(flux,0,0,0) - val(flux,0,1,0) + val(cc,0,0,0)*(val(uf.y,0,1,0) - val(uf.y,0,0,0) - val(divs.y,0,0,0)))/(val*Delta);
      val(cr,0,0,0) += dt*(val(flux,0,0,0) - val(flux,0,1,0) + val(cc,0,0,0)*(val(uf.y,0,1,0) - val(uf.y,0,0,0) - val(divs.y,0,0,0)))/(val*Delta);

      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
        val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,0,1,0) + val(tc,0,0,0)*(val(ibmf.y,0,1,0)*val(uf.y,0,1,0) - val(ibmf.y,0,0,0)*val(uf.y,0,0,0)))/(val(cm,0,0,0)*Delta);}}







      crsum += val(cr,0,0,0)*pow(Delta, 2)*val(cm,0,0,0);
      crsumclamp += ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm0,0,0,0)) ? (val(ibm0,0,0,0)) : (val(cr,0,0,0)))*pow(Delta, 2)*val(cm,0,0,0);
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 325 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&crsumclamp,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&crsum,MPI_DOUBLE,MPI_SUM,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 287, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 288 "./../my-vof-testv2.h"
{_stencil_val(ibm0,0,0,0); {









_stencil_val(ibm0,0,0,0); _stencil_val(ibm0,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(ibm0,0,0,0);
        for (int _i = -1; _i <= 1; _i += 1)
            {_stencil_val(ctid,0,_i,0); _stencil_val(ibm0,0,_i,0); _stencil_val(ibm0,0,_i,0);
                { _stencil_val(ct,0,_i,0);_stencil_val_a(c,0,0,0); }         }



;




_stencil_val(flux,0,0,0); _stencil_val(flux,0,1,0); _stencil_val(cc,0,0,0);_stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0); _stencil_val(divs.y,0,0,0);      _stencil_val_r(c,0,0,0);
_stencil_val(flux,0,0,0); _stencil_val(flux,0,1,0); _stencil_val(cc,0,0,0);_stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0); _stencil_val(divs.y,0,0,0);      _stencil_val_r(cr,0,0,0);      

      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
        {_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,1,0); _stencil_val(tc,0,0,0);_stencil_val(ibmf.y,0,1,0);_stencil_val(uf.y,0,1,0); _stencil_val(ibmf.y,0,0,0);_stencil_val(uf.y,0,0,0);;_stencil_val_r(t,0,0,0);     }}} 







_stencil_val(cr,0,0,0);;       
_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(ibm0,0,0,0);_stencil_val(ibm0,0,0,0);_stencil_val(cr,0,0,0);;    
}   }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction (+:crsum) reduction (+:crsumclamp)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 288 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 288 "./../my-vof-testv2.h"
if (val(ibm0,0,0,0) > 0) {
#line 298 "./../my-vof-testv2.h"
      if (val(ibm0,0,0,0) > 0. && val(ibm0,0,0,0) < 1. && val(cr,0,0,0) > 0. && val(cr,0,0,0) < val(ibm0,0,0,0)-1e-10)
        for (int _i = -1; _i <= 1; _i += 1)
            if (val(ctid,0,_i,0) == -_i && val(ibm0,0,_i,0) > 0. && val(ibm0,0,_i,0) < 1.)
                val(c,0,0,0) = val(ct,0,_i,0);



      double val = _const_cm;




      val(c,0,0,0) += dt*(val(flux,0,0,0) - val(flux,0,1,0) + val(cc,0,0,0)*(val(uf.y,0,1,0) - val(uf.y,0,0,0) - val(divs.y,0,0,0)))/(val*Delta);
      val(cr,0,0,0) += dt*(val(flux,0,0,0) - val(flux,0,1,0) + val(cc,0,0,0)*(val(uf.y,0,1,0) - val(uf.y,0,0,0) - val(divs.y,0,0,0)))/(val*Delta);

      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
        val(t,0,0,0) += dt*(val(tflux,0,0,0) - val(tflux,0,1,0) + val(tc,0,0,0)*(val(ibmf.y,0,1,0)*val(uf.y,0,1,0) - val(ibmf.y,0,0,0)*val(uf.y,0,0,0)))/(_const_cm*Delta);}}







      crsum += val(cr,0,0,0)*pow(Delta, 2)*_const_cm;
      crsumclamp += ( (val(cr,0,0,0)) < 0 ? 0 : (val(cr,0,0,0)) > (val(ibm0,0,0,0)) ? (val(ibm0,0,0,0)) : (val(cr,0,0,0)))*pow(Delta, 2)*_const_cm;
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 325 "./../my-vof-testv2.h"
{mpi_all_reduce_array(&crsumclamp,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&crsum,MPI_DOUBLE,MPI_SUM,1);}}

  if (!approx_equal_double (crsum, crsumclamp, 1e-14))
    fprintf (ferr, "WARNING %g: crsum != crsumclamp. crsum=%0.15g crsumclamp=%0.15g err=%g\n",
        indicator.y, crsum, crsumclamp, get_percent_error(crsum, crsumclamp));
#line 352 "./../my-vof-testv2.h"
  double verror = redistribute_volume (c, cr, ibm);
#line 362 "./../my-vof-testv2.h"
  (void) verror;  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 364, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 364 "./../my-vof-testv2.h"
{
_stencil_val(cr,0,0,0);
        { _stencil_val_a(c,0,0,0);_stencil_val_a(cr,0,0,0);   }  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 364 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 364 "./../my-vof-testv2.h"
{
    if (val(cr,0,0,0) < 1e-11)
        val(cr,0,0,0) = val(c,0,0,0) = 0;
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 369 "./../my-vof-testv2.h"
reconstruction (c, nf, alphaf);





  trash(((scalar[]){ch,{-1}}));  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 376, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 376 "./../my-vof-testv2.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(cr,0,0,0); _stencil_val(ibm,0,0,0);{
        {_stencil_val_a(ch,0,0,0);  }
        
{ _stencil_val(cr,0,0,0);_stencil_val_a(ch,0,0,0); }}  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 376 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 376 "./../my-vof-testv2.h"
{
    if (val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1 && val(cr,0,0,0) >= val(ibm,0,0,0)-1e-10)
        val(ch,0,0,0) = 1.;
    else
        val(ch,0,0,0) = val(cr,0,0,0);
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 382 "./../my-vof-testv2.h"
boundary_internal ((scalar *)((scalar[]){ch,{-1}}), "./../my-vof-testv2.h", 382);
  set_contact_angle_tension(ch, cr, ibm0, nf, alphaf, ns, alphas);



  if (!last)
      reconstruction (ch, nfh, alphafh);

  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){ctid,ct,flux,{-1}}));
}
#line 401 "./../my-vof-testv2.h"
void clean_fluid_real (scalar f, scalar fr, scalar ibm);

void vof_advection (scalar * interfaces, int i)
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
    vector  nf=new_vector("nf"),  nfh=new_vector("nfh"),  ns=new_vector("ns");
    scalar  alphaf=new_scalar("alphaf"),  alphafh=new_scalar("alphafh"),  alphas=new_scalar("alphas");

    trash(((scalar[]){ch,{-1}}));

    if (i == 0)
        {        
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 412, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
            
#line 413 "./../my-vof-testv2.h"
{ _stencil_val(c,0,0,0);_stencil_val_a(ch,0,0,0); }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;            
#line 413 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 413 "./../my-vof-testv2.h"
val(ch,0,0,0) = val(c,0,0,0);}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 413 "./../my-vof-testv2.h"
}
#line 423 "./../my-vof-testv2.h"
    scalar  cc=new_scalar("cc"), * tcl = NULL, * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {

      scalar tc = new_scalar("tc");
      tcl = list_append (tcl, tc);


      if (_attribute[t.i].refine != vof_concentration_refine) {
 _attribute[t.i].refine = _attribute[t.i].prolongation = vof_concentration_refine;
 _attribute[t.i].restriction = restriction_volume_average;
 _attribute[t.i].dirty = true;
 _attribute[t.i].c = c;
      }

    }}}    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 438, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 438 "./../my-vof-testv2.h"
{

      scalar t, tc;
      {scalar*_i0= tcl;scalar*_i1= tracers;if(_i0)for(tc=*_i0,t=*_i1;_i0->i>= 0;tc=*++_i0,t=*++_i1){ {
 if (_attribute[t.i].inverse)
   { _stencil_val(c,0,0,0); _stencil_val(t,0,0,0); _stencil_val(c,0,0,0);_stencil_val_a(tc,0,0,0);       }
 else
   { _stencil_val(c,0,0,0); _stencil_val(t,0,0,0);_stencil_val(c,0,0,0);_stencil_val_a(tc,0,0,0);      }
      }}}

    }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 438 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 438 "./../my-vof-testv2.h"
{

      scalar t, tc;
      {scalar*_i0= tcl;scalar*_i1= tracers;if(_i0)for(tc=*_i0,t=*_i1;_i0->i>= 0;tc=*++_i0,t=*++_i1){ {
 if (_attribute[t.i].inverse)
   val(tc,0,0,0) = val(c,0,0,0) < 0.5 ? val(t,0,0,0)/(1. - val(c,0,0,0)) : 0.;
 else
   val(tc,0,0,0) = val(c,0,0,0) > 0.5 ? val(t,0,0,0)/val(c,0,0,0) : 0.;
      }}}

    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}    
#line 450 "./../my-vof-testv2.h"
reconstruction (c, nf, alphaf);
    reconstruction_ibm (ibm, ibmf, ns, alphas);
    reconstruction (ch, nfh, alphafh);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 454, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 454 "./../my-vof-testv2.h"
{
        if (i == 0) {
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{ {
_stencil_val(c,0,0,0);_stencil_val(nf.x,0,0,0); _stencil_val(nf.y,0,0,0);; _stencil_val(alphaf,0,0,0);
_stencil_val(ns.x,0,0,0); _stencil_val(ns.y,0,0,0);; _stencil_val(alphas,0,0,0); 

_stencil_val(ibm,0,0,0);                
#line 457
_stencil_val_a(cr,0,0,0);    
                                           
                                          
                                            
            }
            
{ _stencil_val(c,0,0,0);_stencil_val(ibm,0,0,0);_stencil_val_a(cr,0,0,0); }}        
}
_stencil_val(cr,0,0,0);_stencil_val(ibm,0,0,0);        _stencil_val_a(cc,0,0,0);

_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);{ {
#line 480 "./../my-vof-testv2.h"
            
                  {_stencil_val_a(divs.x,0,0,0);  }                  {_stencil_val_a(divs.y,0,0,0);  }

        } 
{
            
                {_stencil_val_a(divs.x,0,0,0);  }                {_stencil_val_a(divs.y,0,0,0);  }
        }}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 454 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 454 "./../my-vof-testv2.h"
{
        if (i == 0) {
            if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7) && (val(c,0,0,0) > 0+1e-7 && val(c,0,0,0) < 1-1e-7)) {
                val(cr,0,0,0) = immersed_fraction (val(c,0,0,0), (coord){val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension}, val(alphaf,0,0,0)
,                                         (coord){val(ns.x,0,0,0), val(ns.y,0,0,0), _val_higher_dimension}, val(alphas,0,0,0)
,                                         (coord){-0.5, -0.5, -0.5}
,                                         (coord){0.5, 0.5, 0.5}, 0
#line 1081 "./../ibm-gcm-vof-test.h"
, 0
#line 460 "./../my-vof-testv2.h"
) * val(ibm,0,0,0);
            }
        else
            val(cr,0,0,0) = val(c,0,0,0)*val(ibm,0,0,0);
        }
        val(cc,0,0,0) = (val(cr,0,0,0) > 0.5*val(ibm,0,0,0));

        if ((val(ibm,0,0,0) > 0+1e-7 && val(ibm,0,0,0) < 1-1e-7)) {
#line 480 "./../my-vof-testv2.h"
            
                  val(divs.x,0,0,0) = 0;                  val(divs.y,0,0,0) = 0;

        }
        else {
            
                val(divs.x,0,0,0) = 0;                val(divs.y,0,0,0) = 0;
        }
    }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 490, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 490 "./../my-vof-testv2.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 490 "./../my-vof-testv2.h"
{ 
_stencil_val(ibmf.x,0,0,0);        _stencil_val_a(ibmf_temp.x,0,0,0); 
_stencil_val(ibmf_temp.x,0,0,0);        _stencil_val_r(uf.x,0,0,0); 
    } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 490 "./../my-vof-testv2.h"
{ 
_stencil_val(ibmf.y,0,0,0);        _stencil_val_a(ibmf_temp.y,0,0,0); 
_stencil_val(ibmf_temp.y,0,0,0);        _stencil_val_r(uf.y,0,0,0); 
    }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 490 "./../my-vof-testv2.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 490 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 490 "./../my-vof-testv2.h"
{
        val(ibmf_temp.x,0,0,0) = val(ibmf.x,0,0,0);
        val(uf.x,0,0,0) *= val(ibmf_temp.x,0,0,0);
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 490 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 490 "./../my-vof-testv2.h"
{
        val(ibmf_temp.y,0,0,0) = val(ibmf.y,0,0,0);
        val(uf.y,0,0,0) *= val(ibmf_temp.y,0,0,0);
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 493 "./../my-vof-testv2.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}    
#line 495 "./../my-vof-testv2.h"
boundary_internal ((scalar *)((vector[]){uf,{{-1},{-1}}}), "./../my-vof-testv2.h", 495);
#line 504 "./../my-vof-testv2.h"
    void (* sweep[2]) (scalar, scalar, scalar, scalar *, scalar, scalar,
                               vector, vector, scalar, vector, scalar, vector, scalar, int);
    int d = 0;
    
      sweep[d++] = sweep_x;      sweep[d++] = sweep_y;
    for (d = 0; d < 2; d++) {







        int last = (d == 2 - 1);
        sweep[(i + d) % 2] (c, ch, cc, tcl, cr, ibm, ibmf, ns, alphas,
                                  nf, alphaf, nfh, alphafh, last);
    }
    delete (tcl), pfree (tcl,__func__,__FILE__,__LINE__);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-vof-testv2.h", .line = 523, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 523 "./../my-vof-testv2.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
        
#line 524 "./../my-vof-testv2.h"
{_stencil_val(ibmf_temp.x,0,0,0);_stencil_val_r(uf.x,0,0,0);    } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
        
#line 524 "./../my-vof-testv2.h"
{_stencil_val(ibmf_temp.y,0,0,0);_stencil_val_r(uf.y,0,0,0);    }}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 523 "./../my-vof-testv2.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);        
#line 524 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 524 "./../my-vof-testv2.h"
val(uf.x,0,0,0) /= (val(ibmf_temp.x,0,0,0) + 1e-30);}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);        
#line 524 "./../my-vof-testv2.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 524 "./../my-vof-testv2.h"
val(uf.y,0,0,0) /= (val(ibmf_temp.y,0,0,0) + 1e-30);}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 524 "./../my-vof-testv2.h"
}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 524 "./../my-vof-testv2.h"
delete((scalar*)((scalar[]){cc,alphas,alphafh,alphaf,ns.x,ns.y,nfh.x,nfh.y,nf.x,nf.y,{-1}}));
#line 534 "./../my-vof-testv2.h"
  }}}
}

static int vof_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int vof_0(const int i,const double t,Event *_ev){tracing("vof_0","./../my-vof-testv2.h",537);
{vof_advection (interfaces, i);  }{end_tracing("vof_0","./../my-vof-testv2.h",538);return 0;}end_tracing("vof_0","./../my-vof-testv2.h",538);}
#line 15 "./../my-two-phase.h"





scalar  f={41}, * interfaces =((scalar[]) {{41},{-1}});

#line 1 "../my-two-phase-generic.h"
#line 1 "./../my-two-phase-generic.h"
double rho1 = 1., mu1 = 0., rho2 = 1., mu2 = 0.;





vector  alphav={{42},{43}};
scalar  rhov={44};

static int defaults_3_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int defaults_3(const int i,const double t,Event *_ev){tracing("defaults_3","./../my-two-phase-generic.h",10);
{
  alpha = alphav;
  rho = rhov;





  if (mu1 || mu2)
    mu = new_face_vector("mu");




  display ("draw_vof (c = 'f');"
#line 494 "/home/spencer/basilisk/src/common.h"
, false
#line 25 "./../my-two-phase-generic.h"
);
}{end_tracing("defaults_3","./../my-two-phase-generic.h",26);return 0;}end_tracing("defaults_3","./../my-two-phase-generic.h",26);}
#line 50
static int tracer_advection_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 50 "./../my-two-phase-generic.h"
      static int tracer_advection_0(const int i,const double t,Event *_ev){tracing("tracer_advection_0","./../my-two-phase-generic.h",50);
{
#line 76 "./../my-two-phase-generic.h"
  _attribute[f.i].prolongation = refine_bilinear;
  _attribute[f.i].dirty = true;

}{end_tracing("tracer_advection_0","./../my-two-phase-generic.h",79);return 0;}end_tracing("tracer_advection_0","./../my-two-phase-generic.h",79);}



static int properties_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int properties_0(const int i,const double t,Event *_ev){tracing("properties_0","./../my-two-phase-generic.h",83);
{
#line 128
if(!is_constant(fm.x)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-two-phase-generic.h", .line = 128, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 128 "./../my-two-phase-generic.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 128 "./../my-two-phase-generic.h"
{    



         _stencil_val(cr,-1,0,0);_stencil_val(cr,0,0,0); 

_stencil_val(ibmf.x,0,0,0);        _stencil_val_a(alphav.x,0,0,0);                  
        if (mu1 || mu2) {
          vector muv = mu; 
_stencil_val(fm.x,0,0,0);           _stencil_val_a(muv.x,0,0,0);                  
        }
    } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 128 "./../my-two-phase-generic.h"
{    



         _stencil_val(cr,0,-1,0);_stencil_val(cr,0,0,0); 

_stencil_val(ibmf.y,0,0,0);        _stencil_val_a(alphav.y,0,0,0);                  
        if (mu1 || mu2) {
          vector muv = mu; 
_stencil_val(fm.y,0,0,0);           _stencil_val_a(muv.y,0,0,0);                  
        }
    }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 128 "./../my-two-phase-generic.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 128 "./../my-two-phase-generic.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 128 "./../my-two-phase-generic.h"
{



        double ff = (val(cr,0,0,0) + val(cr,-1,0,0))/2.;

        val(alphav.x,0,0,0) = val(ibmf.x,0,0,0)/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
        if (mu1 || mu2) {
          vector muv = mu;
           val(muv.x,0,0,0) = val(fm.x,0,0,0)*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
        }
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 128 "./../my-two-phase-generic.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 128 "./../my-two-phase-generic.h"
{



        double ff = (val(cr,0,0,0) + val(cr,0,-1,0))/2.;

        val(alphav.y,0,0,0) = val(ibmf.y,0,0,0)/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
        if (mu1 || mu2) {
          vector muv = mu;
           val(muv.y,0,0,0) = val(fm.y,0,0,0)*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
        }
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 139 "./../my-two-phase-generic.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 139 "./../my-two-phase-generic.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-two-phase-generic.h", .line = 128, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 128 "./../my-two-phase-generic.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 128 "./../my-two-phase-generic.h"
{    



         _stencil_val(cr,-1,0,0);_stencil_val(cr,0,0,0); 

_stencil_val(ibmf.x,0,0,0);        _stencil_val_a(alphav.x,0,0,0);                  
        if (mu1 || mu2) {
          vector muv = mu;
;           _stencil_val_a(muv.x,0,0,0);                  
        }
    } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 128 "./../my-two-phase-generic.h"
{    



         _stencil_val(cr,0,-1,0);_stencil_val(cr,0,0,0); 

_stencil_val(ibmf.y,0,0,0);        _stencil_val_a(alphav.y,0,0,0);                  
        if (mu1 || mu2) {
          vector muv = mu;
;           _stencil_val_a(muv.y,0,0,0);                  
        }
    }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 128 "./../my-two-phase-generic.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 128 "./../my-two-phase-generic.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 128 "./../my-two-phase-generic.h"
{



        double ff = (val(cr,0,0,0) + val(cr,-1,0,0))/2.;

        val(alphav.x,0,0,0) = val(ibmf.x,0,0,0)/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
        if (mu1 || mu2) {
          vector muv = mu;
           val(muv.x,0,0,0) = _const_fm.x*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
        }
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 128 "./../my-two-phase-generic.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 128 "./../my-two-phase-generic.h"
{



        double ff = (val(cr,0,0,0) + val(cr,0,-1,0))/2.;

        val(alphav.y,0,0,0) = val(ibmf.y,0,0,0)/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
        if (mu1 || mu2) {
          vector muv = mu;
           val(muv.y,0,0,0) = _const_fm.y*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
        }
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 139 "./../my-two-phase-generic.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 139 "./../my-two-phase-generic.h"
}
  
#line 151 "./../my-two-phase-generic.h"
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-two-phase-generic.h", .line = 151, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 151 "./../my-two-phase-generic.h"
{





_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);_stencil_val(cr,0,0,0);    _stencil_val_a(rhov,0,0,0);                   





  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 151 "./../my-two-phase-generic.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 151 "./../my-two-phase-generic.h"
{





    val(rhov,0,0,0) = (( (val(cr,0,0,0)) < 0. ? 0. : (val(cr,0,0,0)) > 1. ? 1. : (val(cr,0,0,0)))*(rho1 - rho2) + rho2);





  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 166 "./../my-two-phase-generic.h"
_attribute[f.i].prolongation = fraction_refine;
  _attribute[f.i].dirty = true;

}{end_tracing("properties_0","./../my-two-phase-generic.h",169);return 0;}end_tracing("properties_0","./../my-two-phase-generic.h",169);}
#line 31 "./../my-iforce.h"
static int defaults_4_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}
#line 23 "./../my-two-phase.h"
#line 9 "sessile-ibm-axi-osc.c"
#line 1 "../my-tension.h"
#line 1 "./../my-tension.h"
#line 15 "./../my-tension.h"
#line 1 "../my-iforce.h"
#line 1 "./../my-iforce.h"
#line 21 "./../my-iforce.h"










      static int defaults_4(const int i,const double t,Event *_ev){tracing("defaults_4","./../my-iforce.h",31); {
  if (is_constant(a.x)) {
    a = new_face_vector("a");
if(!is_constant(a.x)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-iforce.h", .line = 34, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 34 "./../my-iforce.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 34 "./../my-iforce.h"
{
      _stencil_val_a(a.x,0,0,0);
_stencil_val(a.x,0,0,0);    
} 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 34 "./../my-iforce.h"
{
      _stencil_val_a(a.y,0,0,0);
_stencil_val(a.y,0,0,0);    
}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 34 "./../my-iforce.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 34 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 34 "./../my-iforce.h"
{
      val(a.x,0,0,0) = 0.;
      dimensional (val(a.x,0,0,0) == Delta/( DT*DT));
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 34 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 34 "./../my-iforce.h"
{
      val(a.y,0,0,0) = 0.;
      dimensional (val(a.y,0,0,0) == Delta/( DT*DT));
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 37 "./../my-iforce.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 37 "./../my-iforce.h"
}else {_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX]};NOT_UNUSED(_const_a);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-iforce.h", .line = 34, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 34 "./../my-iforce.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 34 "./../my-iforce.h"
{
      _stencil_val_a(a.x,0,0,0);
;    
} 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 34 "./../my-iforce.h"
{
      _stencil_val_a(a.y,0,0,0);
;    
}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 34 "./../my-iforce.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig); 
#line 34 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 34 "./../my-iforce.h"
{
      _const_a.x = 0.;
      dimensional (_const_a.x == Delta/( DT*DT));
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg); 
#line 34 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 34 "./../my-iforce.h"
{
      _const_a.y = 0.;
      dimensional (_const_a.y == Delta/( DT*DT));
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 37 "./../my-iforce.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 37 "./../my-iforce.h"
}
  }
}{end_tracing("defaults_4","./../my-iforce.h",39);return 0;}end_tracing("defaults_4","./../my-iforce.h",39);}






static int acceleration_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int acceleration_1(const int i,const double t,Event *_ev){tracing("acceleration_1","./../my-iforce.h",46);
{





  scalar * list = NULL;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
    if (_attribute[f.i].phi.i) {
      list = list_add (list, f);
  






      
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-iforce.h", .line = 63, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 64 "./../my-iforce.h"
{_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val_a(f,0,0,0);               }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 64 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 64 "./../my-iforce.h"
val(f,0,0,0) = ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)));}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}    
#line 65 "./../my-iforce.h"
}}}
#line 75 "./../my-iforce.h"
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    _attribute[f.i].prolongation = _attribute[p.i].prolongation;
    _attribute[f.i].dirty = true;
  }}}
#line 94 "./../my-iforce.h"
  vector ia = a;
if(!is_constant(fm.x) && !is_constant(alpha.x)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-iforce.h", .line = 95, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 95 "./../my-iforce.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val(fm.x,0,0,0); {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);   _stencil_val(phi,-1,0,0); 
#line 111
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 110
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 109
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 






_stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val_r(ia.x,0,0,0);    



      }     }}} 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val(fm.y,0,0,0); {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);   _stencil_val(phi,0,-1,0); 
#line 111
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 110
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 109
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 






_stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val_r(ia.y,0,0,0);    



      }     }}}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 95 "./../my-iforce.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 96 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && val(fm.x,0,0,0) > 0.) {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,-1,0,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,-1,0,0) < 1e30f ? val(phi,-1,0,0) :
   0.;


 val(ia.x,0,0,0) += val(alpha.x,0,0,0)/(val(ibmf.x,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;



      }}}}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 96 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && val(fm.y,0,0,0) > 0.) {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,-1,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,-1,0) < 1e30f ? val(phi,0,-1,0) :
   0.;


 val(ia.y,0,0,0) += val(alpha.y,0,0,0)/(val(ibmf.y,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;



      }}}}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 120 "./../my-iforce.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 120 "./../my-iforce.h"
}else if(is_constant(fm.x) && !is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-iforce.h", .line = 95, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 95 "./../my-iforce.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0);; {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);   _stencil_val(phi,-1,0,0); 
#line 111
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 110
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 109
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 






_stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val_r(ia.x,0,0,0);    



      }     }}} 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0);; {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);   _stencil_val(phi,0,-1,0); 
#line 111
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 110
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 109
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 






_stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val_r(ia.y,0,0,0);    



      }     }}}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 95 "./../my-iforce.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 96 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && _const_fm.x > 0.) {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,-1,0,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,-1,0,0) < 1e30f ? val(phi,-1,0,0) :
   0.;


 val(ia.x,0,0,0) += val(alpha.x,0,0,0)/(val(ibmf.x,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;



      }}}}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 96 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && _const_fm.y > 0.) {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,-1,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,-1,0) < 1e30f ? val(phi,0,-1,0) :
   0.;


 val(ia.y,0,0,0) += val(alpha.y,0,0,0)/(val(ibmf.y,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;



      }}}}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 120 "./../my-iforce.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 120 "./../my-iforce.h"
}else if(!is_constant(fm.x) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-iforce.h", .line = 95, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 95 "./../my-iforce.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val(fm.x,0,0,0); {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);   _stencil_val(phi,-1,0,0); 
#line 111
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 110
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 109
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0);






;_stencil_val(ibmf.x,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val_r(ia.x,0,0,0);    



      }     }}} 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val(fm.y,0,0,0); {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);   _stencil_val(phi,0,-1,0); 
#line 111
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 110
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 109
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0);






;_stencil_val(ibmf.y,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val_r(ia.y,0,0,0);    



      }     }}}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 95 "./../my-iforce.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 96 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && val(fm.x,0,0,0) > 0.) {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,-1,0,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,-1,0,0) < 1e30f ? val(phi,-1,0,0) :
   0.;


 val(ia.x,0,0,0) += _const_alpha.x/(val(ibmf.x,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;



      }}}}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 96 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && val(fm.y,0,0,0) > 0.) {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,-1,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,-1,0) < 1e30f ? val(phi,0,-1,0) :
   0.;


 val(ia.y,0,0,0) += _const_alpha.y/(val(ibmf.y,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;



      }}}}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 120 "./../my-iforce.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 120 "./../my-iforce.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-iforce.h", .line = 95, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 95 "./../my-iforce.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0);; {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);   _stencil_val(phi,-1,0,0); 
#line 111
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 110
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 109
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0);






;_stencil_val(ibmf.x,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val_r(ia.x,0,0,0);    



      }     }}} 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0);; {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);   _stencil_val(phi,0,-1,0); 
#line 111
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 110
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 109
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0);






;_stencil_val(ibmf.y,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val_r(ia.y,0,0,0);    



      }     }}}}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 95 "./../my-iforce.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 96 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && _const_fm.x > 0.) {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,-1,0,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,-1,0,0) < 1e30f ? val(phi,-1,0,0) :
   0.;


 val(ia.x,0,0,0) += _const_alpha.x/(val(ibmf.x,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;



      }}}}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 96 "./../my-iforce.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 96 "./../my-iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && _const_fm.y > 0.) {
#line 107 "./../my-iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,-1,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,-1,0) < 1e30f ? val(phi,0,-1,0) :
   0.;


 val(ia.y,0,0,0) += _const_alpha.y/(val(ibmf.y,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;



      }}}}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 120 "./../my-iforce.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 120 "./../my-iforce.h"
}
#line 130 "./../my-iforce.h"
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    _attribute[f.i].prolongation = fraction_refine;
    _attribute[f.i].dirty = true;
  }}}






  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    scalar phi = _attribute[f.i].phi;
    delete (((scalar[]){phi,{-1}}));
    _attribute[f.i].phi.i = 0;
  }}}
  pfree (list,__func__,__FILE__,__LINE__);
}{end_tracing("acceleration_1","./../my-iforce.h",146);return 0;}end_tracing("acceleration_1","./../my-iforce.h",146);}
#line 16 "./../my-tension.h"




#line 1 "./curvature.h"
#line 1 "/home/spencer/basilisk/src/curvature.h"
#line 12 "/home/spencer/basilisk/src/curvature.h"
static void curvature_restriction (Point point, scalar kappa)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 14 "/home/spencer/basilisk/src/curvature.h"
double k = 0., s = 0.;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 16 "/home/spencer/basilisk/src/curvature.h"
if (val(kappa,0,0,0) != 1e30f)
      k += val(kappa,0,0,0), s++;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 18 "/home/spencer/basilisk/src/curvature.h"
val(kappa,0,0,0) = s ? k/s : 1e30f;
}







static void curvature_prolongation (Point point, scalar kappa)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
  
#line 368
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 29 "/home/spencer/basilisk/src/curvature.h"
{
    double sk = 0., s = 0.;
    for (int i = 0; i <= 1; i++)

      for (int j = 0; j <= 1; j++)




   if (coarse(kappa,child.x*i,child.y*j,child.z*k) != 1e30f)
     sk += coarse(kappa,child.x*i,child.y*j,child.z*k), s++;
    val(kappa,0,0,0) = s ? sk/s : 1e30f;
  }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 42 "/home/spencer/basilisk/src/curvature.h"
}
#line 68 "/home/spencer/basilisk/src/curvature.h"
#line 1 "./heights.h"
#line 1 "/home/spencer/basilisk/src/heights.h"
#line 29 "/home/spencer/basilisk/src/heights.h"
static inline double height (double H) {
  return H > 20./2. ? H - 20. : H < -20./2. ? H + 20. : H;
}

static inline int orientation (double H) {
  return fabs(H) > 20./2.;
}
#line 49 "/home/spencer/basilisk/src/heights.h"
static void half_column (Point point, scalar c, vector h, vector cs, int j)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 57 "/home/spencer/basilisk/src/heights.h"
const int complete = -1;

   {







    double S = val(c,0,0,0), H = S, ci;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (val(h.x,0,0,0) == 300.)
 state.s = complete, state.h = 1e30f;




      else {
 int s = (val(h.x,0,0,0) + 20./2.)/100.;
 state.h = val(h.x,0,0,0) - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
#line 109 "/home/spencer/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? val(c,i*j,0,0) : val(cs.x,(i - 2)*j,0,0);
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
#line 138 "/home/spencer/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
#line 156 "/home/spencer/basilisk/src/heights.h"
      else if (S == ci && trunc(H) != H)
 break;
    }





    if (j == -1) {







      if (S != complete && ((val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) ||
       (S > 0. && S < 1.)))
 val(h.x,0,0,0) = 300.;
      else if (S == complete)
 val(h.x,0,0,0) = H;
      else





 val(h.x,0,0,0) = H + 100.*(1. + (S >= 1.));
    }
    else {
#line 195 "/home/spencer/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 val(h.x,0,0,0) = 1e30f;
      else
 val(h.x,0,0,0) = (state.h > 1e10 ? 1e30f : state.h);
    }
  } 
#line 59
{







    double S = val(c,0,0,0), H = S, ci;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (val(h.y,0,0,0) == 300.)
 state.s = complete, state.h = 1e30f;




      else {
 int s = (val(h.y,0,0,0) + 20./2.)/100.;
 state.h = val(h.y,0,0,0) - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
#line 109 "/home/spencer/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? val(c,0,i*j,0) : val(cs.y,0,(i - 2)*j,0);
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
#line 138 "/home/spencer/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
#line 156 "/home/spencer/basilisk/src/heights.h"
      else if (S == ci && trunc(H) != H)
 break;
    }





    if (j == -1) {







      if (S != complete && ((val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) ||
       (S > 0. && S < 1.)))
 val(h.y,0,0,0) = 300.;
      else if (S == complete)
 val(h.y,0,0,0) = H;
      else





 val(h.y,0,0,0) = H + 100.*(1. + (S >= 1.));
    }
    else {
#line 195 "/home/spencer/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 val(h.y,0,0,0) = 1e30f;
      else
 val(h.y,0,0,0) = (state.h > 1e10 ? 1e30f : state.h);
    }
  }
}
#line 49 "/home/spencer/basilisk/src/heights.h"
static void _stencil_half_column (Point point, scalar c, vector h, vector cs, int j)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   
#line 59 "/home/spencer/basilisk/src/heights.h"
{      







     _stencil_val(c,0,0,0);            







    
    
    if (j == 1) {




_stencil_val(h.x,0,0,0);{ 
      




{     
 _stencil_val(h.x,0,0,0); 
_stencil_val(h.x,0,0,0);      

}}    







}
#line 109 "/home/spencer/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) { 
_stencil_val(c,i*j,0,0); _stencil_val(cs.x,(i - 2)*j,0,0); 
           
  
 
       
         
  
 
        







     
   
  
   
        
        
           
        




             
#line 138 "/home/spencer/basilisk/src/heights.h"
              
              
#line 156 "/home/spencer/basilisk/src/heights.h"
      
         
    }





    if (j == -1) {







_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{
 
{_stencil_val_a(h.x,0,0,0);  }
{
 {_stencil_val_a(h.x,0,0,0);  }





 
{_stencil_val_a(h.x,0,0,0);        }}      }    
}
    else {
#line 203
{
 {_stencil_val_a(h.x,0,0,0);  }
 
{_stencil_val_a(h.x,0,0,0);        }}
      
#line 195 "/home/spencer/basilisk/src/heights.h"
                
   





         
      
    


}
  } 
#line 59
{      







     _stencil_val(c,0,0,0);            







    
    
    if (j == 1) {




_stencil_val(h.y,0,0,0);{ 
      




{     
 _stencil_val(h.y,0,0,0); 
_stencil_val(h.y,0,0,0);      

}}    







}
#line 109 "/home/spencer/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) { 
_stencil_val(c,0,i*j,0); _stencil_val(cs.y,0,(i - 2)*j,0); 
           
  
 
       
         
  
 
        







     
   
  
   
        
        
           
        




             
#line 138 "/home/spencer/basilisk/src/heights.h"
              
              
#line 156 "/home/spencer/basilisk/src/heights.h"
      
         
    }





    if (j == -1) {







_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{
 
{_stencil_val_a(h.y,0,0,0);  }
{
 {_stencil_val_a(h.y,0,0,0);  }





 
{_stencil_val_a(h.y,0,0,0);        }}      }    
}
    else {
#line 203
{
 {_stencil_val_a(h.y,0,0,0);  }
 
{_stencil_val_a(h.y,0,0,0);        }}
      
#line 195 "/home/spencer/basilisk/src/heights.h"
                
   





         
      
    


}
  }
}
#line 222 "/home/spencer/basilisk/src/heights.h"
static void column_propagation (vector h)
{
  



  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/heights.h", .line = 227, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 229 "/home/spencer/basilisk/src/heights.h"
for (int i = -2; i <= 2; i++)
      {
 {_stencil_val(h.x,i,0,0);
_stencil_val(h.x,i,0,0);_stencil_val(h.x,0,0,0);
   { _stencil_val(h.x,i,0,0);_stencil_val_a(h.x,0,0,0);   }       } 
#line 231
{_stencil_val(h.y,0,i,0);
_stencil_val(h.y,0,i,0);_stencil_val(h.y,0,0,0);
   { _stencil_val(h.y,0,i,0);_stencil_val_a(h.y,0,0,0);   }       }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 229 "/home/spencer/basilisk/src/heights.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 229 "/home/spencer/basilisk/src/heights.h"
for (int i = -2; i <= 2; i++)
      {
 if (fabs(height(val(h.x,i,0,0))) <= 3.5 &&
     fabs(height(val(h.x,i,0,0)) + i) < fabs(height(val(h.x,0,0,0))))
   val(h.x,0,0,0) = val(h.x,i,0,0) + i; 
#line 231
if (fabs(height(val(h.y,0,i,0))) <= 3.5 &&
     fabs(height(val(h.y,0,i,0)) + i) < fabs(height(val(h.y,0,0,0))))
   val(h.y,0,0,0) = val(h.y,0,i,0) + i;}}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 234 "/home/spencer/basilisk/src/heights.h"
}
#line 293 "/home/spencer/basilisk/src/heights.h"

static void refine_h_x (Point point, scalar h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 300 "/home/spencer/basilisk/src/heights.h"
bool complete = true;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 301 "/home/spencer/basilisk/src/heights.h"
{
    for (int i = -2; i <= 2; i++)
      if (allocated(i,0,0) &&
   !(!is_leaf(neighbor(i,0,0)) && !neighbor(i,0,0).neighbors && neighbor(i,0,0).pid >= 0) && !(neighbor(i,0,0).pid < 0) &&
   fabs(height(val(h,i,0,0))) <= 3.5 &&
   fabs(height(val(h,i,0,0)) + i) < fabs(height(val(h,0,0,0))))
 val(h,0,0,0) = val(h,i,0,0) + i;
    if (val(h,0,0,0) == 1e30f)
      complete = false;
  }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 311 "/home/spencer/basilisk/src/heights.h"
if (complete)
    return;
#line 321 "/home/spencer/basilisk/src/heights.h"
  int ori = orientation(val(h,0,0,0));

  for (int i = -1; i <= 1; i++)
    if (val(h,0,i,0) == 1e30f || orientation(val(h,0,i,0)) != ori)
      return;

  double h0 = (30.*height(val(h,0,0,0)) + height(val(h,0,1,0)) + height(val(h,0,-1,0)))/16.
    + 20.*ori;
  double dh = (height(val(h,0,1,0)) - height(val(h,0,-1,0)))/4.;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 331 "/home/spencer/basilisk/src/heights.h"
if (val(h,0,0,0) == 1e30f)
      val(h,0,0,0) = h0 + dh*child.y - child.x/2.;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 356 "/home/spencer/basilisk/src/heights.h"
}
#line 294
static void refine_h_y (Point point, scalar h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 300 "/home/spencer/basilisk/src/heights.h"
bool complete = true;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 301 "/home/spencer/basilisk/src/heights.h"
{
    for (int i = -2; i <= 2; i++)
      if (allocated(0,i,0) &&
   !(!is_leaf(neighbor(0,i,0)) && !neighbor(0,i,0).neighbors && neighbor(0,i,0).pid >= 0) && !(neighbor(0,i,0).pid < 0) &&
   fabs(height(val(h,0,i,0))) <= 3.5 &&
   fabs(height(val(h,0,i,0)) + i) < fabs(height(val(h,0,0,0))))
 val(h,0,0,0) = val(h,0,i,0) + i;
    if (val(h,0,0,0) == 1e30f)
      complete = false;
  }
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }  
#line 311 "/home/spencer/basilisk/src/heights.h"
if (complete)
    return;
#line 321 "/home/spencer/basilisk/src/heights.h"
  int ori = orientation(val(h,0,0,0));

  for (int i = -1; i <= 1; i++)
    if (val(h,i,0,0) == 1e30f || orientation(val(h,i,0,0)) != ori)
      return;

  double h0 = (30.*height(val(h,0,0,0)) + height(val(h,1,0,0)) + height(val(h,-1,0,0)))/16.
    + 20.*ori;
  double dh = (height(val(h,1,0,0)) - height(val(h,-1,0,0)))/4.;
  
  
#line 368 "/home/spencer/basilisk/src/grid/tree.h"
{
    int _i = 2*point.i - 2, _j = 2*point.j - 2;
    point.level++;
    for (int _k = 0; _k < 2; _k++) {
      point.i = _i + _k;
      for (int _l = 0; _l < 2; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 331 "/home/spencer/basilisk/src/heights.h"
if (val(h,0,0,0) == 1e30f)
      val(h,0,0,0) = h0 + dh*child.x - child.y/2.;
      
#line 377 "/home/spencer/basilisk/src/grid/tree.h"
}
    }
    point.i = (_i + 2)/2; point.j = (_j + 2)/2;
    point.level--;
  }
#line 356 "/home/spencer/basilisk/src/heights.h"
}






     
void heights (scalar c, vector h)
{tracing("heights","/home/spencer/basilisk/src/heights.h",364);
  vector  s=new_vector("s");
  
    for (int i = 0; i < nboundary; i++)
      _attribute[s.x.i].boundary[i] = _attribute[c.i].boundary[i];    
#line 368
for (int i = 0; i < nboundary; i++)
      _attribute[s.y.i].boundary[i] = _attribute[c.i].boundary[i];





  restriction (((scalar[]){c,{-1}}));
  for (int j = -1; j <= 1; j += 2) {    
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
      
#line 383 "/home/spencer/basilisk/src/heights.h"
{
        {_stencil_val_a(h.x,0,0,0);  }        {_stencil_val_a(h.y,0,0,0);  }}  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (0 <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[0];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = 0;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;      
#line 383 "/home/spencer/basilisk/src/heights.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 383 "/home/spencer/basilisk/src/heights.h"
{
        val(h.x,0,0,0) = 1e30f;        val(h.y,0,0,0) = 1e30f;}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}    
#line 386 "/home/spencer/basilisk/src/heights.h"
for (int l = 1; l <= depth(); l++) {      
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
 
#line 392 "/home/spencer/basilisk/src/heights.h"
{
   { _stencil_val(c,2*j,0,0);_stencil_val_a(s.x,0,0,0); }   { _stencil_val(c,0,2*j,0);_stencil_val_a(s.y,0,0,0); }}  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j; 
#line 392 "/home/spencer/basilisk/src/heights.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 392 "/home/spencer/basilisk/src/heights.h"
{
   val(s.x,0,0,0) = val(c,2*j,0,0);   val(s.y,0,0,0) = val(c,0,2*j,0);}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
  
#line 403 "/home/spencer/basilisk/src/heights.h"
      
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
 
#line 404 "/home/spencer/basilisk/src/heights.h"
{ { 
_stencil_val(c,j,0,0);   _stencil_val_a(s.x,0,0,0); 
_stencil_val(c,2*j,0,0);   _stencil_val_a(s.x,j,0,0); 
        } 
#line 404
{ 
_stencil_val(c,0,j,0);   _stencil_val_a(s.y,0,0,0); 
_stencil_val(c,0,2*j,0);   _stencil_val_a(s.y,0,j,0); 
        }}  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if ((
#line 403 "/home/spencer/basilisk/src/heights.h"
l - 1
#line 732 "/home/spencer/basilisk/src/grid/tree.h"
) <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[(
#line 403 "/home/spencer/basilisk/src/heights.h"
l - 1
#line 734 "/home/spencer/basilisk/src/grid/tree.h"
)];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = (
#line 735
(
#line 403 "/home/spencer/basilisk/src/heights.h"
l - 1
#line 735 "/home/spencer/basilisk/src/grid/tree.h"
)
#line 463
);
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j; 
#line 404 "/home/spencer/basilisk/src/heights.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 404 "/home/spencer/basilisk/src/heights.h"
{ {
   val(s.x,0,0,0) = val(c,j,0,0);
   val(s.x,j,0,0) = val(c,2*j,0,0);
        } 
#line 404
{
   val(s.y,0,0,0) = val(c,0,j,0);
   val(s.y,0,j,0) = val(c,0,2*j,0);
        }}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}
#line 494
{
  if ((
#line 414 "/home/spencer/basilisk/src/heights.h"
l - 1
#line 495 "/home/spencer/basilisk/src/grid/tree.h"
) <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _cache = ((Tree *)grid)->prolongation[(
#line 414 "/home/spencer/basilisk/src/heights.h"
l - 1
#line 497 "/home/spencer/basilisk/src/grid/tree.h"
)];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = (
#line 498
(
#line 414 "/home/spencer/basilisk/src/heights.h"
l - 1
#line 498 "/home/spencer/basilisk/src/grid/tree.h"
)
#line 463
);
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _cache.n; _k++) {
 point.i = _cache.p[_k].i;

 point.j = _cache.p[_k].j; 
#line 415 "/home/spencer/basilisk/src/heights.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 415 "/home/spencer/basilisk/src/heights.h"
{
   _attribute[c.i].prolongation (point, s.x);   _attribute[c.i].prolongation (point, s.y);}}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 500
}
}      
#line 417 "/home/spencer/basilisk/src/heights.h"
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, (scalar *)((vector[]){s,{{-1},{-1}}}), l); };      
#line 347 "/home/spencer/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
        
#line 424 "/home/spencer/basilisk/src/heights.h"
_stencil_half_column (point, c, h, s, j);  
#line 352 "/home/spencer/basilisk/src/grid/stencils.h"
} 
#line 731 "/home/spencer/basilisk/src/grid/tree.h"
{
  if (l <= depth()) {
    { if (((Tree *)grid)->dirty) update_cache_f(); };
    CacheLevel _active = ((Tree *)grid)->active[l];
#line 452
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    point.level = l;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 0; _k < _active.n; _k++) {
 point.i = _active.p[_k].i;

 point.j = _active.p[_k].j;        
#line 424 "/home/spencer/basilisk/src/heights.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 424 "/home/spencer/basilisk/src/heights.h"
half_column (point, c, h, s, j);}
      
#line 475 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}
  
#line 737
}
}    
#line 425 "/home/spencer/basilisk/src/heights.h"
}
  }






   {
    _attribute[h.x.i].prolongation = no_data;
    _attribute[h.x.i].restriction = no_restriction;
    _attribute[h.x.i].dirty = true;
  } 
#line 433
{
    _attribute[h.y.i].prolongation = no_data;
    _attribute[h.y.i].restriction = no_restriction;
    _attribute[h.y.i].dirty = true;
  }




  column_propagation (h);






  
    _attribute[h.x.i].prolongation = refine_h_x;    _attribute[h.y.i].prolongation = refine_h_y;delete((scalar*)((vector[]){s,{{-1},{-1}}}));
end_tracing("heights","/home/spencer/basilisk/src/heights.h",451);}








#line 69 "/home/spencer/basilisk/src/curvature.h"



static double kappa_y (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 74 "/home/spencer/basilisk/src/curvature.h"
int ori = orientation(val(h.y,0,0,0));
  for (int i = -1; i <= 1; i++)
    if (val(h.y,i,0,0) == 1e30f || orientation(val(h.y,i,0,0)) != ori)
      return 1e30f;
  double hx = (val(h.y,1,0,0) - val(h.y,-1,0,0))/2.;
  double hxx = (val(h.y,1,0,0) + val(h.y,-1,0,0) - 2.*val(h.y,0,0,0))/Delta;
  return hxx/pow(1. + ( hx*hx), 3/2.);
}
#line 72
static double kappa_x (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 74 "/home/spencer/basilisk/src/curvature.h"
int ori = orientation(val(h.x,0,0,0));
  for (int i = -1; i <= 1; i++)
    if (val(h.x,0,i,0) == 1e30f || orientation(val(h.x,0,i,0)) != ori)
      return 1e30f;
  double hx = (val(h.x,0,1,0) - val(h.x,0,-1,0))/2.;
  double hxx = (val(h.x,0,1,0) + val(h.x,0,-1,0) - 2.*val(h.x,0,0,0))/Delta;
  return hxx/pow(1. + ( hx*hx), 3/2.);
}


static coord normal_y (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 86 "/home/spencer/basilisk/src/curvature.h"
coord n = {1e30f, 1e30f, 1e30f};
  if (val(h.y,0,0,0) == 1e30f)
    return n;
  int ori = orientation(val(h.y,0,0,0));
  if (val(h.y,-1,0,0) != 1e30f && orientation(val(h.y,-1,0,0)) == ori) {
    if (val(h.y,1,0,0) != 1e30f && orientation(val(h.y,1,0,0)) == ori)
      n.x = (val(h.y,-1,0,0) - val(h.y,1,0,0))/2.;
    else
      n.x = val(h.y,-1,0,0) - val(h.y,0,0,0);
  }
  else if (val(h.y,1,0,0) != 1e30f && orientation(val(h.y,1,0,0)) == ori)
    n.x = val(h.y,0,0,0) - val(h.y,1,0,0);
  else
    return n;
  double nn = (ori ? -1. : 1.)*sqrt(1. + ( (n.x)*(n.x)));
  n.x /= nn;
  n.y = 1./nn;
  return n;
}
#line 84
static coord normal_x (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 86 "/home/spencer/basilisk/src/curvature.h"
coord n = {1e30f, 1e30f, 1e30f};
  if (val(h.x,0,0,0) == 1e30f)
    return n;
  int ori = orientation(val(h.x,0,0,0));
  if (val(h.x,0,-1,0) != 1e30f && orientation(val(h.x,0,-1,0)) == ori) {
    if (val(h.x,0,1,0) != 1e30f && orientation(val(h.x,0,1,0)) == ori)
      n.y = (val(h.x,0,-1,0) - val(h.x,0,1,0))/2.;
    else
      n.y = val(h.x,0,-1,0) - val(h.x,0,0,0);
  }
  else if (val(h.x,0,1,0) != 1e30f && orientation(val(h.x,0,1,0)) == ori)
    n.y = val(h.x,0,0,0) - val(h.x,0,1,0);
  else
    return n;
  double nn = (ori ? -1. : 1.)*sqrt(1. + ( (n.y)*(n.y)));
  n.y /= nn;
  n.x = 1./nn;
  return n;
}
#line 181 "/home/spencer/basilisk/src/curvature.h"
static double height_curvature (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 189 "/home/spencer/basilisk/src/curvature.h"
typedef struct {
    double n;
    double (* kappa) (Point, vector);
  } NormKappa;
  struct { NormKappa x, y, z; } n;
  
    n.x.n = val(c,1,0,0) - val(c,-1,0,0), n.x.kappa = kappa_x;    n.y.n = val(c,0,1,0) - val(c,0,-1,0), n.y.kappa = kappa_y;
  double (* kappaf) (Point, vector) = NULL; NOT_UNUSED (kappaf);




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormKappa _tmp_ = n.x; n.x = n.y; n.y = _tmp_; } while(false);
#line 213 "/home/spencer/basilisk/src/curvature.h"
  double kappa = 1e30f;
  
    if (kappa == 1e30f) {
      kappa = n.x.kappa (point, h);
      if (kappa != 1e30f) {
 kappaf = n.x.kappa;
 if (n.x.n < 0.)
   kappa = - kappa;
      }
    }    
#line 215
if (kappa == 1e30f) {
      kappa = n.y.kappa (point, h);
      if (kappa != 1e30f) {
 kappaf = n.y.kappa;
 if (n.y.n < 0.)
   kappa = - kappa;
      }
    }

  if (kappa != 1e30f) {




    if (fabs(kappa) > 1./Delta)
      kappa = ( (int)(kappa > 0 ? 1 : -1))/Delta;





    double nr, r = y, hx;
    if (kappaf == kappa_x) {
      hx = (height(val(h.x,0,1,0)) - height(val(h.x,0,-1,0)))/2.;
      nr = hx*(orientation(val(h.x,0,0,0)) ? 1 : -1);
    }
    else {
      r += height(val(h.y,0,0,0))*Delta;
      hx = (height(val(h.y,1,0,0)) - height(val(h.y,-1,0,0)))/2.;
      nr = orientation(val(h.y,0,0,0)) ? -1 : 1;
    }

    kappa += nr/( (sqrt(1. + ( hx*hx))*r) > (Delta/2.) ? (sqrt(1. + ( hx*hx))*r) : (Delta/2.));

  }

  return kappa;
}
#line 181 "/home/spencer/basilisk/src/curvature.h"
static void _stencil_height_curvature (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;    
#line 195 "/home/spencer/basilisk/src/curvature.h"
{ _stencil_val(c,1,0,0); _stencil_val(c,-1,0,0);     }    { _stencil_val(c,0,1,0); _stencil_val(c,0,-1,0);     }                      
  
      




     
#line 213 "/home/spencer/basilisk/src/curvature.h"
   
#line 224
{     
               




       





    
{ {
_stencil_val(h.x,0,1,0);_stencil_val(h.x,0,-1,0); 
         _stencil_val(h.x,0,0,0);    
} 
{
_stencil_val(h.y,0,0,0);
        _stencil_val(h.y,1,0,0);_stencil_val(h.y,-1,0,0);
          _stencil_val(h.y,0,0,0);    
}}  



}  

return ;
}






coord height_normal (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;  
#line 267 "/home/spencer/basilisk/src/curvature.h"
typedef struct {
    double n;
    coord (* normal) (Point, vector);
  } NormNormal;
  struct { NormNormal x, y, z; } n;
  
    n.x.n = val(c,1,0,0) - val(c,-1,0,0), n.x.normal = normal_x;    n.y.n = val(c,0,1,0) - val(c,0,-1,0), n.y.normal = normal_y;




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormNormal _tmp_ = n.x; n.x = n.y; n.y = _tmp_; } while(false);
#line 290 "/home/spencer/basilisk/src/curvature.h"
  coord normal = {1e30f, 1e30f, 1e30f};
  
    if (normal.x == 1e30f)
      normal = n.x.normal (point, h);    
#line 292
if (normal.y == 1e30f)
      normal = n.y.normal (point, h);

  return normal;
}
#line 332 "/home/spencer/basilisk/src/curvature.h"
#line 1 "./parabola.h"
#line 1 "/home/spencer/basilisk/src/parabola.h"







typedef struct {
  coord o;

  coord m;
  double ** M, rhs[3], a[3];
#line 21 "/home/spencer/basilisk/src/parabola.h"
} ParabolaFit;

static void parabola_fit_init (ParabolaFit * p, coord o, coord m)
{
  
    p->o.x = o.x;    p->o.y = o.y;

  
    p->m.x = m.x;    p->m.y = m.y;
  normalize (&p->m);
  int n = 3;
#line 65 "/home/spencer/basilisk/src/parabola.h"
  p->M = (double **) matrix_new (n, n, sizeof(double));
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++)
      p->M[i][j] = 0.;
    p->rhs[i] = 0.;
  }
}

static void parabola_fit_add (ParabolaFit * p, coord m, double w)
{

  double x1 = m.x - p->o.x, y1 = m.y - p->o.y;
  double x = p->m.y*x1 - p->m.x*y1;
  double y = p->m.x*x1 + p->m.y*y1;
  double x2 = w*x*x, x3 = x2*x, x4 = x3*x;
  p->M[0][0] += x4;
  p->M[1][0] += x3; p->M[1][1] += x2;
  p->M[2][1] += w*x; p->M[2][2] += w;
  p->rhs[0] += x2*y; p->rhs[1] += w*x*y; p->rhs[2] += w*y;
#line 111 "/home/spencer/basilisk/src/parabola.h"
}

static double parabola_fit_solve (ParabolaFit * p)
{

  p->M[0][1] = p->M[1][0];
  p->M[0][2] = p->M[2][0] = p->M[1][1];
  p->M[1][2] = p->M[2][1];
  double pivmin = matrix_inverse (p->M, 3, 1e-10);
  if (pivmin) {
    p->a[0] = p->M[0][0]*p->rhs[0] + p->M[0][1]*p->rhs[1] + p->M[0][2]*p->rhs[2];
    p->a[1] = p->M[1][0]*p->rhs[0] + p->M[1][1]*p->rhs[1] + p->M[1][2]*p->rhs[2];
  }
  else
    p->a[0] = p->a[1] = 0.;
#line 158 "/home/spencer/basilisk/src/parabola.h"
  matrix_free (p->M);
  return pivmin;
}

static double parabola_fit_curvature (ParabolaFit * p,
          double kappamax, double * kmax)
{
  double kappa;

  double dnm = 1. + ( (p->a[1])*(p->a[1]));
  kappa = - 2.*p->a[0]/pow(dnm, 3/2.);
  if (kmax)
    *kmax = fabs (kappa);
#line 190 "/home/spencer/basilisk/src/parabola.h"
  if (fabs (kappa) > kappamax) {
    if (kmax)
      *kmax = kappamax;
    return kappa > 0. ? kappamax : - kappamax;
  }
  return kappa;
}


static void parabola_fit_axi_curvature (const ParabolaFit * p,
     double r, double h,
     double * kappa, double * kmax)
{
  double nr = (p->m.x*p->a[1] + p->m.y)/sqrt (1. + ( (p->a[1])*(p->a[1])));

  double kaxi = nr/( r > (h/2.) ? r : (h/2.));
  *kappa += kaxi;
  if (kmax)
    *kmax = ( (*kmax) > (fabs (kaxi)) ? (*kmax) : (fabs (kaxi)));
}
#line 333 "/home/spencer/basilisk/src/curvature.h"






static int independents (coord * p, int n)
{
  if (n < 2)
    return n;
  int ni = 1;
  for (int j = 1; j < n; j++) {
    bool depends = false;
    for (int i = 0; i < j && !depends; i++) {
      double d2 = 0.;
      
 d2 += ( (p[i].x - p[j].x)*(p[i].x - p[j].x)); d2 += ( (p[i].y - p[j].y)*(p[i].y - p[j].y));
      depends = (d2 < ( 0.5*0.5));
    }
    ni += !depends;
  }
  return ni;
}






static double height_curvature_fit (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;





  
#line 369 "/home/spencer/basilisk/src/curvature.h"
coord ip[2 == 2 ? 6 : 27];
  int n = 0;




   {





    int n1 = 0, n2 = 0;

    for (int i = -1; i <= 1; i++)
      if (val(h.y,i,0,0) != 1e30f) {
 if (orientation(val(h.y,i,0,0))) n1++; else n2++;
      }







    int ori = (n1 > n2);







    for (int i = -1; i <= 1; i++)
      if (val(h.y,i,0,0) != 1e30f && orientation(val(h.y,i,0,0)) == ori)
 ip[n].x = i, ip[n++].y = height(val(h.y,i,0,0));






  } 
#line 375
{





    int n1 = 0, n2 = 0;

    for (int i = -1; i <= 1; i++)
      if (val(h.x,0,i,0) != 1e30f) {
 if (orientation(val(h.x,0,i,0))) n1++; else n2++;
      }







    int ori = (n1 > n2);







    for (int i = -1; i <= 1; i++)
      if (val(h.x,0,i,0) != 1e30f && orientation(val(h.x,0,i,0)) == ori)
 ip[n].y = i, ip[n++].x = height(val(h.x,0,i,0));






  }





  if (independents (ip, n) < (2 == 2 ? 3 : 9))
    return 1e30f;





  coord m = mycs (point, c), fc;
  double alpha = line_alpha (val(c,0,0,0), m);
  double area = line_length_center(m,alpha,&fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);

  NOT_UNUSED(area);
  parabola_fit_add (&fit, fc, .1);
#line 440 "/home/spencer/basilisk/src/curvature.h"
  for (int i = 0; i < n; i++)
    parabola_fit_add (&fit, ip[i], 1.);
  parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., NULL)/Delta;

  parabola_fit_axi_curvature (&fit, y + fc.y*Delta, Delta, &kappa, NULL);

  return kappa;
}
#line 362
static void _stencil_height_curvature_fit (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;          





  
  




   
#line 375 "/home/spencer/basilisk/src/curvature.h"
{      





    

    for (int i = -1; i <= 1; i++)
      {_stencil_val(h.y,i,0,0); {
_stencil_val(h.y,i,0,0);      
}   }     







    







    for (int i = -1; i <= 1; i++)
      {_stencil_val(h.y,i,0,0);_stencil_val(h.y,i,0,0);
 {_stencil_val(h.y,i,0,0);     }       }






  } 
#line 375
{      





    

    for (int i = -1; i <= 1; i++)
      {_stencil_val(h.x,0,i,0); {
_stencil_val(h.x,0,i,0);      
}   }     







    







    for (int i = -1; i <= 1; i++)
      {_stencil_val(h.x,0,i,0);_stencil_val(h.x,0,i,0);
 {_stencil_val(h.x,0,i,0);     }       }






  }    
    





             





   _stencil_mycs (point, c);     
  _stencil_val(c,0,0,0);          
  
                 
  

  
  
#line 440 "/home/spencer/basilisk/src/curvature.h"
     
    
  
         

  

  return ;
}






static double centroids_curvature_fit (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;





  
#line 462 "/home/spencer/basilisk/src/curvature.h"
coord m = mycs (point, c), fc;
  double alpha = line_alpha (val(c,0,0,0), m);
  line_length_center(m,alpha,&fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);





  coord r = {x,y,z};  
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 474 "/home/spencer/basilisk/src/curvature.h"
if (val(c,0,0,0) > 0. && val(c,0,0,0) < 1.) {
      coord m = mycs (point, c), fc;
      double alpha = line_alpha (val(c,0,0,0), m);
      double area = line_length_center(m,alpha,&fc);
      coord rn = {x,y,z};
      
 fc.x += (rn.x - r.x)/Delta; fc.y += (rn.y - r.y)/Delta;
      parabola_fit_add (&fit, fc, area);
    }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
  
#line 483 "/home/spencer/basilisk/src/curvature.h"
parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., NULL)/Delta;

  parabola_fit_axi_curvature (&fit, y + fc.y*Delta, Delta, &kappa, NULL);

  return kappa;
}
#line 455
static void _stencil_centroids_curvature_fit (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;   





   
#line 462 "/home/spencer/basilisk/src/curvature.h"
_stencil_mycs (point, c);     
  _stencil_val(c,0,0,0);  
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
    
#line 474 "/home/spencer/basilisk/src/curvature.h"
{_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
       _stencil_mycs (point, c);     
      _stencil_val(c,0,0,0);      
      
      
       
       
      
    }      }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }       
  
         

  

  
#line 488 "/home/spencer/basilisk/src/curvature.h"
return ;
}
#line 504 "/home/spencer/basilisk/src/curvature.h"
static inline bool interfacial (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 506 "/home/spencer/basilisk/src/curvature.h"
if (val(c,0,0,0) >= 1.) {
    for (int i = -1; i <= 1; i += 2)
      {
 if (val(c,i,0,0) <= 0.)
   return true; 
#line 509
if (val(c,0,i,0) <= 0.)
   return true;}
  }
  else if (val(c,0,0,0) <= 0.) {
    for (int i = -1; i <= 1; i += 2)
      {
 if (val(c,i,0,0) >= 1.)
   return true; 
#line 515
if (val(c,0,i,0) >= 1.)
   return true;}
  }
  else
    return true;
  return false;
}
#line 504 "/home/spencer/basilisk/src/curvature.h"
static void _stencil_interfacial (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 506 "/home/spencer/basilisk/src/curvature.h"
_stencil_val(c,0,0,0);{ {
    for (int i = -1; i <= 1; i += 2)
      {
 {_stencil_val(c,i,0,0); 
      } 
#line 509
{_stencil_val(c,0,i,0); 
      }}
  } 
{_stencil_val(c,0,0,0);{ {
    for (int i = -1; i <= 1; i += 2)
      {
 {_stencil_val(c,i,0,0); 
      } 
#line 515
{_stencil_val(c,0,i,0); 
      }}
  } 
    
}  }}  
return ;
}
#line 533 "/home/spencer/basilisk/src/curvature.h"
typedef struct {
  int h;
  int f;
  int a;
  int c;
} cstats;

     
cstats curvature (scalar c, scalar kappa,
    double sigma, bool add)
{tracing("curvature","/home/spencer/basilisk/src/curvature.h",541);
  int sh = 0, f = 0, sa = 0, sc = 0;






  _attribute[kappa.i].refine = _attribute[kappa.i].prolongation = curvature_prolongation;
  _attribute[kappa.i].restriction = curvature_restriction;




  vector ch = _attribute[c.i].height,   h=(ch).x.i>0?(ch):new_vector("h");
  if (!ch.x.i)
    heights (c, h);





  scalar  k=new_scalar("k");
  scalar_clone (k, kappa);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/curvature.h", .line = 568, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 568 "/home/spencer/basilisk/src/curvature.h"
{




_stencil_interfacial (point, c);{
      {_stencil_val_a(k,0,0,0);  } 





{ _stencil_height_curvature (point, c, h);_stencil_val_a(k,0,0,0);{
       
{ _stencil_height_curvature_fit (point, c, h);_stencil_val_a(k,0,0,0);
          }}    }}  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:sh) reduction(+:f)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 568 "/home/spencer/basilisk/src/curvature.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 568 "/home/spencer/basilisk/src/curvature.h"
{




    if (!interfacial (point, c))
      val(k,0,0,0) = 1e30f;





    else if ((val(k,0,0,0) = height_curvature (point, c, h)) != 1e30f)
      sh++;
    else if ((val(k,0,0,0) = height_curvature_fit (point, c, h)) != 1e30f)
      f++;
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 584 "/home/spencer/basilisk/src/curvature.h"
{mpi_all_reduce_array(&f,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&sh,MPI_INT,MPI_SUM,1);}  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/curvature.h", .line = 586, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 586 "/home/spencer/basilisk/src/curvature.h"
{ 





    
_stencil_val(k,0,0,0);{
      { _stencil_val(k,0,0,0); } 
{_stencil_interfacial (point, c);{ {      
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 603 "/home/spencer/basilisk/src/curvature.h"
{_stencil_val(k,0,0,0);
   { _stencil_val(k,0,0,0);  }   }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }




 
#line 612 "/home/spencer/basilisk/src/curvature.h"
{ _stencil_centroids_curvature_fit (point, c);  }    
}
        
}    }}




{
      {_stencil_val_a(kappa,0,0,0);  } 
if (add)
      {_stencil_val_r(kappa,0,0,0);  }
    else
      {_stencil_val_a(kappa,0,0,0);  }}  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:sa) reduction(+:sc)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 586 "/home/spencer/basilisk/src/curvature.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 586 "/home/spencer/basilisk/src/curvature.h"
{





    double kf;
    if (val(k,0,0,0) < 1e30f)
      kf = val(k,0,0,0);
    else if (interfacial (point, c)) {





      double sk = 0., a = 0.;      
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
 
#line 603 "/home/spencer/basilisk/src/curvature.h"
if (val(k,0,0,0) < 1e30f)
   sk += val(k,0,0,0), a++;      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
      
#line 605 "/home/spencer/basilisk/src/curvature.h"
if (a > 0.)
 kf = sk/a, sa++;
      else




 kf = centroids_curvature_fit (point, c), sc++;
    }
    else
      kf = 1e30f;




    if (kf == 1e30f)
      val(kappa,0,0,0) = 1e30f;
    else if (add)
      val(kappa,0,0,0) += sigma*kf;
    else
      val(kappa,0,0,0) = sigma*kf;
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 626 "/home/spencer/basilisk/src/curvature.h"
{mpi_all_reduce_array(&sc,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&sa,MPI_INT,MPI_SUM,1);}
#line 643 "/home/spencer/basilisk/src/curvature.h"
  { cstats _ret= (cstats){sh, f, sa, sc};delete((scalar*)((scalar[]){k,{-1}}));if((ch).x.i<=0)delete((scalar*)((vector[]){h,{{-1},{-1}}}));{end_tracing("curvature","/home/spencer/basilisk/src/curvature.h",643);return _ret;}}delete((scalar*)((scalar[]){k,{-1}}));
end_tracing("curvature","/home/spencer/basilisk/src/curvature.h",644);}
#line 665 "/home/spencer/basilisk/src/curvature.h"

static double pos_x (Point point, vector h, coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 668 "/home/spencer/basilisk/src/curvature.h"
if (fabs(height(val(h.x,0,0,0))) > 1.)
    return 1e30f;
  coord o = {x, y, z};
  o.x += height(val(h.x,0,0,0))*Delta;
  double pos = 0.;
  
    pos += (o.x - Z->x)*G->x;    pos += (o.y - Z->y)*G->y;
  return pos;
}
#line 666
static double pos_y (Point point, vector h, coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
  
#line 668 "/home/spencer/basilisk/src/curvature.h"
if (fabs(height(val(h.y,0,0,0))) > 1.)
    return 1e30f;
  coord o = {x, y, z};
  o.y += height(val(h.y,0,0,0))*Delta;
  double pos = 0.;
  
    pos += (o.y - Z->y)*G->y;    pos += (o.x - Z->x)*G->x;
  return pos;
}







static double height_position (Point point, scalar f, vector h,
          coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;






  
#line 693 "/home/spencer/basilisk/src/curvature.h"
typedef struct {
    double n;
    double (* pos) (Point, vector, coord *, coord *);
  } NormPos;
  struct { NormPos x, y, z; } n;
  
    n.x.n = val(f,1,0,0) - val(f,-1,0,0), n.x.pos = pos_x;    n.y.n = val(f,0,1,0) - val(f,0,-1,0), n.y.pos = pos_y;




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormPos _tmp_ = n.x; n.x = n.y; n.y = _tmp_; } while(false);
#line 716 "/home/spencer/basilisk/src/curvature.h"
  double pos = 1e30f;
  
    if (pos == 1e30f)
      pos = n.x.pos (point, h, G, Z);    
#line 718
if (pos == 1e30f)
      pos = n.y.pos (point, h, G, Z);

  return pos;
}
#line 684
static void _stencil_height_position (Point point, scalar f,_stencil_undefined * h,
_stencil_undefined * G,_stencil_undefined * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;        
          
     
      






  
  
  
    
#line 699 "/home/spencer/basilisk/src/curvature.h"
{ _stencil_val(f,1,0,0); _stencil_val(f,-1,0,0);     }    { _stencil_val(f,0,1,0); _stencil_val(f,0,-1,0);     }                
    




     
#line 716 "/home/spencer/basilisk/src/curvature.h"
  
     
          
      

  return ;
}
#line 735 "/home/spencer/basilisk/src/curvature.h"
void position (scalar f, scalar pos,
        coord G, coord Z, bool add)
{






  _attribute[pos.i].refine = _attribute[pos.i].prolongation = curvature_prolongation;
  _attribute[pos.i].restriction = curvature_restriction;



  vector fh = _attribute[f.i].height,   h=(fh).x.i>0?(fh):new_vector("h");
  if (!fh.x.i)
    heights (f, h);  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/curvature.h", .line = 752, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 752 "/home/spencer/basilisk/src/curvature.h"
{
_stencil_interfacial (point, f);{ {  
       _stencil_height_position (point, f, NULL,NULL ,NULL ); 
{      





  _stencil_mycs (point, f);     
 _stencil_val(f,0,0,0); 
 
  
 
         
      }      
if (add)
 {_stencil_val_r(pos,0,0,0);  }
      else
 {_stencil_val_a(pos,0,0,0);  }
    }
      
{_stencil_val_a(pos,0,0,0);  }}  
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 752 "/home/spencer/basilisk/src/curvature.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 752 "/home/spencer/basilisk/src/curvature.h"
{
    if (interfacial (point, f)) {
      double hp = height_position (point, f, h, &G, &Z);
      if (hp == 1e30f) {





 coord n = mycs (point, f), o = {x,y,z}, c;
 double alpha = line_alpha (val(f,0,0,0), n);
 line_length_center(n,alpha,&c);
 hp = 0.;
 
   hp += (o.x + Delta*c.x - Z.x)*G.x;   hp += (o.y + Delta*c.y - Z.y)*G.y;
      }
      if (add)
 val(pos,0,0,0) += hp;
      else
 val(pos,0,0,0) = hp;
    }
    else
      val(pos,0,0,0) = 1e30f;
  }}      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 775 "/home/spencer/basilisk/src/curvature.h"
if((fh).x.i<=0)delete((scalar*)((vector[]){h,{{-1},{-1}}}));
#line 790 "/home/spencer/basilisk/src/curvature.h"
}
#line 41 "./../my-tension.h"
static int stability_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 21 "./../my-tension.h"






#line 41 "./../my-tension.h"
      static int stability_1(const int i,const double t,Event *_ev){tracing("stability_1","./../my-tension.h",41);
{





  double amin = 1e30f, amax = -1e30f, dmin = 1e30f;
if(!is_constant(fm.x) && !is_constant(alpha.x)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-tension.h", .line = 49, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 49 "./../my-tension.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 50 "./../my-tension.h"
{_stencil_val(fm.x,0,0,0); {

_stencil_val(ibmf.x,0,0,0); {
_stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0); { _stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0); }
_stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0); { _stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0); }      
}    





}   } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 50 "./../my-tension.h"
{_stencil_val(fm.y,0,0,0); {

_stencil_val(ibmf.y,0,0,0); {
_stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0); { _stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0); }
_stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0); { _stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0); }      
}    





}   }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(min:amin) reduction(max:amax) reduction(min:dmin)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 49 "./../my-tension.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 50 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 50 "./../my-tension.h"
if (val(fm.x,0,0,0) > 0.) {

      if (val(ibmf.x,0,0,0) > 0.) {
      if (val(alpha.x,0,0,0)/val(ibmf.x,0,0,0) > amax) amax = val(alpha.x,0,0,0)/val(ibmf.x,0,0,0);
      if (val(alpha.x,0,0,0)/val(ibmf.x,0,0,0) < amin) amin = val(alpha.x,0,0,0)/val(ibmf.x,0,0,0);
      }




      if (Delta < dmin) dmin = Delta;
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 50 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 50 "./../my-tension.h"
if (val(fm.y,0,0,0) > 0.) {

      if (val(ibmf.y,0,0,0) > 0.) {
      if (val(alpha.y,0,0,0)/val(ibmf.y,0,0,0) > amax) amax = val(alpha.y,0,0,0)/val(ibmf.y,0,0,0);
      if (val(alpha.y,0,0,0)/val(ibmf.y,0,0,0) < amin) amin = val(alpha.y,0,0,0)/val(ibmf.y,0,0,0);
      }




      if (Delta < dmin) dmin = Delta;
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 61 "./../my-tension.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 61 "./../my-tension.h"
{mpi_all_reduce_array(&dmin,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&amax,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&amin,MPI_DOUBLE,MPI_MIN,1);}}else if(is_constant(fm.x) && !is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-tension.h", .line = 49, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 49 "./../my-tension.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 50 "./../my-tension.h"
{; {

_stencil_val(ibmf.x,0,0,0); {
_stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0); { _stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0); }
_stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0); { _stencil_val(alpha.x,0,0,0);_stencil_val(ibmf.x,0,0,0); }      
}    





}   } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 50 "./../my-tension.h"
{; {

_stencil_val(ibmf.y,0,0,0); {
_stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0); { _stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0); }
_stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0); { _stencil_val(alpha.y,0,0,0);_stencil_val(ibmf.y,0,0,0); }      
}    





}   }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(min:amin) reduction(max:amax) reduction(min:dmin)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 49 "./../my-tension.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 50 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 50 "./../my-tension.h"
if (_const_fm.x > 0.) {

      if (val(ibmf.x,0,0,0) > 0.) {
      if (val(alpha.x,0,0,0)/val(ibmf.x,0,0,0) > amax) amax = val(alpha.x,0,0,0)/val(ibmf.x,0,0,0);
      if (val(alpha.x,0,0,0)/val(ibmf.x,0,0,0) < amin) amin = val(alpha.x,0,0,0)/val(ibmf.x,0,0,0);
      }




      if (Delta < dmin) dmin = Delta;
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 50 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 50 "./../my-tension.h"
if (_const_fm.y > 0.) {

      if (val(ibmf.y,0,0,0) > 0.) {
      if (val(alpha.y,0,0,0)/val(ibmf.y,0,0,0) > amax) amax = val(alpha.y,0,0,0)/val(ibmf.y,0,0,0);
      if (val(alpha.y,0,0,0)/val(ibmf.y,0,0,0) < amin) amin = val(alpha.y,0,0,0)/val(ibmf.y,0,0,0);
      }




      if (Delta < dmin) dmin = Delta;
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 61 "./../my-tension.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 61 "./../my-tension.h"
{mpi_all_reduce_array(&dmin,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&amax,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&amin,MPI_DOUBLE,MPI_MIN,1);}}else if(!is_constant(fm.x) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-tension.h", .line = 49, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 49 "./../my-tension.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 50 "./../my-tension.h"
{_stencil_val(fm.x,0,0,0); {

_stencil_val(ibmf.x,0,0,0); {
;_stencil_val(ibmf.x,0,0,0); {;_stencil_val(ibmf.x,0,0,0); }
;_stencil_val(ibmf.x,0,0,0); {;_stencil_val(ibmf.x,0,0,0); }      
}    





}   } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 50 "./../my-tension.h"
{_stencil_val(fm.y,0,0,0); {

_stencil_val(ibmf.y,0,0,0); {
;_stencil_val(ibmf.y,0,0,0); {;_stencil_val(ibmf.y,0,0,0); }
;_stencil_val(ibmf.y,0,0,0); {;_stencil_val(ibmf.y,0,0,0); }      
}    





}   }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(min:amin) reduction(max:amax) reduction(min:dmin)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 49 "./../my-tension.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 50 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 50 "./../my-tension.h"
if (val(fm.x,0,0,0) > 0.) {

      if (val(ibmf.x,0,0,0) > 0.) {
      if (_const_alpha.x/val(ibmf.x,0,0,0) > amax) amax = _const_alpha.x/val(ibmf.x,0,0,0);
      if (_const_alpha.x/val(ibmf.x,0,0,0) < amin) amin = _const_alpha.x/val(ibmf.x,0,0,0);
      }




      if (Delta < dmin) dmin = Delta;
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 50 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 50 "./../my-tension.h"
if (val(fm.y,0,0,0) > 0.) {

      if (val(ibmf.y,0,0,0) > 0.) {
      if (_const_alpha.y/val(ibmf.y,0,0,0) > amax) amax = _const_alpha.y/val(ibmf.y,0,0,0);
      if (_const_alpha.y/val(ibmf.y,0,0,0) < amin) amin = _const_alpha.y/val(ibmf.y,0,0,0);
      }




      if (Delta < dmin) dmin = Delta;
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 61 "./../my-tension.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 61 "./../my-tension.h"
{mpi_all_reduce_array(&dmin,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&amax,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&amin,MPI_DOUBLE,MPI_MIN,1);}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-tension.h", .line = 49, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 49 "./../my-tension.h"
{ 
#line 377 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 50 "./../my-tension.h"
{; {

_stencil_val(ibmf.x,0,0,0); {
;_stencil_val(ibmf.x,0,0,0); {;_stencil_val(ibmf.x,0,0,0); }
;_stencil_val(ibmf.x,0,0,0); {;_stencil_val(ibmf.x,0,0,0); }      
}    





}   } 
#line 378 "/home/spencer/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 50 "./../my-tension.h"
{; {

_stencil_val(ibmf.y,0,0,0); {
;_stencil_val(ibmf.y,0,0,0); {;_stencil_val(ibmf.y,0,0,0); }
;_stencil_val(ibmf.y,0,0,0); {;_stencil_val(ibmf.y,0,0,0); }      
}    





}   }}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 692 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(min:amin) reduction(max:amax) reduction(min:dmin)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 694
((Tree *)grid)->faces
#line 436
).n; _k++) {
 point.i = (
#line 694
((Tree *)grid)->faces
#line 437
).p[_k].i;

 point.j = (
#line 694
((Tree *)grid)->faces
#line 439
).p[_k].j;




 point.level = (
#line 694
((Tree *)grid)->faces
#line 444
).p[_k].level;
 _flags = (
#line 694
((Tree *)grid)->faces
#line 445
).p[_k].flags;
#line 49 "./../my-tension.h"
{
  
#line 699 "/home/spencer/basilisk/src/grid/tree.h"
if (_flags & face_x) {
    int ig = -1; NOT_UNUSED(ig);    
#line 50 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 50 "./../my-tension.h"
if (_const_fm.x > 0.) {

      if (val(ibmf.x,0,0,0) > 0.) {
      if (_const_alpha.x/val(ibmf.x,0,0,0) > amax) amax = _const_alpha.x/val(ibmf.x,0,0,0);
      if (_const_alpha.x/val(ibmf.x,0,0,0) < amin) amin = _const_alpha.x/val(ibmf.x,0,0,0);
      }




      if (Delta < dmin) dmin = Delta;
    }}
  
#line 702 "/home/spencer/basilisk/src/grid/tree.h"
}
  



if (_flags & face_y) {
    int jg = -1; NOT_UNUSED(jg);    
#line 50 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_y = Delta;

  double Delta_x = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_x);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 50 "./../my-tension.h"
if (_const_fm.y > 0.) {

      if (val(ibmf.y,0,0,0) > 0.) {
      if (_const_alpha.y/val(ibmf.y,0,0,0) > amax) amax = _const_alpha.y/val(ibmf.y,0,0,0);
      if (_const_alpha.y/val(ibmf.y,0,0,0) < amin) amin = _const_alpha.y/val(ibmf.y,0,0,0);
      }




      if (Delta < dmin) dmin = Delta;
    }}
  
#line 710 "/home/spencer/basilisk/src/grid/tree.h"
}
#line 61 "./../my-tension.h"
}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 696
}
#line 61 "./../my-tension.h"
{mpi_all_reduce_array(&dmin,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&amax,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&amin,MPI_DOUBLE,MPI_MIN,1);}}
  double rhom = (1./amin + 1./amax)/2.;





  double sigma = 0.;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){
    sigma += _attribute[c.i].sigma;}}
  if (sigma) {
    double dt = sqrt (rhom*( dmin*dmin*dmin)/(3.14159265358979*sigma));
    if (dt < dtmax)
      dtmax = dt;
  }
}{end_tracing("stability_1","./../my-tension.h",76);return 0;}end_tracing("stability_1","./../my-tension.h",76);}








static int acceleration_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 85 "./../my-tension.h"
      static int acceleration_2(const int i,const double t,Event *_ev){tracing("acceleration_2","./../my-tension.h",85);
{

  scalar  f0=new_scalar("f0");
  _attribute[f0.i].refine = _attribute[f0.i].prolongation = fraction_refine;
  

  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-tension.h", .line = 91, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 91 "./../my-tension.h"
{ 
_stencil_val(f,0,0,0);    _stencil_val_a(f0,0,0,0); 
_stencil_val(ch,0,0,0);    _stencil_val_a(f,0,0,0); 
  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 91 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 91 "./../my-tension.h"
{
    val(f0,0,0,0) = val(f,0,0,0);
    val(f,0,0,0) = val(ch,0,0,0);
  }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 96 "./../my-tension.h"
boundary_internal ((scalar *)((scalar[]){f,{-1}}), "./../my-tension.h", 96);




  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
    if (_attribute[f.i].sigma) {





      scalar phi = _attribute[f.i].phi;
      if (phi.i)
 curvature (f, phi, _attribute[f.i].sigma, true);
      else {
 phi = new_scalar("phi");
 curvature (f, phi, _attribute[f.i].sigma, false);
 _attribute[f.i].phi = phi;
      }
    }}}
  

    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../my-tension.h", .line = 118, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);        
#line 119 "./../my-tension.h"
{ _stencil_val(f0,0,0,0);_stencil_val_a(f,0,0,0); }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;        
#line 119 "./../my-tension.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 119 "./../my-tension.h"
val(f,0,0,0) = val(f0,0,0,0);}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 120 "./../my-tension.h"
boundary_internal ((scalar *)((scalar[]){f,{-1}}), "./../my-tension.h", 120);delete((scalar*)((scalar[]){f0,{-1}}));

}{end_tracing("acceleration_2","./../my-tension.h",122);return 0;}end_tracing("acceleration_2","./../my-tension.h",122);}
#line 10 "sessile-ibm-axi-osc.c"
#line 1 "../contact-ibm.h"
#line 1 "./../contact-ibm.h"
#line 17 "./../contact-ibm.h"
static inline coord normal_contact (coord ns, coord nf, double angle)
{
    coord n;

    if (- ns.x * nf.y + ns.y * nf.x > 0) {
        n.x = - ns.x * cos(angle) + ns.y * sin(angle);
        n.y = - ns.x * sin(angle) - ns.y * cos(angle);
    }
    else {
        n.x = - ns.x * cos(angle) - ns.y * sin(angle);
        n.y = ns.x * sin(angle) - ns.y * cos(angle);
    }
#line 55 "./../contact-ibm.h"
    return n;
}


void clean_fluid (scalar f, scalar fr, scalar ibm)
{
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 61, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 61 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(f,0,0,0); {
            int fluidNeighbors = 0;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 64 "./../contact-ibm.h"
{
_stencil_val(f,0,0,0); _stencil_val(ibm,0,0,0); {
                    ++fluidNeighbors;
                    
                }            
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
            
#line 70 "./../contact-ibm.h"
if (!fluidNeighbors)
                {_stencil_val_a(f,0,0,0);  }
        }    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 61 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 61 "./../contact-ibm.h"
{
        if (val(ibm,0,0,0) == 0. && val(f,0,0,0)) {
            int fluidNeighbors = 0;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 64 "./../contact-ibm.h"
{
                if (val(f,0,0,0) > 1e-11 && val(ibm,0,0,0)) {
                    ++fluidNeighbors;                    
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 67 "./../contact-ibm.h"
;
                }
            }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
            
#line 70 "./../contact-ibm.h"
if (!fluidNeighbors)
                val(f,0,0,0) = 0;
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 74 "./../contact-ibm.h"
}

void clean_fluid_real (scalar f, scalar fr, scalar ibm)
{
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 78, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 78 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(f,0,0,0); {
            int fluidNeighbors = 0;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 81 "./../contact-ibm.h"
{
_stencil_val(fr,0,0,0); _stencil_val(ibm,0,0,0); {
                    ++fluidNeighbors;
                    
                }            
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
            
#line 87 "./../contact-ibm.h"
if (!fluidNeighbors)
                {_stencil_val_a(f,0,0,0);  }
        }    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 78 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 78 "./../contact-ibm.h"
{
        if (val(ibm,0,0,0) == 0. && val(f,0,0,0)) {
            int fluidNeighbors = 0;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 81 "./../contact-ibm.h"
{
                if (val(fr,0,0,0) > 1e-11 && val(ibm,0,0,0)) {
                    ++fluidNeighbors;                    
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 84 "./../contact-ibm.h"
;
                }
            }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
            
#line 87 "./../contact-ibm.h"
if (!fluidNeighbors)
                val(f,0,0,0) = 0;
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 91 "./../contact-ibm.h"
}
#line 106 "./../contact-ibm.h"
void reconstruction_contact_test (scalar f, scalar fr, vector n, scalar alpha,
                                  vector ns, scalar alphas, scalar inter,
                                  scalar ghostInter, scalar extra)
{
    scalar  f0=new_scalar("f0");
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 111, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 111 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(fr,0,0,0); _stencil_val(fr,0,0,0); _stencil_val(ibm,0,0,0);
_stencil_is_interior_cell(point, ibm, NULL, fr);
#line 112
{
        
{            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;                
#line 117 "./../contact-ibm.h"
{_stencil_val(f,0,0,0); _stencil_val(ibm,0,0,0);       }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
            
#line 118 "./../contact-ibm.h"
_stencil_val_a(ghostInter,0,0,0);  
        }
            
{_stencil_val_a(ghostInter,0,0,0);  }}    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 111 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 111 "./../contact-ibm.h"
{
        if (val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1 && (val(fr,0,0,0) <= 1e-10 || val(fr,0,0,0) >= val(ibm,0,0,0) - 1e-10) &&
            !is_interior_cell(point, ibm, f, fr) && level == depth())
        {
            int near = 0;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;                
#line 117 "./../contact-ibm.h"
if (val(f,0,0,0) > 0 && val(ibm,0,0,0)) { near = 1;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 117 "./../contact-ibm.h"
; }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
            
#line 118 "./../contact-ibm.h"
val(ghostInter,0,0,0) = near;
        }
        else
            val(ghostInter,0,0,0) = 0;
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 124 "./../contact-ibm.h"
{if(!is_constant(contact_angle)){
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 124, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 124 "./../contact-ibm.h"
{ 

_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);        _stencil_val_a(inter,0,0,0); 

_stencil_val(inter,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);        _stencil_val_a(extra,0,0,0);

_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(f,0,0,0); _stencil_val(f,0,0,0); {  
             _stencil_facet_normal (point, ibm, ibmf);     
            _stencil_val(ibm,0,0,0); 
            

            
                { _stencil_val(n.x,0,0,0); }                { _stencil_val(n.y,0,0,0); }      

            
             _stencil_val(contact_angle,0,0,0);   

            
             
                 

             {
                    
                _stencil_val_a(n.x,0,0,0);  
            } 
#line 145
{
                    
                _stencil_val_a(n.y,0,0,0);  
            }
_stencil_val(f,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(alpha,0,0,0); _stencil_val(fr,0,0,0);            _stencil_val_a(alpha,0,0,0);
_stencil_val(extra,0,0,0); { 
_stencil_val(alpha,0,0,0);                _stencil_val_a(f,0,0,0);
_stencil_val(f,0,0,0); {
                    _stencil_val_a(fr,0,0,0);
_stencil_is_interior_cell(point, ibm, NULL, fr); {                        
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;                            
#line 157 "./../contact-ibm.h"
{_stencil_val(f,0,0,0); _stencil_val(ibm,0,0,0);       }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                        
#line 158 "./../contact-ibm.h"
_stencil_val_a(ghostInter,0,0,0);  
                    }                
} 
_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);                _stencil_val_a(inter,0,0,0); 
_stencil_val(inter,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(ghostInter,0,0,0); _stencil_val(fr,0,0,0); _stencil_val(ibm,0,0,0);                _stencil_val_a(extra,0,0,0);           
            }        
}    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 124 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 124 "./../contact-ibm.h"
{

        val(inter,0,0,0) = val(f,0,0,0) < 1 && val(f,0,0,0) > 0;

        val(extra,0,0,0) = val(inter,0,0,0) && val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1;

        if ((val(ibm,0,0,0) > 0+1e-10 && val(ibm,0,0,0) < 1-1e-10) && val(f,0,0,0) > 1e-10 && val(f,0,0,0) < 1 - 1e-10) {
            coord ns = facet_normal (point, ibm, ibmf);
            double alphas = line_alpha (val(ibm,0,0,0), ns);
            coord nf;

            
                nf.x = val(n.x,0,0,0);                nf.y = val(n.y,0,0,0);

            normalize (&ns);
            coord nc = normal_contact (ns, nf, val(contact_angle,0,0,0));

            double mag = 0;
            
                mag += fabs(nc.x);                mag += fabs(nc.y);

             {
                nc.x /= mag + 1e-30;
                val(n.x,0,0,0) = nc.x;
            } 
#line 145
{
                nc.y /= mag + 1e-30;
                val(n.y,0,0,0) = nc.y;
            }
            val(alpha,0,0,0) = immersed_alpha_temp (val(f,0,0,0), val(ibm,0,0,0), nc, val(alpha,0,0,0), ns, alphas, val(fr,0,0,0)
#line 1643 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 149 "./../contact-ibm.h"
);
            if (val(extra,0,0,0)) {
                val(f,0,0,0) = line_area(nc.x, nc.y, val(alpha,0,0,0));
                if (val(f,0,0,0) <= 0) {
                    val(fr,0,0,0) = 0;
                    if (!is_interior_cell(point, ibm, f, fr) && level == depth()) {
                        int near = 0;                        
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;                            
#line 157 "./../contact-ibm.h"
if (val(f,0,0,0) > 0 && val(ibm,0,0,0)) { near = 1;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 157 "./../contact-ibm.h"
; }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                        
#line 158 "./../contact-ibm.h"
val(ghostInter,0,0,0) = near;
                    }
                }
                val(inter,0,0,0) = val(f,0,0,0) < 1 && val(f,0,0,0) > 0;
                val(extra,0,0,0) = val(inter,0,0,0) && val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1 && !val(ghostInter,0,0,0) && val(fr,0,0,0) < val(ibm,0,0,0)-1e-10;
            }
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 165 "./../contact-ibm.h"
}else {double _const_contact_angle=_constant[contact_angle.i-_NVARMAX];NOT_UNUSED(_const_contact_angle);
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 124, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 124 "./../contact-ibm.h"
{ 

_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);        _stencil_val_a(inter,0,0,0); 

_stencil_val(inter,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);        _stencil_val_a(extra,0,0,0);

_stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(f,0,0,0); _stencil_val(f,0,0,0); {  
             _stencil_facet_normal (point, ibm, ibmf);     
            _stencil_val(ibm,0,0,0); 
            

            
                { _stencil_val(n.x,0,0,0); }                { _stencil_val(n.y,0,0,0); }


;   

            
             
                 

             {
                    
                _stencil_val_a(n.x,0,0,0);  
            } 
#line 145
{
                    
                _stencil_val_a(n.y,0,0,0);  
            }
_stencil_val(f,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(alpha,0,0,0); _stencil_val(fr,0,0,0);            _stencil_val_a(alpha,0,0,0);
_stencil_val(extra,0,0,0); { 
_stencil_val(alpha,0,0,0);                _stencil_val_a(f,0,0,0);
_stencil_val(f,0,0,0); {
                    _stencil_val_a(fr,0,0,0);
_stencil_is_interior_cell(point, ibm, NULL, fr); {                        
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;                            
#line 157 "./../contact-ibm.h"
{_stencil_val(f,0,0,0); _stencil_val(ibm,0,0,0);       }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                        
#line 158 "./../contact-ibm.h"
_stencil_val_a(ghostInter,0,0,0);  
                    }                
} 
_stencil_val(f,0,0,0); _stencil_val(f,0,0,0);                _stencil_val_a(inter,0,0,0); 
_stencil_val(inter,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(ghostInter,0,0,0); _stencil_val(fr,0,0,0); _stencil_val(ibm,0,0,0);                _stencil_val_a(extra,0,0,0);           
            }        
}    
}

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 124 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 124 "./../contact-ibm.h"
{

        val(inter,0,0,0) = val(f,0,0,0) < 1 && val(f,0,0,0) > 0;

        val(extra,0,0,0) = val(inter,0,0,0) && val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1;

        if ((val(ibm,0,0,0) > 0+1e-10 && val(ibm,0,0,0) < 1-1e-10) && val(f,0,0,0) > 1e-10 && val(f,0,0,0) < 1 - 1e-10) {
            coord ns = facet_normal (point, ibm, ibmf);
            double alphas = line_alpha (val(ibm,0,0,0), ns);
            coord nf;

            
                nf.x = val(n.x,0,0,0);                nf.y = val(n.y,0,0,0);

            normalize (&ns);
            coord nc = normal_contact (ns, nf, _const_contact_angle);

            double mag = 0;
            
                mag += fabs(nc.x);                mag += fabs(nc.y);

             {
                nc.x /= mag + 1e-30;
                val(n.x,0,0,0) = nc.x;
            } 
#line 145
{
                nc.y /= mag + 1e-30;
                val(n.y,0,0,0) = nc.y;
            }
            val(alpha,0,0,0) = immersed_alpha_temp (val(f,0,0,0), val(ibm,0,0,0), nc, val(alpha,0,0,0), ns, alphas, val(fr,0,0,0)
#line 1643 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 149 "./../contact-ibm.h"
);
            if (val(extra,0,0,0)) {
                val(f,0,0,0) = line_area(nc.x, nc.y, val(alpha,0,0,0));
                if (val(f,0,0,0) <= 0) {
                    val(fr,0,0,0) = 0;
                    if (!is_interior_cell(point, ibm, f, fr) && level == depth()) {
                        int near = 0;                        
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;                            
#line 157 "./../contact-ibm.h"
if (val(f,0,0,0) > 0 && val(ibm,0,0,0)) { near = 1;  
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 157 "./../contact-ibm.h"
; }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                        
#line 158 "./../contact-ibm.h"
val(ghostInter,0,0,0) = near;
                    }
                }
                val(inter,0,0,0) = val(f,0,0,0) < 1 && val(f,0,0,0) > 0;
                val(extra,0,0,0) = val(inter,0,0,0) && val(ibm,0,0,0) > 0 && val(ibm,0,0,0) < 1 && !val(ghostInter,0,0,0) && val(fr,0,0,0) < val(ibm,0,0,0)-1e-10;
            }
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 165 "./../contact-ibm.h"
}}

    boundary_internal ((scalar *)((scalar[]){f, fr, n.x, n.y, alpha, inter, ghostInter, extra,{-1}}), "./../contact-ibm.h", 167);delete((scalar*)((scalar[]){f0,{-1}}));
}
#line 179 "./../contact-ibm.h"
scalar  gginter={45};
scalar  gf0={46},  gf1={47},  gf2={48},  gf3={49},  gf4={50};

    scalar  inter={51};
    scalar  ghostInter={52};
    scalar  extra={53};

     
void set_contact_angle_tension (scalar f, scalar fr0, const scalar ibm,
                                vector nf, scalar alphaf, vector ns, scalar alphas)
{tracing("set_contact_angle_tension","./../contact-ibm.h",187);
#line 200 "./../contact-ibm.h"
    reconstruction_contact_test (f, fr0, nf, alphaf, ns, alphas, inter, ghostInter, extra);

    scalar  f0=new_scalar("f0");
  
    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 203, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 203 "./../contact-ibm.h"
{ 
_stencil_val(ghostInter,0,0,0);        _stencil_val_a(gginter,0,0,0); 
_stencil_val(f,0,0,0);        _stencil_val_a(f0,0,0,0); 
_stencil_val(f0,0,0,0);        _stencil_val_a(gf0,0,0,0); 
    }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 203 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 203 "./../contact-ibm.h"
{
        val(gginter,0,0,0) = val(ghostInter,0,0,0);
        val(f0,0,0,0) = val(f,0,0,0);
        val(gf0,0,0,0) = val(f0,0,0,0);
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}    
#line 208 "./../contact-ibm.h"
boundary_internal ((scalar *)((scalar[]){f0,{-1}}), "./../contact-ibm.h", 208);






    if(!is_constant(contact_angle)){
  






    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 215, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 215 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); {            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 222 "./../contact-ibm.h"
{
_stencil_val(extra,0,0,0); {         


                     _stencil_val(fr0,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);









; _stencil_val(nf.y,0,0,0);_stencil_val(nf.x,0,0,0); 

_stencil_val(alphaf,0,0,0);                








}            
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
#line 251 "./../contact-ibm.h"
{ {





                _stencil_val_a(f,0,0,0);      
            } 

{                
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 262 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0);{ 
                          
{_stencil_val(ibm,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0);
                        
                          
}}                
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
#line 270 "./../contact-ibm.h"
{
                    {_stencil_val_a(f,0,0,0);  } 

{                    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 274 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0);{
                               
{_stencil_val(ibm,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0);
                            
                              
}}                    
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                        
#line 283 "./../contact-ibm.h"
{_stencil_val_a(f,0,0,0);  }                
}}            

}}        

}
_stencil_val(ghostInter,0,0,0);
        {                
            
            
            


             _stencil_val(fr0,0,0,0);

;_stencil_val(ns.y,0,0,0);_stencil_val(ns.x,0,0,0);            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 299 "./../contact-ibm.h"
{
_stencil_val(extra,0,0,0); {
_stencil_val(nf.x,0,0,0); _stencil_val(nf.y,0,0,0);; 
                     
_stencil_val(contact_angle,0,0,0); _stencil_val(contact_angle,0,0,0);                     
#line 315
_stencil_val(fr0,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); 

                      

_stencil_val(alphaf,0,0,0); 

                          
#line 330 "./../contact-ibm.h"
                    
                }            
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
#line 340 "./../contact-ibm.h"
{ {







                _stencil_val_a(f,0,0,0);
_stencil_val(f,0,0,0); {_stencil_val_a(f,0,0,0);  }            




} 

{ _stencil_val(fr0,0,0,0); {
                _stencil_val_a(f,0,0,0);  
            }       }}        
}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 215 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 215 "./../contact-ibm.h"
{
        if (val(ibm,0,0,0) <= 0. && level == depth()) {
            double ghostf = 0., totalWeight = 0.;
            coord ghostCell = {x,y,z};
            int count = 0;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 222 "./../contact-ibm.h"
{
                if (val(extra,0,0,0)) {


                    double cellWeight = val(ibm,0,0,0) * (1. - val(ibm,0,0,0)) * val(fr0,0,0,0) * (1. - val(fr0,0,0,0));

                    totalWeight += cellWeight;

                    coord leftPoint = {x, y, z}, rightPoint;
                     {
                        leftPoint.x = (ghostCell.x - leftPoint.x) / Delta - 0.5;
                        rightPoint.x = leftPoint.x + 1.;
                    } 
#line 231
{
                        leftPoint.y = (ghostCell.y - leftPoint.y) / Delta - 0.5;
                        rightPoint.y = leftPoint.y + 1.;
                    }

                    coord nf1 = {val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension};

                    ghostf += cellWeight * rectangle_fraction (nf1, val(alphaf,0,0,0), leftPoint, rightPoint);







                    count++;
                }
            }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }


            
#line 251 "./../contact-ibm.h"
if (totalWeight > 0.) {





                val(f,0,0,0) = ghostf / (totalWeight + 1e-30);
            }

            else {
                bool check = false;                
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 262 "./../contact-ibm.h"
{
                    if (val(ibm,0,0,0) && val(fr0,0,0,0) >= val(ibm,0,0,0) - 1e-6)
                        check = true;
                    else if (val(ibm,0,0,0) && val(fr0,0,0,0) < val(ibm,0,0,0) - 1e-6) {
                        check = false;                        
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 267 "./../contact-ibm.h"
;
                    }
                }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                
#line 270 "./../contact-ibm.h"
if (check)
                    val(f,0,0,0) = 1;

                else {                    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 274 "./../contact-ibm.h"
{
                        if (val(ibm,0,0,0) && val(fr0,0,0,0) >= val(ibm,0,0,0) - 1e-6)
                            check = true;
                        else if (val(ibm,0,0,0) && val(fr0,0,0,0) < val(ibm,0,0,0) - 1e-6) {
                            check = false;                            
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 279 "./../contact-ibm.h"
;
                        }
                    }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                    
#line 282 "./../contact-ibm.h"
if (check)
                        val(f,0,0,0) = 1;
                }

            }

        }
        if (val(ghostInter,0,0,0))
        {
            double ghostf = 0., totalWeight = 0.;
            coord ghostCell = {x,y,z};
            int count = 0;


            int cond0 = val(fr0,0,0,0) <= 1e-10;

            coord ns0 = {-val(ns.x,0,0,0), -val(ns.y,0,0,0), -_val_higher_dimension}, nf1;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 299 "./../contact-ibm.h"
{
                if (val(extra,0,0,0)) {
                    nf1 = (coord){val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension};

                    if ((val(contact_angle,0,0,0) > 3.*3.14159265358979/4. || val(contact_angle,0,0,0) < 3.14159265358979/4.) &&
                        cond0 && dot_product_norm(nf1, ns0) <= 0)
                        continue;



                    coord leftPoint = {x, y, z}, rightPoint;
                     {
                        leftPoint.x = (ghostCell.x - leftPoint.x) / Delta - 0.5;
                        rightPoint.x = leftPoint.x + 1.;
                    } 
#line 310
{
                        leftPoint.y = (ghostCell.y - leftPoint.y) / Delta - 0.5;
                        rightPoint.y = leftPoint.y + 1.;
                    }

                    double cellWeight = val(ibm,0,0,0) * (1. - val(ibm,0,0,0)) * val(fr0,0,0,0) * (1. - val(fr0,0,0,0));

                    totalWeight += cellWeight;

                    ghostf += cellWeight * rectangle_fraction (nf1, val(alphaf,0,0,0), leftPoint, rightPoint);
#line 330 "./../contact-ibm.h"
                    count++;
                }
            }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }







            
#line 340 "./../contact-ibm.h"
if (totalWeight > 0.) {







                val(f,0,0,0) = ghostf / totalWeight;
                if (val(f,0,0,0) > 1 - 1e-10) val(f,0,0,0) = 1;




            }

            else if (ghostf <= 0 && val(fr0,0,0,0) <= 1e-10 ) {
                val(f,0,0,0) = 0;
            }
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 360 "./../contact-ibm.h"
}else {double _const_contact_angle=_constant[contact_angle.i-_NVARMAX];NOT_UNUSED(_const_contact_angle);    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 215, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 215 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); {            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 222 "./../contact-ibm.h"
{
_stencil_val(extra,0,0,0); {         


                     _stencil_val(fr0,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0);









; _stencil_val(nf.y,0,0,0);_stencil_val(nf.x,0,0,0); 

_stencil_val(alphaf,0,0,0);                








}            
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
#line 251 "./../contact-ibm.h"
{ {





                _stencil_val_a(f,0,0,0);      
            } 

{                
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 262 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0);{ 
                          
{_stencil_val(ibm,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0);
                        
                          
}}                
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
#line 270 "./../contact-ibm.h"
{
                    {_stencil_val_a(f,0,0,0);  } 

{                    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 274 "./../contact-ibm.h"
{
_stencil_val(ibm,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0);{
                               
{_stencil_val(ibm,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0);
                            
                              
}}                    
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                        
#line 283 "./../contact-ibm.h"
{_stencil_val_a(f,0,0,0);  }                
}}            

}}        

}
_stencil_val(ghostInter,0,0,0);
        {                
            
            
            


             _stencil_val(fr0,0,0,0);

;_stencil_val(ns.y,0,0,0);_stencil_val(ns.x,0,0,0);            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 299 "./../contact-ibm.h"
{
_stencil_val(extra,0,0,0); {
_stencil_val(nf.x,0,0,0); _stencil_val(nf.y,0,0,0);;

;;                     
#line 315
_stencil_val(fr0,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(ibm,0,0,0); 

                      

_stencil_val(alphaf,0,0,0); 

                          
#line 330 "./../contact-ibm.h"
                    
                }            
}      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
#line 340 "./../contact-ibm.h"
{ {







                _stencil_val_a(f,0,0,0);
_stencil_val(f,0,0,0); {_stencil_val_a(f,0,0,0);  }            




} 

{ _stencil_val(fr0,0,0,0); {
                _stencil_val_a(f,0,0,0);  
            }       }}        
}    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 215 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 215 "./../contact-ibm.h"
{
        if (val(ibm,0,0,0) <= 0. && level == depth()) {
            double ghostf = 0., totalWeight = 0.;
            coord ghostCell = {x,y,z};
            int count = 0;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 222 "./../contact-ibm.h"
{
                if (val(extra,0,0,0)) {


                    double cellWeight = val(ibm,0,0,0) * (1. - val(ibm,0,0,0)) * val(fr0,0,0,0) * (1. - val(fr0,0,0,0));

                    totalWeight += cellWeight;

                    coord leftPoint = {x, y, z}, rightPoint;
                     {
                        leftPoint.x = (ghostCell.x - leftPoint.x) / Delta - 0.5;
                        rightPoint.x = leftPoint.x + 1.;
                    } 
#line 231
{
                        leftPoint.y = (ghostCell.y - leftPoint.y) / Delta - 0.5;
                        rightPoint.y = leftPoint.y + 1.;
                    }

                    coord nf1 = {val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension};

                    ghostf += cellWeight * rectangle_fraction (nf1, val(alphaf,0,0,0), leftPoint, rightPoint);







                    count++;
                }
            }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }


            
#line 251 "./../contact-ibm.h"
if (totalWeight > 0.) {





                val(f,0,0,0) = ghostf / (totalWeight + 1e-30);
            }

            else {
                bool check = false;                
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 262 "./../contact-ibm.h"
{
                    if (val(ibm,0,0,0) && val(fr0,0,0,0) >= val(ibm,0,0,0) - 1e-6)
                        check = true;
                    else if (val(ibm,0,0,0) && val(fr0,0,0,0) < val(ibm,0,0,0) - 1e-6) {
                        check = false;                        
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 267 "./../contact-ibm.h"
;
                    }
                }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                
#line 270 "./../contact-ibm.h"
if (check)
                    val(f,0,0,0) = 1;

                else {                    
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 274 "./../contact-ibm.h"
{
                        if (val(ibm,0,0,0) && val(fr0,0,0,0) >= val(ibm,0,0,0) - 1e-6)
                            check = true;
                        else if (val(ibm,0,0,0) && val(fr0,0,0,0) < val(ibm,0,0,0) - 1e-6) {
                            check = false;                            
#line 17 "/home/spencer/basilisk/src/grid/neighbors.h"
(_k = _l = _nn + 1)
#line 279 "./../contact-ibm.h"
;
                        }
                    }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }
                    
#line 282 "./../contact-ibm.h"
if (check)
                        val(f,0,0,0) = 1;
                }

            }

        }
        if (val(ghostInter,0,0,0))
        {
            double ghostf = 0., totalWeight = 0.;
            coord ghostCell = {x,y,z};
            int count = 0;


            int cond0 = val(fr0,0,0,0) <= 1e-10;

            coord ns0 = {-val(ns.x,0,0,0), -val(ns.y,0,0,0), -_val_higher_dimension}, nf1;            
#line 18 "/home/spencer/basilisk/src/grid/neighbors.h"
{
    const int _nn = 2;
    const int _i = point.i, _j = point.j;
    for (int _k = - _nn; _k <= _nn; _k++) {
      point.i = _i + _k;
      for (int _l = - _nn; _l <= _nn; _l++) {
 point.j = _j + _l; 
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2; 
#line 299 "./../contact-ibm.h"
{
                if (val(extra,0,0,0)) {
                    nf1 = (coord){val(nf.x,0,0,0), val(nf.y,0,0,0), _val_higher_dimension};

                    if ((_const_contact_angle > 3.*3.14159265358979/4. || _const_contact_angle < 3.14159265358979/4.) &&
                        cond0 && dot_product_norm(nf1, ns0) <= 0)
                        continue;



                    coord leftPoint = {x, y, z}, rightPoint;
                     {
                        leftPoint.x = (ghostCell.x - leftPoint.x) / Delta - 0.5;
                        rightPoint.x = leftPoint.x + 1.;
                    } 
#line 310
{
                        leftPoint.y = (ghostCell.y - leftPoint.y) / Delta - 0.5;
                        rightPoint.y = leftPoint.y + 1.;
                    }

                    double cellWeight = val(ibm,0,0,0) * (1. - val(ibm,0,0,0)) * val(fr0,0,0,0) * (1. - val(fr0,0,0,0));

                    totalWeight += cellWeight;

                    ghostf += cellWeight * rectangle_fraction (nf1, val(alphaf,0,0,0), leftPoint, rightPoint);
#line 330 "./../contact-ibm.h"
                    count++;
                }
            }      
#line 27 "/home/spencer/basilisk/src/grid/neighbors.h"
}
    }
    point.i = _i; point.j = _j;
  }







            
#line 340 "./../contact-ibm.h"
if (totalWeight > 0.) {







                val(f,0,0,0) = ghostf / totalWeight;
                if (val(f,0,0,0) > 1 - 1e-10) val(f,0,0,0) = 1;




            }

            else if (ghostf <= 0 && val(fr0,0,0,0) <= 1e-10 ) {
                val(f,0,0,0) = 0;
            }
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 360 "./../contact-ibm.h"
}





    scalar  ftmp=new_scalar("ftmp");    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 367, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 367 "./../contact-ibm.h"
{ 
_stencil_val(f,0,0,0);        _stencil_val_a(ftmp,0,0,0); 
    }    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 367 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 367 "./../contact-ibm.h"
{
        val(ftmp,0,0,0) = val(f,0,0,0);
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}    
#line 370 "./../contact-ibm.h"
boundary_internal ((scalar *)((scalar[]){ftmp,fr0,f,{-1}}), "./../contact-ibm.h", 370);





{  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "./../contact-ibm.h", .line = 376, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 376 "./../contact-ibm.h"
{ 
_stencil_val(f,0,0,0);        _stencil_val_a(gf1,0,0,0);
_stencil_val(ghostInter,0,0,0); _stencil_val(fr0,0,0,0); _stencil_val(ibm,0,0,0); _stencil_val(f,0,0,0); _stencil_val(f0,0,0,0); _stencil_val(f,0,0,0); {  

             _stencil_mycs (point, ftmp); 
{  
                 _stencil_val(ftmp,0,0,0);
                _stencil_val_a(ftmp,0,0,0); 
_stencil_mycs (point, ftmp);                
_stencil_val_a(ftmp,0,0,0);  
            }

; _stencil_val(ns.y,0,0,0);_stencil_val(ns.x,0,0,0);    
            _stencil_val(ftmp,0,0,0);   
                                             
            _stencil_val(ibm,0,0,0); 
#line 390
_stencil_val(alphas,0,0,0);_stencil_val(ftmp,0,0,0); 

_stencil_val(fr0,0,0,0); {        
                 _stencil_val(ibm,0,0,0); _stencil_val(f,0,0,0); _stencil_val(alphas,0,0,0);_stencil_val(fr0,0,0,0);     
                
                _stencil_val_a(f,0,0,0);    
            }        




}
_stencil_val(extra,0,0,0);_stencil_val(ghostInter,0,0,0); {  
             _stencil_mycs (point, ftmp); 
{
              _stencil_val_a(f,0,0,0);  
              
            }
; _stencil_val(ns.y,0,0,0);_stencil_val(ns.x,0,0,0);      
             _stencil_val(fr0,0,0,0); _stencil_val(alphas,0,0,0); _stencil_val(alphaf,0,0,0); _stencil_val(ibm,0,0,0);_stencil_val(f,0,0,0);
            _stencil_val_a(f,0,0,0);    
        }    
}    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags; 
#line 376 "./../contact-ibm.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 376 "./../contact-ibm.h"
{
        val(gf1,0,0,0) = val(f,0,0,0);
        if (val(ghostInter,0,0,0) && val(fr0,0,0,0) >= val(ibm,0,0,0) - 1e-10 && val(f,0,0,0) != val(f0,0,0,0) && val(f,0,0,0) != 1.) {

            coord mf = mycs (point, ftmp);
            if (!mf.x && !mf.y && !mf.z) {
                double ftemp = val(ftmp,0,0,0);
                val(ftmp,0,0,0) = 0.5;
                mf = mycs (point, ftmp);
                val(ftmp,0,0,0) = ftemp;
            }

            coord ns1 = {val(ns.x,0,0,0), val(ns.y,0,0,0), _val_higher_dimension};
            double alpha = line_alpha(val(ftmp,0,0,0), mf);
            double fr = immersed_fraction(val(ftmp,0,0,0), mf, alpha, ns1, val(alphas,0,0,0)
,                                         (coord){-0.5,-0.5,-0.5}, (coord){0.5,0.5,0.5}
#line 1081 "./../ibm-gcm-vof-test.h"
, 0, 0
#line 391 "./../contact-ibm.h"
)*val(ibm,0,0,0);
            if (!approx_equal_double(fr, val(fr0,0,0,0)
#line 142 "./../ibm-gcm.h"
, 1e-11
#line 392 "./../contact-ibm.h"
)) {
                const tripoint tcell = fill_tripoint (val(fr0,0,0,0), mf, alpha, ns1, val(alphas,0,0,0), val(f,0,0,0), val(ibm,0,0,0));
                double alphatmp = ghost_alpha(tcell, -0.6, 0.6
#line 1346 "./../ibm-gcm-vof-test.h"
, NULL
#line 394 "./../contact-ibm.h"
);
                val(f,0,0,0) = line_area(mf.x, mf.y, alphatmp);
            }




        }
        if (val(extra,0,0,0) && !val(ghostInter,0,0,0)) {
            coord nf1 = mycs (point, ftmp);
            if (!nf1.x && !nf1.y && !nf1.z) {
              val(f,0,0,0) = 0;
              continue;
            }
            coord ns1 = {val(ns.x,0,0,0), val(ns.y,0,0,0), _val_higher_dimension};
            double alpha = immersed_alpha_temp (val(f,0,0,0), val(ibm,0,0,0), nf1, val(alphaf,0,0,0), ns1, val(alphas,0,0,0), val(fr0,0,0,0)
#line 1643 "./../ibm-gcm-vof-test.h"
, 1e-9, NULL
#line 409 "./../contact-ibm.h"
);
            val(f,0,0,0) = line_area(nf1.x, nf1.y, alpha);
        }
    }}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 412 "./../contact-ibm.h"
}
#line 444 "./../contact-ibm.h"
    boundary_internal ((scalar *)((scalar[]){f,{-1}}), "./../contact-ibm.h", 444);delete((scalar*)((scalar[]){ftmp,f0,{-1}}));
end_tracing("set_contact_angle_tension","./../contact-ibm.h",445);}
#line 11 "sessile-ibm-axi-osc.c"



const int maxlevel = 7;

double tend = 15;
double theta0, Oh = 0.025;

static double _boundary13(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 19 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 19 "sessile-ibm-axi-osc.c"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = false, 0 : Delta*0 + val(_s,0,0,0)));}}}static double _boundary13_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 19 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 19 "sessile-ibm-axi-osc.c"
{return( ( data ? ((bool *)data)[0] = false, 0 : val(_s,0,0,0)));}}}
static double _boundary14(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 20 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 20 "sessile-ibm-axi-osc.c"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, 0 : 2.*0 - val(_s,0,0,0)));}}}static double _boundary14_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 20 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 20 "sessile-ibm-axi-osc.c"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}

static double _boundary15(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 22 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 22 "sessile-ibm-axi-osc.c"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, 0 : 2.*0 - val(_s,0,0,0)));}}}static double _boundary15_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 22 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 22 "sessile-ibm-axi-osc.c"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}

static double _boundary16(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "sessile-ibm-axi-osc.c"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, 0 : 2.*0 - val(_s,0,0,0)));}}}static double _boundary16_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 24 "sessile-ibm-axi-osc.c"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}
static double _boundary17(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 25 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 25 "sessile-ibm-axi-osc.c"
{return( ( data ? ibm_area_center (point, _s, &x, &y, &z),    ((bool *)data)[0] = true, 0 : 2.*0 - val(_s,0,0,0)));}}}static double _boundary17_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 25 "sessile-ibm-axi-osc.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 25 "sessile-ibm-axi-osc.c"
{return( ( data ? ((bool *)data)[0] = true, 0 : - val(_s,0,0,0)));}}}



int main()
{
#line 60
_init_solver();  
#line 31
size (1.);




  origin (-0.2626, 0
#line 106 "/home/spencer/basilisk/src/common.h"
, 0.
#line 36 "sessile-ibm-axi-osc.c"
);
  init_grid (1 << maxlevel);

  TOLERANCE = 1e-5;

  rho1 = rho2 = 1;
  _attribute[f.i].sigma = 0.1;
  mu1 = mu2 = Oh * sqrt(rho1 * _attribute[f.i].sigma * 0.5);


  double angles[2] = {50, 130};
  for (int i = 0; i < 2; i++) {
    theta0 = angles[i];
    tend = 15.001;
    const scalar c = new_const_scalar("c",13, theta0*3.14159265358979/180.);
    contact_angle = c;
    run();
  }






free_solver();}

double v0 = 0;

static int init_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 0)!=0;*ip=i;*tp=t;return ret;}      static int init_0(const int i,const double t,Event *_ev){tracing("init_0","sessile-ibm-axi-osc.c",64);
{





  scalar  phi=new_vertex_scalar("phi");
  
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "sessile-ibm-axi-osc.c", .line = 72, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;    
#line 73 "sessile-ibm-axi-osc.c"
{_stencil_val_a(phi,0,0,0);  }
  
#line 338 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 1708 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 1710
((Tree *)grid)->vertices
#line 436
).n; _k++) {
 point.i = (
#line 1710
((Tree *)grid)->vertices
#line 437
).p[_k].i;

 point.j = (
#line 1710
((Tree *)grid)->vertices
#line 439
).p[_k].j;




 point.level = (
#line 1710
((Tree *)grid)->vertices
#line 444
).p[_k].level;
 _flags = (
#line 1710
((Tree *)grid)->vertices
#line 445
).p[_k].flags; 
#line 1710
{
    int ig = -1; NOT_UNUSED (ig);

    int jg = -1; NOT_UNUSED (jg);    
#line 73 "sessile-ibm-axi-osc.c"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 73 "sessile-ibm-axi-osc.c"
val(phi,0,0,0) = x;}
  
#line 1719 "/home/spencer/basilisk/src/grid/tree.h"
}      
#line 447
}
  }
}

#line 1720
}  
#line 74 "sessile-ibm-axi-osc.c"
boundary_internal ((scalar *)((scalar[]){phi,{-1}}), "sessile-ibm-axi-osc.c", 74);
  fractions (phi, ibm, ibmf
#line 122 "/home/spencer/basilisk/src/fractions.h"
, 0.
#line 75 "sessile-ibm-axi-osc.c"
);
  
  
#line 359 "/home/spencer/basilisk/src/fractions.h"
{
    scalar  phi=new_vertex_scalar("phi");    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 361, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
      
#line 362 "/home/spencer/basilisk/src/fractions.h"
{_stencil_val_a(phi,0,0,0);          }  
#line 338 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 1708 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 1710
((Tree *)grid)->vertices
#line 436
).n; _k++) {
 point.i = (
#line 1710
((Tree *)grid)->vertices
#line 437
).p[_k].i;

 point.j = (
#line 1710
((Tree *)grid)->vertices
#line 439
).p[_k].j;




 point.level = (
#line 1710
((Tree *)grid)->vertices
#line 444
).p[_k].level;
 _flags = (
#line 1710
((Tree *)grid)->vertices
#line 445
).p[_k].flags; 
#line 1710
{
    int ig = -1; NOT_UNUSED (ig);

    int jg = -1; NOT_UNUSED (jg);      
#line 362 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 362 "/home/spencer/basilisk/src/fractions.h"
val(phi,0,0,0) = (
#line 76 "sessile-ibm-axi-osc.c"
- (( x*x) + ( y*y) - ( (0.5/2.)*(0.5/2.)))
#line 362 "/home/spencer/basilisk/src/fractions.h"
);}
  
#line 1719 "/home/spencer/basilisk/src/grid/tree.h"
}      
#line 447
}
  }
}

#line 1720
}    
#line 363 "/home/spencer/basilisk/src/fractions.h"
fractions (phi, f
#line 121
,
(  vector) {0}, 0.
#line 363
);delete((scalar*)((scalar[]){phi,{-1}}));
  }  
#line 359
{
    scalar  phi=new_vertex_scalar("phi");    
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/spencer/basilisk/src/fractions.h", .line = 361, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
      
#line 362 "/home/spencer/basilisk/src/fractions.h"
{_stencil_val_a(phi,0,0,0);          }  
#line 338 "/home/spencer/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 1708 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 1710
((Tree *)grid)->vertices
#line 436
).n; _k++) {
 point.i = (
#line 1710
((Tree *)grid)->vertices
#line 437
).p[_k].i;

 point.j = (
#line 1710
((Tree *)grid)->vertices
#line 439
).p[_k].j;




 point.level = (
#line 1710
((Tree *)grid)->vertices
#line 444
).p[_k].level;
 _flags = (
#line 1710
((Tree *)grid)->vertices
#line 445
).p[_k].flags; 
#line 1710
{
    int ig = -1; NOT_UNUSED (ig);

    int jg = -1; NOT_UNUSED (jg);      
#line 362 "/home/spencer/basilisk/src/fractions.h"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 362 "/home/spencer/basilisk/src/fractions.h"
val(phi,0,0,0) = (
#line 77 "sessile-ibm-axi-osc.c"
- (( x*x) + ( y*y) - ( (0.5/2.)*(0.5/2.)))
#line 362 "/home/spencer/basilisk/src/fractions.h"
);}
  
#line 1719 "/home/spencer/basilisk/src/grid/tree.h"
}      
#line 447
}
  }
}

#line 1720
}    
#line 363 "/home/spencer/basilisk/src/fractions.h"
fractions (phi, ch
#line 121
,
(  vector) {0}, 0.
#line 363
);delete((scalar*)((scalar[]){phi,{-1}}));
  }  
#line 79 "sessile-ibm-axi-osc.c"
v0 = real_volume(f);delete((scalar*)((scalar[]){phi,{-1}}));
}{end_tracing("init_0","sessile-ibm-axi-osc.c",80);return 0;}end_tracing("init_0","sessile-ibm-axi-osc.c",80);}

static int logfile_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=( t <= tend)!=0;*ip=i;*tp=t;return ret;}static int logfile_expr1(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int logfile(const int i,const double t,Event *_ev){tracing("logfile","sessile-ibm-axi-osc.c",82);
{





  scalar  kappa=new_scalar("kappa");
  curvature (ch, kappa
#line 541 "/home/spencer/basilisk/src/curvature.h"
, 
1., false
#line 90 "sessile-ibm-axi-osc.c"
);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "sessile-ibm-axi-osc.c", .line = 91, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 92 "sessile-ibm-axi-osc.c"
{_stencil_val(ibm,0,0,0);
      {_stencil_val_a(kappa,0,0,0);  }   }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 92 "sessile-ibm-axi-osc.c"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 92 "sessile-ibm-axi-osc.c"
if (val(ibm,0,0,0) < 1.)
      val(kappa,0,0,0) = 1e30f;}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 94 "sessile-ibm-axi-osc.c"
if (statsf (kappa).stddev < 1e-6)
    {delete((scalar*)((scalar[]){kappa,{-1}}));{end_tracing("logfile","sessile-ibm-axi-osc.c",95);return true;}}

  double vreal = 0;
  if(!is_constant(cm)){
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "sessile-ibm-axi-osc.c", .line = 98, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 99 "sessile-ibm-axi-osc.c"
{ _stencil_val(cr,0,0,0);_stencil_val(cm,0,0,0);  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:vreal)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 99 "sessile-ibm-axi-osc.c"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 99 "sessile-ibm-axi-osc.c"
vreal += val(cr,0,0,0)*( Delta*Delta)*val(cm,0,0,0);}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 99 "sessile-ibm-axi-osc.c"
{mpi_all_reduce_array(&vreal,MPI_DOUBLE,MPI_SUM,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "sessile-ibm-axi-osc.c", .line = 98, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 99 "sessile-ibm-axi-osc.c"
{ _stencil_val(cr,0,0,0);;  }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL (reduction(+:vreal)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 99 "sessile-ibm-axi-osc.c"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 99 "sessile-ibm-axi-osc.c"
vreal += val(cr,0,0,0)*( Delta*Delta)*_const_cm;}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}
#line 99 "sessile-ibm-axi-osc.c"
{mpi_all_reduce_array(&vreal,MPI_DOUBLE,MPI_SUM,1);}}


  scalar  pos=new_scalar("pos");
  position (cr, pos,
#line 736 "/home/spencer/basilisk/src/curvature.h"
(        coord) 
#line 103 "sessile-ibm-axi-osc.c"
{1,0}
#line 736 "/home/spencer/basilisk/src/curvature.h"
,( coord) {0}, false
#line 103 "sessile-ibm-axi-osc.c"
);
  double hmax = statsf(pos).max;




  double perror = i == 0? 0: (vreal - v0)/v0 * 100;

  fprintf(ferr, "%d %g %g %g %g %g %g\n", i, t, theta0, v0, vreal, perror, hmax);
  fprintf(fout, "%d %g %g %g %g %g %g\n", i, t, theta0, v0, vreal, perror, hmax);delete((scalar*)((scalar[]){pos,kappa,{-1}}));
}{end_tracing("logfile","sessile-ibm-axi-osc.c",113);return 0;}end_tracing("logfile","sessile-ibm-axi-osc.c",113);}
#line 124 "sessile-ibm-axi-osc.c"
double equivalent_contact_angle (double R, double V)
{
  double x0 = 0., x1 = 3.14159265358979;
  while (x1 - x0 > 1e-4) {
    double x = (x1 + x0)/2.;
    double f = V - ( R*R)*(x - sin(x)*cos(x));
    if (f > 0.)
      x0 = x;
    else
      x1 = x;
  }
  return (x0 + x1)/2.;
}

static int end_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = TEND_EVENT)!=0;*ip=i;*tp=t;return ret;}      static int end(const int i,const double t,Event *_ev){tracing("end","sessile-ibm-axi-osc.c",138);
{



  char name[80];
  sprintf (name, "shape-%g", theta0);
  FILE * fp = fopen (name, "w");
  output_facets (ch, fp
#line 516 "/home/spencer/basilisk/src/fractions.h"
,( vector) {{-1}}
#line 146 "sessile-ibm-axi-osc.c"
);




  scalar  kappa=new_scalar("kappa");
  curvature (ch, kappa
#line 541 "/home/spencer/basilisk/src/curvature.h"
, 
1., false
#line 152 "sessile-ibm-axi-osc.c"
);
  
  
#line 314 "/home/spencer/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "sessile-ibm-axi-osc.c", .line = 153, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 154 "sessile-ibm-axi-osc.c"
{_stencil_val(ibm,0,0,0);
      {_stencil_val_a(kappa,0,0,0);  }   }

    
#line 328 "/home/spencer/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 684 "/home/spencer/basilisk/src/grid/tree.h"
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
#line 423
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    point.i = 2;

    point.j = 2;




    int _k; unsigned short _flags; NOT_UNUSED(_flags);
    OMP(omp for schedule(static))
      for (_k = 0; _k < (
#line 686
((Tree *)grid)->leaves
#line 436
).n; _k++) {
 point.i = (
#line 686
((Tree *)grid)->leaves
#line 437
).p[_k].i;

 point.j = (
#line 686
((Tree *)grid)->leaves
#line 439
).p[_k].j;




 point.level = (
#line 686
((Tree *)grid)->leaves
#line 444
).p[_k].level;
 _flags = (
#line 686
((Tree *)grid)->leaves
#line 445
).p[_k].flags;    
#line 154 "sessile-ibm-axi-osc.c"
{  
#line 3 "/home/spencer/basilisk/src/grid/variables.h"
double Delta = L0*(1./(1 << point.level));
  double Delta_x = Delta;

  double Delta_y = Delta;





  double x = ((ig + 1)/2. + (point.i - 2))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2))*Delta + Y0;



  NOT_UNUSED(y);



  double z = 0.;

  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);





  ;
  
#line 321 "/home/spencer/basilisk/src/grid/tree.h"
int level = point.level; NOT_UNUSED(level);



  struct { int x, y; } child = {
    2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1
  };





  NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;

  parent.j = (point.j + 2)/2;
#line 154 "sessile-ibm-axi-osc.c"
if (val(ibm,0,0,0) < 1.)
      val(kappa,0,0,0) = 1e30f;}
      
#line 447 "/home/spencer/basilisk/src/grid/tree.h"
}
  }
}

#line 688
}  
#line 157 "sessile-ibm-axi-osc.c"
stats s = statsf (kappa);
  double R = s.volume/s.sum, V = 2*3.14159265358979*statsf(cr).sum;

  static FILE * fp2 =NULL;if(!fp2||i==0)fp2=pid()>0?fopen("/dev/null","w"): fopen ("results", "w");

  fprintf (fp2, "%d %g %.5g %.3g %.4g %g %g\n", N, theta0, R, s.stddev,
    equivalent_contact_angle (R, V)*180./3.14159265358979, v0, V);

  fflush(fp2);
  if (theta0 == 165)
      fclose (fp2);delete((scalar*)((scalar[]){kappa,{-1}}));
}{end_tracing("end","sessile-ibm-axi-osc.c",168);return 0;}end_tracing("end","sessile-ibm-axi-osc.c",168);}
#line 2 "ast/init_solver.h"

static void _init_solver (void)
{
  void init_solver();
datasize=54*sizeof(real);  init_solver();
  {
#line 24
quadtree_methods();

    

    
#line 12
{
      
      
    
      {  
#line 2326 "./../ibm-gcm.h"
event_register((Event){0,1,metric,{metric_expr0},((int *)0),((double *)0),"./../ibm-gcm.h",2326,"metric"});  
#line 203 "./../my-axi.h"
event_register((Event){0,1,metric_0,{metric_0_expr0},((int *)0),((double *)0),"./../my-axi.h",203,"metric"});  
#line 42 "/home/spencer/basilisk/src/run.h"
event_register((Event){0,1,defaults,{defaults_expr0},((int *)0),((double *)0),"/home/spencer/basilisk/src/run.h",42,"defaults"});  
#line 143 "./../my-centered.h"
event_register((Event){0,1,defaults_0,{defaults_0_expr0},((int *)0),((double *)0),"./../my-centered.h",143,"defaults"});  
#line 222
event_register((Event){0,1,default_display,{default_display_expr0},((int *)0),((double *)0),"./../my-centered.h",222,"default_display"});  








event_register((Event){0,1,init,{init_expr0},((int *)0),((double *)0),"./../my-centered.h",231,"init"});  
#line 14 "./../ibm-gcm-events.h"
event_register((Event){0,1,update_metric,{update_metric_expr0},((int *)0),((double *)0),"./../ibm-gcm-events.h",14,"update_metric"});  
#line 66 "./../my-vof-testv2.h"
event_register((Event){0,1,defaults_1,{defaults_1_expr0},((int *)0),((double *)0),"./../my-vof-testv2.h",66,"defaults"});  
#line 87
event_register((Event){0,1,defaults_2,{defaults_2_expr0},((int *)0),((double *)0),"./../my-vof-testv2.h",87,"defaults"});  
#line 10 "./../my-two-phase-generic.h"
event_register((Event){0,1,defaults_3,{defaults_3_expr0},((int *)0),((double *)0),"./../my-two-phase-generic.h",10,"defaults"});  
#line 31 "./../my-iforce.h"
event_register((Event){0,1,defaults_4,{defaults_4_expr0},((int *)0),((double *)0),"./../my-iforce.h",31,"defaults"});  
#line 64 "sessile-ibm-axi-osc.c"
event_register((Event){0,1,init_0,{init_0_expr0},((int *)0),((double *)0),"sessile-ibm-axi-osc.c",64,"init"});  
#line 82
event_register((Event){0,2,logfile,{logfile_expr0,logfile_expr1},((int *)0),((double *)0),"sessile-ibm-axi-osc.c",82,"logfile"});  
#line 138
event_register((Event){0,1,end,{end_expr0},((int *)0),((double *)0),"sessile-ibm-axi-osc.c",138,"end"});
	
	
	
      
#line 22 "ast/init_solver.h"
}
#line 385 "/home/spencer/basilisk/src/common.h"
init_const_vector((vector){{_NVARMAX+3},{_NVARMAX+4}},"zerof",(double[]){0.,0.,0.});
init_const_vector((vector){{_NVARMAX+5},{_NVARMAX+6}},"unityf",(double[]){1.,1.,1.});
init_const_scalar((scalar){_NVARMAX+7},"unity", 1.);
init_const_scalar((scalar){_NVARMAX+8},"zeroc", 0.);



init_const_vector((vector){{_NVARMAX+9},{_NVARMAX+10}},"fm",(double[]){1.,1.,1.});
init_const_scalar((scalar){_NVARMAX+11},"cm", 1.);  init_scalar((scalar){0},"ibm");  init_scalar((scalar){1},"ibm0");  init_face_vector((vector){{2},{3}},"ibmf");  init_face_vector((vector){{4},{5}},"ibmf0");  init_scalar((scalar){6},"ibmCells");  init_face_vector((vector){{7},{8}},"ibmFaces"); 
#line 68 "./../ibm-gcm.h"
immersed=new_bid();  init_scalar((scalar){9},"divg");  init_scalar((scalar){10},"divg1");  init_scalar((scalar){11},"p");  init_vector((vector){{12},{13}},"u");  init_vector((vector){{14},{15}},"g");  init_scalar((scalar){16},"pf");  init_face_vector((vector){{17},{18}},"uf");  init_vector((vector){{19},{20}},"bi");  init_scalar((scalar){21},"ibalphas");  init_vector((vector){{22},{23}},"normals");  init_vector((vector){{24},{25}},"midPoints");  init_scalar((scalar){26},"cid");  init_scalar((scalar){27},"ch");  init_scalar((scalar){28},"cr");  init_vector((vector){{29},{30}},"nfg");  init_vector((vector){{31},{32}},"nsg");  init_vector((vector){{33},{34}},"divs");  init_scalar((scalar){35},"alphafg");  init_scalar((scalar){36},"alphasg");  init_face_vector((vector){{37},{38}},"ibmf_temp");  init_vector((vector){{39},{40}},"fluxr");  init_scalar((scalar){41},"f");  init_face_vector((vector){{42},{43}},"alphav");  init_scalar((scalar){44},"rhov");  init_scalar((scalar){45},"gginter");  init_scalar((scalar){46},"gf0");  init_scalar((scalar){47},"gf1");  init_scalar((scalar){48},"gf2");  init_scalar((scalar){49},"gf3");  init_scalar((scalar){50},"gf4");  init_scalar((scalar){51},"inter");  init_scalar((scalar){52},"ghostInter");  init_scalar((scalar){53},"extra");    
#line 23 "ast/init_solver.h"
}_attribute[p.i].dirty=1,_attribute[p.i].boundary[right]=_boundary8,_attribute[p.i].boundary_homogeneous[right]=_boundary8_homogeneous;_attribute[p.i].dirty=1,_attribute[p.i].boundary[left]=_boundary9,_attribute[p.i].boundary_homogeneous[left]=_boundary9_homogeneous;_attribute[uf.x.i].dirty=1,_attribute[uf.x.i].boundary[bottom]=_boundary10,_attribute[uf.x.i].boundary_homogeneous[bottom]=_boundary10;_attribute[uf.y.i].dirty=1,_attribute[uf.y.i].boundary[bottom]=_boundary11,_attribute[uf.y.i].boundary_homogeneous[bottom]=_boundary11_homogeneous;_attribute[p.i].dirty=1,_attribute[p.i].boundary[top]=_boundary12,_attribute[p.i].boundary_homogeneous[top]=_boundary12_homogeneous;_attribute[u.y.i].dirty=1,_attribute[u.y.i].boundary[immersed]=_boundary13,_attribute[u.y.i].boundary_homogeneous[immersed]=_boundary13_homogeneous;_attribute[u.x.i].dirty=1,_attribute[u.x.i].boundary[immersed]=_boundary14,_attribute[u.x.i].boundary_homogeneous[immersed]=_boundary14_homogeneous;_attribute[u.x.i].dirty=1,_attribute[u.x.i].boundary[bottom]=_boundary15,_attribute[u.x.i].boundary_homogeneous[bottom]=_boundary15_homogeneous;_attribute[p.i].dirty=1,_attribute[p.i].boundary[right]=_boundary16,_attribute[p.i].boundary_homogeneous[right]=_boundary16_homogeneous;_attribute[pf.i].dirty=1,_attribute[pf.i].boundary[right]=_boundary17,_attribute[pf.i].boundary_homogeneous[right]=_boundary17_homogeneous;  
#line 50 "/home/spencer/basilisk/src/run.h"
event_register((Event){0,1,cleanup,{cleanup_expr0},((int *)0),((double *)0),"/home/spencer/basilisk/src/run.h",50,"cleanup"});  
#line 257 "./../my-centered.h"
event_register((Event){0,1,set_dtmax,{set_dtmax_expr0},((int *)0),((double *)0),"./../my-centered.h",257,"set_dtmax"});  

event_register((Event){0,1,stability,{stability_expr0},((int *)0),((double *)0),"./../my-centered.h",259,"stability"});  









event_register((Event){0,1,vof,{vof_expr0},((int *)0),((double *)0),"./../my-centered.h",269,"vof"});  
event_register((Event){0,1,tracer_advection,{tracer_advection_expr0},((int *)0),((double *)0),"./../my-centered.h",270,"tracer_advection"});  
event_register((Event){0,1,tracer_diffusion,{tracer_diffusion_expr0},((int *)0),((double *)0),"./../my-centered.h",271,"tracer_diffusion"});  






event_register((Event){0,1,properties,{properties_expr0},((int *)0),((double *)0),"./../my-centered.h",278,"properties"});  
#line 361
event_register((Event){0,1,advection_term,{advection_term_expr0},((int *)0),((double *)0),"./../my-centered.h",361,"advection_term"});  
#line 396
event_register((Event){0,1,viscous_term,{viscous_term_expr0},((int *)0),((double *)0),"./../my-centered.h",396,"viscous_term"});  
#line 433
event_register((Event){0,1,acceleration,{acceleration_expr0},((int *)0),((double *)0),"./../my-centered.h",433,"acceleration"});  
#line 485
event_register((Event){0,1,projection,{projection_expr0},((int *)0),((double *)0),"./../my-centered.h",485,"projection"});  
#line 499
event_register((Event){0,1,end_timestep,{end_timestep_expr0},((int *)0),((double *)0),"./../my-centered.h",499,"end_timestep"});  









event_register((Event){0,1,adapt,{adapt_expr0},((int *)0),((double *)0),"./../my-centered.h",509,"adapt"});  
#line 151 "./../ibm-gcm-events.h"
event_register((Event){0,1,acceleration_0,{acceleration_0_expr0},((int *)0),((double *)0),"./../ibm-gcm-events.h",151,"acceleration"});  
#line 289
event_register((Event){0,1,end_timestep_0,{end_timestep_0_expr0},((int *)0),((double *)0),"./../ibm-gcm-events.h",289,"end_timestep"});  
#line 97 "./../my-vof-testv2.h"
event_register((Event){0,1,stability_0,{stability_0_expr0},((int *)0),((double *)0),"./../my-vof-testv2.h",97,"stability"});  
#line 537
event_register((Event){0,1,vof_0,{vof_0_expr0},((int *)0),((double *)0),"./../my-vof-testv2.h",537,"vof"});  
#line 50 "./../my-two-phase-generic.h"
event_register((Event){0,1,tracer_advection_0,{tracer_advection_0_expr0},((int *)0),((double *)0),"./../my-two-phase-generic.h",50,"tracer_advection"});  
#line 83
event_register((Event){0,1,properties_0,{properties_0_expr0},((int *)0),((double *)0),"./../my-two-phase-generic.h",83,"properties"});  
#line 46 "./../my-iforce.h"
event_register((Event){0,1,acceleration_1,{acceleration_1_expr0},((int *)0),((double *)0),"./../my-iforce.h",46,"acceleration"});  
#line 41 "./../my-tension.h"
event_register((Event){0,1,stability_1,{stability_1_expr0},((int *)0),((double *)0),"./../my-tension.h",41,"stability"});  
#line 85
event_register((Event){0,1,acceleration_2,{acceleration_2_expr0},((int *)0),((double *)0),"./../my-tension.h",85,"acceleration"});  
#line 24 "ast/init_solver.h"
}
  set_fpe();
}
